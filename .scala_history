import scala.xml.XML
val f = XML.load("test.xml")
import 4~._ie.tcd.slscs.itut.AinmNerCorpus
import ie.tcd.slscs.itut.AinmNerCorpus._
TEIHeader.readParagraphs(f)
import scala.xml._
val f = <foo/>
f.name
f
f.namespace
f.toString
import ie.tcd.slscs.itut.AinmNerCorpus._
val f = XML.load("test.xml")
import scala.xml.XML
val f = XML.load("test.xml")
TEIHeader.readParagraphs(f)
import scala.xml.XML
val f = XML.load("test.xml")
import ie.tcd.slscs.itut.AinmNerCorpus._
TEIHeader.readParagraphs(f)
import ie.tcd.slscs.itut.AinmNerCorpus._
import scala.xml.XML
val f = XML.load("test.xml")
TEIHeader.readParagraphs(f)
import ie.tcd.slscs.itut.AinmNerCorpus._
import scala.xml.XML
val f = XML.load("test.xml")
TEIHeader.readParagraphs(f)
val paras = TEIHeader.readParagraphs(f)
val para = paras(0)
para.getText
import ie.tcd.slscs.itut.gramadanj.FileUtils
val foo = FileUtils.isDirectory("/home/jim/www.ainm.ie")
val files = FileUtils.getFileListStartsWith("/home/jim/www.ainm.ie", "Bio")
files.toList
import scala.xml.XML
XML.loadFile(files(0))
import ie.tcd.slscs.itut.AinmNerCorpus
import ie.tcd.slscs.itut.AinmNerCorpus.TEIReader
AinmNerCorpus
val fo = EduInst("foo", "TCD", "")
val fo = AinmNerCorpus.EduInst("foo", "TCD", "")
import ie.tcd.slscs.itut.AinmNerCorpus.*
import ie.tcd.slscs.itut.AinmNerCorpus._
val fo = EduInst("foo", "TCD", "")
  def filterNERType(kind: String, l: List[NERText]): List[NERText] = {
    def filterinner(n: NERText, kind: String): NERText = n match {
      case EntityReference(t, k) = {
        if(k == kind) {
          EntityReference(t, k)
        } else {
          TextPart(t)
        }
      }
      case TextPart(t) => TextPart(t)
    }
    l.map{e => filterinner(e, kind)}
  }
import ie.tcd.slscs.itut.AinmNerCorpus._
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{readFile}
val docs = files.map{AinmProcess.readFile}
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{AinmProcess.readFile}
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{AinmProcess.readFile}
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{AinmProcess.readFile}
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{AinmProcess.readFile}
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{AinmProcess.readFile}
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{AinmProcess.readFile}
val doc1 = docs(0)
AinmProcess.sentdetect.sentPosDetect("Chuir se e. Agus anois.")
val f = AinmProcess.sentdetect.sentPosDetect("Chuir se e. Agus anois.")
def splitParagraph(p: Paragraph): Array[Span] = AinmProcess.sentdetect.sentPosDetect(p.getText)
import  ie.tcd.slscs.itut.AinmNerCorpus.AinmReader
import  ie.tcd.slscs.itut.AinmNerCorpus._
def splitParagraph(p: Paragraph): Array[Span] = AinmProcess.sentdetect.sentPosDetect(p.getText)
import opennlp.tools.util.Span
def splitParagraph(p: Paragraph): Array[Span] = AinmProcess.sentdetect.sentPosDetect(p.getText)
  def splitParagraphs(l: List[Paragraphs]): List[Array[Span]] = l.map{splitParagraph}
  def splitParagraphs(l: List[Paragraph]): List[Array[Span]] = l.map{splitParagraph}
splitParagraphs(doc1)
val split = splitParagraphs(doc1)
val test = "thing to test"
test.replaceAll(" ", "_").toCharArray.sliding(2).toList
test.replaceAll(" ", "_").toCharArray.sliding(2).map{mkString}
test.replaceAll(" ", "_").toCharArray.sliding(2).map{_.mkString}
test.replaceAll(" ", "_").toCharArray.sliding(2).map{_.mkString}.toList
val s = Span(2, 3)
import opennlp.tools.util.Span
val s = Span(2, 3)
val s = new Span(2,3)
import  ie.tcd.slscs.itut.AinmNerCorpus._
import  ie.tcd.slscs.itut.AinmNerCorpus.AinmReader
val foo = "gaois.ie-crp-tmx-irish-legislation-2017-07-12.tmx"
foo.substring(0, foo.length - 4)
  abstract class TrRule(tag: String) {
    def getTag:String = tag
  }
  abstract class Token(tags: List[String]) {
    def getTags = tags
  }
  case class LemmaToken(lemma: String, tags: List[String]) extends Token(tags)
  case class TagsToken(tags: List[String]) extends Token(tags)
  abstract class AlignedToken(tags: List[String], pos: Int) extends Token(tags)
  case class LemmaAlignedToken(lemma: String, tags: List[String], pos: Int) extends AlignedToken(tags, pos)
  case class TagsAlignedToken(tags: List[String], pos: Int) extends AlignedToken(tags, pos)
  case class RulePiece(src: List[Token], trg: List[Token],
                       al: Map[Int, Array[Int]], srcmac: List[Macro],
                       trgmac: List[Macro], srceg: String, trgeg: String)
  case class MultiPartRule(tag: String, parts: List[RulePiece]) extends TrRule(tag)
  case class Rule(tag: String, src: List[Token], trg: List[Token],
                  srcal: Map[Int, Array[Int]], srcmac: List[Macro],
                  trgmac: List[Macro], srceg: String, trgeg: String) extends TrRule(tag)
  implicit def RuleToMultiPart(r: Rule): MultiPartRule = {
    val rp:RulePiece = RulePiece(r.src, r.trg, r.srcal, r.srcmac, r.trgmac, r.srceg, r.trgeg)
    MultiPartRule(r.tag, List[RulePiece](rp))
  }
  def flipMacro(pos: Int, mac: Macro): Macro = {
    Macro(mac.name, mac.params.map{e => if (e <= pos) e else -e})
  }
  case class Macro(name: String, params: List[Int])
  case class RulePiece(src: List[Token], trg: List[Token],
                       al: Map[Int, Array[Int]], srcmac: List[Macro],
                       trgmac: List[Macro], srceg: String, trgeg: String)
  case class MultiPartRule(tag: String, parts: List[RulePiece]) extends TrRule(tag)
  case class Rule(tag: String, src: List[Token], trg: List[Token],
                  srcal: Map[Int, Array[Int]], srcmac: List[Macro],
                  trgmac: List[Macro], srceg: String, trgeg: String) extends TrRule(tag)
  implicit def RuleToMultiPart(r: Rule): MultiPartRule = {
    val rp:RulePiece = RulePiece(r.src, r.trg, r.srcal, r.srcmac, r.trgmac, r.srceg, r.trgeg)
    MultiPartRule(r.tag, List[RulePiece](rp))
  }
  def flipMacro(pos: Int, mac: Macro): Macro = {
    Macro(mac.name, mac.params.map{e => if (e <= pos) e else -e})
  }
  def stringToMacro(s: String): Option[Macro] = {
    val in = s.split(":")
    if(in.length != 2) {
      None
    }
    val params = in(1).split(",").map{_.trim}.map{_.toInt}.toList
    Some(Macro(in(0), params))
  }
  implicit def stringToMacroList(s: String): List[Macro] = s.split(" ").flatMap{stringToMacro}.toList
stringToMacroList("agree:1,2")
flipMacro(2, m)
val m =stringToMacroList("agree:1,2")
flipMacro(2, m)
flipMacro(2, m(0))
flipMacro(1, m(0))
  def cart(l: List[List[String]]): List[List[String]] = l match {
    case Nil => List(Nil)
    case h :: t => for(e <- h; rest <- cart(t)) yield e :: rest
}
cart(List(List("a", "b"), List("1", "2", "3")))
val ll = List("aa", "ab", "ac", "bb", "bc", "cc")
ll.map => (e => e.substring(0, 1) -> e)
ll.map(e => e.substring(0, 1) -> e)
ll.map(e => e.substring(0, 1) -> e).toMap
ll.map(e => e.substring(0, 1) -> e).mkMap
ll.map(e => e.substring(0, 1) -> e).flatmap
ll.map(e => e.substring(0, 1) -> e)
ll.map(e => e.substring(0, 1) -> e).flatten
ll.map(e => e.substring(0, 1) -> e).
ll.foldLeft(e => e.substring(0, 1) -> e)
ll.foldLeft(Map(String, List(String))(e => e.substring(0, 1) -> e)
ll.foldLeft(Map(String, List(String)))(e => e.substring(0, 1) -> e)
ll.foldLeft(Map(String, List[String]))(e => e.substring(0, 1) -> e)
ll.foldLeft(Map(String, List[String]()))(e => e.substring(0, 1) -> e)
ll.foldLeft(Map[String, List[String]()])(e => e.substring(0, 1) -> e)
ll.foldLeft(Map[String, List[String]]())(e => e.substring(0, 1) -> e)
ll.foldLeft(Map[String, List[String]]())(e: String => e.substring(0, 1) -> e)
ll.map => (e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2__
ll.map => (e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2))
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2))
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2)).sort
  def prpersMaker(tags: String): List[String] = {
    def gender(s: String) = if(s.contains("Masc")) "m" else if(s.contains("Fem")) "f" else "mf"
    def number(s: String) = if(s.contains("Sg")) "sg" else if(s.contains("Pl")) "pl" else "sp"
    def person(s: String) = if(s.contains("1P")) "p1" else if(s.contains("2P")) "p2" else "p3"
    def addtags(s: String) = List[String](person(s), gender(s), number(s))
    if(!tags.contains("Pron+Prep")) {
      List.empty[String]
    } else {
      val base = List("prn", "obj")
      base ++ addtags(tags)
    }
  }
prpersMaker("+Pron+Prep+3P+Sg+Masc")
val foo = List[String]("ba", "bla", null)
val foo = List[String]("ba", "bla", None)
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2)).sort
val ll = List("aa", "ab", "ac", "bb", "bc", "cc")
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2)).sort
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2))
ll.map(e => e.substring(0, 1) -> e)
val ll = List("aa", "ab", "ac", "bb", "bc", "cc")
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2))
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).map(case (k, v) => v)
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).map( case (k, v) => v)
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).map{case (k, v) => v}
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2))
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1)..map{case (k, v) => k -> v.map{_._2}}
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).map{case (k, v) => k -> v.map{_._2}}
ll.zipWithIndex
ll.zipWithIndex.map{e => (e._1, e._2 + 1)}
val f = "Magazyn KOT, podarowany w prezencie członkom klubu, cieszył się ogromnym powodzeniem i bez problemów znajdował czytelników o polskich korzeniach, którzy tłumaczyli teksty na hebrajski."
f.length
val tip = "+Foo+CU+Bar"
val tip = if(tags.startsWith("+")) tags.substring(1) else tags
val tags = "+Foo+CU+Bar"
val tip = if(tags.startsWith("+")) tags.substring(1) else tags
val bla = tip.split("\\+")
//val blah = bla.filter{
val l = List("CC", "CM", "CU")
val blah = bla.filter{!l.contains(_)}
val balaha = bla.filter{l.contains(_)}
val tags = "+Foo+CU+Bar+CM"
val tip = if(tags.startsWith("+")) tags.substring(1) else tags
val bla = tip.split("\\+")
val blah = bla.filter{!l.contains(_)}
val balaha = bla.filter{l.contains(_)}.mkString(",")
val tags = "+Foo+CU+Bar"
val tip = if(tags.startsWith("+")) tags.substring(1) else tags
val bla = tip.split("\\+")
val balaha = bla.filter{l.contains(_)}.mkString(",")
  val DIALECTS = List("CC", "CM", "CU")
  def getDialect(tags: String): String = {
    val tagsw = if(tags.startsWith("+")) tags.substring(1) else tags
    tagsw.split("\\+").filter{DIALECTS.contains(_)}.mkString(",")
  }
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2))
val foo ="+Verb+Pres"
foo.replace("+Verb", "+Vbser")
val mp = Map("ng" -> "g", "bhf" -> "f")
val foo = List("a", "b", "c")
val bar = List("1")
for (a <- bar; b <- foo) yield a :: b
for (a <- bar; b <- foo) yield List(a) :: b
bar.zip(foo)
val a = List("1", "2", "3")
val b = Map("3" -> List(List("a"), List("a", "b"), List("a", "b", "c"))
)
case class TNode(v: String)
case class NTNode(v: List[List[String]])
abstract class Node
case class TNode(v: String) extends Node
case class NTNode(v: List[List[String]]) extends Node
def mkNodes(l: List[String]): List[Node] = {
def mkNode(s: String) = if(b.contains(s)) {
NTNode(b(s))
} else {
TNode(s)
}
l.map{mkNode}
}
mkNodes(a)
def expandNodes(l: List[Node]): List[List[String]] = {
def expandInner(n: Node, acc: List[List[String]]) = n match {
case TNode(s) => 
def expandNodes(l: List[Node]): List[List[String]] = {
def expandInner(n: List[Node], acc: List[List[String]]) = n match {
case Nil => acc
val s = "1"
val t = List("a", "b", "c")
val u = t.map{e => List(s, e)}
val s = List("1", "2")
val u = s.map{ a => t.map{ b => List(a, b)} }
val u = s.map{ a => t.map{ b => List(a, b)} }.flatten
case Node(s) :: xs => expandInner(xs, acc.map{ e => e :+ Node(s) }
case NTNode(v) :: xs => expandInner(xs, acc.map{ e => e.map{ f => List(e, f)}}.flatten)
def expandNodes(l: List[Node]): List[List[String]] = {
def expandInner(n: List[Node], acc: List[List[String]]) = n match {
case Nil => acc
case TNode(s) :: xs => expandInner(xs, acc.map{ e => e :+ Node(s) }
)
case NTNode(v) :: xs => expandInner(xs, acc.map{ e => e.map{ f => List(e, f)}}.flatten)
}
expandInner(l, List.empty[List[String]])
}
def expandNodes(l: List[Node]): List[List[String]] = {
def expandInner(n: List[Node], acc: List[List[String]]): List[List[String]] = n match {
case Nil => acc
case TNode(s) :: xs => expandInner(xs, acc.map{ e => e :+ Node(s) })
case NTNode(v) :: xs => expandInner(xs, acc.map{ e => e.map{ f => List(e, f)}}.flatten)
}
expandInner(l, List.empty[List[String]])
}
  def expandNodes(l: List[Node]): List[List[Node]] = {
    def expandInner(n: List[Node], acc: List[List[Node]]): List[List[Node]] = n match {
      case Nil => acc
      case TNode(s) :: xs => expandInner(xs, acc.map{ e => e :+ TNode(s) })
      case NTNode(v) :: xs => expandInner(xs, acc.map{ e: List[Node]  => v.map{ f: List[Node] => List(e, f)}}.flatten.flatten)
    }
    expandInner(l, List.empty[List[Node]])
  }
  abstract class Node
  case class TNode(v: String) extends Node
  case class NTNode(v: List[List[Node]]) extends Node
  def mkNodes(l: List[String], b: Map[String,List[List[Node]]]): List[Node] = {
    def mkNode(s: String) = if(b.contains(s)) {
      NTNode(b(s))
    } else {
      TNode(s)
    }
    l.map{mkNode}
  }
  def expandNodes(l: List[Node]): List[List[Node]] = {
    def expandInner(n: List[Node], acc: List[List[Node]]): List[List[Node]] = n match {
      case Nil => acc
      case TNode(s) :: xs => expandInner(xs, acc.map{ e => e :+ TNode(s) })
      case NTNode(v) :: xs => expandInner(xs, acc.map{ e: List[Node]  => v.map{ f: List[Node] => List(e, f)}}.flatten.flatten)
    }
    expandInner(l, List.empty[List[Node]])
  }
val b = Map("3" -> List(List("a"), List("a", "b"), List("a", "b", "c"))
)
val c = b.map{e -> (e._1, e.map{_.map{f => TNode(f)}}}
val c = b.map{e -> (e._1, e.map{_.map{f => TNode(f)}})}
val c = b.map{e -> (e._1, e._2.map{_.map{f => TNode(f)}})}
val foo = Map(1 -> 2, 2 -> 3)
foo.map{e => (e._1, e._2 + 1)}
def toNodes(b: Map[String, List[List[String]]]): List[List[Node]] = b.map{e => (e._1, e._2.map{_.map{g => TNode(g)}})}
def toNodes(b: Map[String, List[List[String]]]): Map[String, List[List[Node]]] = b.map{e => (e._1, e._2.map{_.map{g => TNode(g)}})}
c = toNodes(b)
val c = toNodes(b)
mkNodes(a)
val d = mkNodes(a, c)
expandNodes(d)
  def expandNodes(l: List[Node]): List[List[Node]] = {
    def expandInner(n: List[Node], acc: List[List[Node]]): List[List[Node]] = n match {
      case Nil => acc
      case TNode(s) :: xs => expandInner(xs, acc.map{ e => e :+ TNode(s) })
      case NTNode(v) :: xs => expandInner(xs, acc.flatMap{ e: List[Node]  => v.flatMap{ f: List[Node] => List(e, f)}})
    }
    expandInner(l, List.empty[List[Node]])
  }
expandNodes(d)
val u = s.map{ a => t.map{ b => List(a, b)} }.flatten
val u = p.map{ a => t.map{ b => List(a, b)} }.flatten
val p = List.empty[String]
val u = p.map{ a => t.map{ b => List(a, b)} }.flatten
val u = p.flatMap{ a => t.map{ b => List(a, b)} }
  def expandNodes(l: List[Node]): List[List[Node]] = {
    def expandInner(n: List[Node], acc: List[List[Node]]): List[List[Node]] = n match {
      case Nil => acc
      case TNode(s) :: xs => if(acc.isEmpty) {
        expandInner(xs, List(List(TNode(s))))
      } else {
        expandInner(xs, acc.map{ e => e :+ TNode(s) })
      }
      case NTNode(v) :: xs => if(acc.isEmpty) {
        expandInner(xs, v)
      } else {
        expandInner(xs, acc.flatMap { e: List[Node] => v.flatMap { f: List[Node] => List(e, f) } })
      }
    }
    expandInner(l, List.empty[List[Node]])
  }
expandNodes(d)
expandNodes(d).flatten
  def expandNodes(l: List[Node]): List[List[Node]] = {
    def expandInner(n: List[Node], acc: List[List[Node]]): List[List[Node]] = n match {
      case Nil => acc
      case TNode(s) :: xs => if(acc.isEmpty) {
        expandInner(xs, List(List(TNode(s))))
      } else {
        expandInner(xs, acc.map{ e => e :+ TNode(s) })
      }
      case NTNode(v) :: xs => if(acc.isEmpty) {
        expandInner(xs, v)
      } else {
        expandInner(xs, acc.flatMap { e: List[Node] => v.flatMap { f: List[Node] => List(List(e, f).flatten) } })
      }
    }
    expandInner(l, List.empty[List[Node]])
  }
expandNodes(d)
expandNodes(d).flatten
expandNodes(d)
val a = List("1", "2", "3" "4", "3")
val a = List("1", "2", "3", "4", "3")
val mp = Map("ng" -> "g", "bhf" -> "f")
val d = mkNodes(a, c)
expandNodes(d)
  val mutationStarts: Map[Char, List[String]] = Map('b' -> List("mb", "bh"), 'c' -> List("gc", "ch"), 'd' -> List("nd", "dh"),
    'f' -> List("bhf", "fh"), 'g' -> List("ng", "gh"), 'm' -> List("mh"), 'p' -> List("bp", "ph"), 's' -> List("ts", "sh"),
    't' -> List("dt", "th"), 'a' -> List("h-a", "t-a", "n-a"), 'e' -> List("h-e", "t-e", "n-e"),
    'i' -> List("h-i", "t-i", "n-i"), 'o' -> List("h-o", "t-o", "n-o"), 'u' -> List("h-u", "t-u", "n-u"),
    'á' -> List("h-á", "t-á", "n-á"), 'é' -> List("h-é", "t-é", "n-é"),
    'í' -> List("h-í", "t-í", "n-í"), 'ó' -> List("h-ó", "t-ó", "n-ó"), 'ú' -> List("h-ú", "t-ú", "n-ú"),
    'B' -> List("mB", "Bh"), 'C' -> List("gC", "Ch"), 'D' -> List("nD", "Dh"),
    'F' -> List("bhF", "Fh"), 'G' -> List("nG", "Gh"), 'M' -> List("Mh"), 'P' -> List("bP", "Ph"), 'S' -> List("tS", "Sh"),
    'T' -> List("dT", "Th"), 'A' -> List("hA", "tA", "nA"), 'E' -> List("hE", "tE", "nE"),
    'I' -> List("hI", "tI", "nI"), 'O' -> List("hO", "tO", "nO"), 'U' -> List("hU", "tU", "nU"),
    'Á' -> List("hÁ", "tÁ", "nÁ"), 'É' -> List("hÉ", "tÉ", "nÉ"),
    'Í' -> List("hÍ", "tÍ", "nÍ"), 'Ó' -> List("hÓ", "tÓ", "nÓ"), 'Ú' -> List("hÚ", "tÚ", "nÚ"))
def find_beginning(s: String, l: List[String]): Int = {
for(ent <- l) {
if(s.startsWith(ent) {
s.length
}
val foo = List("bh", "mb")
def fbeg(s: String, l: List[String]): Int = {
val f = l.dropWhile(e => !s.startsWith(e))
if(f.length == 0) {
0
} else {
f.head.length
}
fbeg("bad", foo)
fbeg("bhad", foo)
fbeg("mbad", foo)
  val mutationStarts: Map[Char, List[String]] = Map('b' -> List("mb", "bh"), 'c' -> List("gc", "ch"), 'd' -> List("nd", "dh"),
    'f' -> List("bhf", "fh"), 'g' -> List("ng", "gh"), 'm' -> List("mh"), 'p' -> List("bp", "ph"), 's' -> List("ts", "sh"),
    't' -> List("dt", "th"), 'a' -> List("h-a", "t-a", "n-a"), 'e' -> List("h-e", "t-e", "n-e"),
    'i' -> List("h-i", "t-i", "n-i"), 'o' -> List("h-o", "t-o", "n-o"), 'u' -> List("h-u", "t-u", "n-u"),
    'á' -> List("h-á", "t-á", "n-á"), 'é' -> List("h-é", "t-é", "n-é"),
    'í' -> List("h-í", "t-í", "n-í"), 'ó' -> List("h-ó", "t-ó", "n-ó"), 'ú' -> List("h-ú", "t-ú", "n-ú"),
    'B' -> List("mB", "Bh"), 'C' -> List("gC", "Ch"), 'D' -> List("nD", "Dh"),
    'F' -> List("bhF", "Fh"), 'G' -> List("nG", "Gh"), 'M' -> List("Mh"), 'P' -> List("bP", "Ph"), 'S' -> List("tS", "Sh"),
    'T' -> List("dT", "Th"), 'A' -> List("hA", "tA", "nA"), 'E' -> List("hE", "tE", "nE"),
    'I' -> List("hI", "tI", "nI"), 'O' -> List("hO", "tO", "nO"), 'U' -> List("hU", "tU", "nU"),
    'Á' -> List("hÁ", "tÁ", "nÁ"), 'É' -> List("hÉ", "tÉ", "nÉ"),
    'Í' -> List("hÍ", "tÍ", "nÍ"), 'Ó' -> List("hÓ", "tÓ", "nÓ"), 'Ú' -> List("hÚ", "tÚ", "nÚ"))
  def findBeginning(s: String, l: List[String]): Int = {
    val f = l.dropWhile(e => !s.startsWith(e))
    if(f.length == 0) {
      0
    } else {
      f.head.length
    }
  }
  def stemWord(a: String, b: String): String = {
    if(a == "" || b == "") {
      ""
    }
    val first_char = a.charAt(0)
    val j = findBeginning(b, mutationStarts(first_char))
    val i = if(j == 0) 0 else 1
    val comp_a = a.substring(i)
    val comp_b = b.substring(j)
    val inner = (comp_a, comp_b).zipped.takeWhile(Function.tupled(_ == _)).map(_._1).mkString
    if(i != 0) {
      first_char + inner
    } else {
      inner
    }
  }
stemWord("bad", "mbaid")
val strs = List("thing", "is", "shortest")
strs.reduceLeft(_.length < _.length)
strs.reduceLeft((a, b) => a.length < b.length)
strs.reduceLeft((a: String, b:String) => a.length < b.length)
strs.reduceLeft((a, b) => if(a.length < b.length) a else b)
val strs = List("thing", "is", "shortest", "at")
strs.reduceLeft((a, b) => if(a.length < b.length) a else b)
val f = List("at", "as", "art")
val s = f.reduceLeft((a, b) => if(a.length < b.length) a else b)
val g = f.filter(_.length == s.length)
"foo".startsWith("")
"foo".startsWith("a")
val a = (1, 2, 3)
val b = (2, 3, 4)
val c = (3, 4, 5)
val abc = List(a, b, c)
val e = ""
e.split(" ")
