import scala.xml.XML
val f = XML.load("test.xml")
import 4~._ie.tcd.slscs.itut.AinmNerCorpus
import ie.tcd.slscs.itut.AinmNerCorpus._
TEIHeader.readParagraphs(f)
import scala.xml._
val f = <foo/>
f.name
f
f.namespace
f.toString
import ie.tcd.slscs.itut.AinmNerCorpus._
val f = XML.load("test.xml")
import scala.xml.XML
val f = XML.load("test.xml")
TEIHeader.readParagraphs(f)
import scala.xml.XML
val f = XML.load("test.xml")
import ie.tcd.slscs.itut.AinmNerCorpus._
TEIHeader.readParagraphs(f)
import ie.tcd.slscs.itut.AinmNerCorpus._
import scala.xml.XML
val f = XML.load("test.xml")
TEIHeader.readParagraphs(f)
import ie.tcd.slscs.itut.AinmNerCorpus._
import scala.xml.XML
val f = XML.load("test.xml")
TEIHeader.readParagraphs(f)
val paras = TEIHeader.readParagraphs(f)
val para = paras(0)
para.getText
import ie.tcd.slscs.itut.gramadanj.FileUtils
val foo = FileUtils.isDirectory("/home/jim/www.ainm.ie")
val files = FileUtils.getFileListStartsWith("/home/jim/www.ainm.ie", "Bio")
files.toList
import scala.xml.XML
XML.loadFile(files(0))
import ie.tcd.slscs.itut.AinmNerCorpus
import ie.tcd.slscs.itut.AinmNerCorpus.TEIReader
AinmNerCorpus
val fo = EduInst("foo", "TCD", "")
val fo = AinmNerCorpus.EduInst("foo", "TCD", "")
import ie.tcd.slscs.itut.AinmNerCorpus.*
import ie.tcd.slscs.itut.AinmNerCorpus._
val fo = EduInst("foo", "TCD", "")
  def filterNERType(kind: String, l: List[NERText]): List[NERText] = {
    def filterinner(n: NERText, kind: String): NERText = n match {
      case EntityReference(t, k) = {
        if(k == kind) {
          EntityReference(t, k)
        } else {
          TextPart(t)
        }
      }
      case TextPart(t) => TextPart(t)
    }
    l.map{e => filterinner(e, kind)}
  }
import ie.tcd.slscs.itut.AinmNerCorpus._
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{readFile}
val docs = files.map{AinmProcess.readFile}
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{AinmProcess.readFile}
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{AinmProcess.readFile}
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{AinmProcess.readFile}
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{AinmProcess.readFile}
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{AinmProcess.readFile}
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{AinmProcess.readFile}
val doc1 = docs(0)
AinmProcess.sentdetect.sentPosDetect("Chuir se e. Agus anois.")
val f = AinmProcess.sentdetect.sentPosDetect("Chuir se e. Agus anois.")
def splitParagraph(p: Paragraph): Array[Span] = AinmProcess.sentdetect.sentPosDetect(p.getText)
import  ie.tcd.slscs.itut.AinmNerCorpus.AinmReader
import  ie.tcd.slscs.itut.AinmNerCorpus._
def splitParagraph(p: Paragraph): Array[Span] = AinmProcess.sentdetect.sentPosDetect(p.getText)
import opennlp.tools.util.Span
def splitParagraph(p: Paragraph): Array[Span] = AinmProcess.sentdetect.sentPosDetect(p.getText)
  def splitParagraphs(l: List[Paragraphs]): List[Array[Span]] = l.map{splitParagraph}
  def splitParagraphs(l: List[Paragraph]): List[Array[Span]] = l.map{splitParagraph}
splitParagraphs(doc1)
val split = splitParagraphs(doc1)
val test = "thing to test"
test.replaceAll(" ", "_").toCharArray.sliding(2).toList
test.replaceAll(" ", "_").toCharArray.sliding(2).map{mkString}
test.replaceAll(" ", "_").toCharArray.sliding(2).map{_.mkString}
test.replaceAll(" ", "_").toCharArray.sliding(2).map{_.mkString}.toList
val s = Span(2, 3)
import opennlp.tools.util.Span
val s = Span(2, 3)
val s = new Span(2,3)
import  ie.tcd.slscs.itut.AinmNerCorpus._
import  ie.tcd.slscs.itut.AinmNerCorpus.AinmReader
val foo = "gaois.ie-crp-tmx-irish-legislation-2017-07-12.tmx"
foo.substring(0, foo.length - 4)
  abstract class TrRule(tag: String) {
    def getTag:String = tag
  }
  abstract class Token(tags: List[String]) {
    def getTags = tags
  }
  case class LemmaToken(lemma: String, tags: List[String]) extends Token(tags)
  case class TagsToken(tags: List[String]) extends Token(tags)
  abstract class AlignedToken(tags: List[String], pos: Int) extends Token(tags)
  case class LemmaAlignedToken(lemma: String, tags: List[String], pos: Int) extends AlignedToken(tags, pos)
  case class TagsAlignedToken(tags: List[String], pos: Int) extends AlignedToken(tags, pos)
  case class RulePiece(src: List[Token], trg: List[Token],
                       al: Map[Int, Array[Int]], srcmac: List[Macro],
                       trgmac: List[Macro], srceg: String, trgeg: String)
  case class MultiPartRule(tag: String, parts: List[RulePiece]) extends TrRule(tag)
  case class Rule(tag: String, src: List[Token], trg: List[Token],
                  srcal: Map[Int, Array[Int]], srcmac: List[Macro],
                  trgmac: List[Macro], srceg: String, trgeg: String) extends TrRule(tag)
  implicit def RuleToMultiPart(r: Rule): MultiPartRule = {
    val rp:RulePiece = RulePiece(r.src, r.trg, r.srcal, r.srcmac, r.trgmac, r.srceg, r.trgeg)
    MultiPartRule(r.tag, List[RulePiece](rp))
  }
  def flipMacro(pos: Int, mac: Macro): Macro = {
    Macro(mac.name, mac.params.map{e => if (e <= pos) e else -e})
  }
  case class Macro(name: String, params: List[Int])
  case class RulePiece(src: List[Token], trg: List[Token],
                       al: Map[Int, Array[Int]], srcmac: List[Macro],
                       trgmac: List[Macro], srceg: String, trgeg: String)
  case class MultiPartRule(tag: String, parts: List[RulePiece]) extends TrRule(tag)
  case class Rule(tag: String, src: List[Token], trg: List[Token],
                  srcal: Map[Int, Array[Int]], srcmac: List[Macro],
                  trgmac: List[Macro], srceg: String, trgeg: String) extends TrRule(tag)
  implicit def RuleToMultiPart(r: Rule): MultiPartRule = {
    val rp:RulePiece = RulePiece(r.src, r.trg, r.srcal, r.srcmac, r.trgmac, r.srceg, r.trgeg)
    MultiPartRule(r.tag, List[RulePiece](rp))
  }
  def flipMacro(pos: Int, mac: Macro): Macro = {
    Macro(mac.name, mac.params.map{e => if (e <= pos) e else -e})
  }
  def stringToMacro(s: String): Option[Macro] = {
    val in = s.split(":")
    if(in.length != 2) {
      None
    }
    val params = in(1).split(",").map{_.trim}.map{_.toInt}.toList
    Some(Macro(in(0), params))
  }
  implicit def stringToMacroList(s: String): List[Macro] = s.split(" ").flatMap{stringToMacro}.toList
stringToMacroList("agree:1,2")
flipMacro(2, m)
val m =stringToMacroList("agree:1,2")
flipMacro(2, m)
flipMacro(2, m(0))
flipMacro(1, m(0))
  def cart(l: List[List[String]]): List[List[String]] = l match {
    case Nil => List(Nil)
    case h :: t => for(e <- h; rest <- cart(t)) yield e :: rest
}
cart(List(List("a", "b"), List("1", "2", "3")))
val ll = List("aa", "ab", "ac", "bb", "bc", "cc")
ll.map => (e => e.substring(0, 1) -> e)
ll.map(e => e.substring(0, 1) -> e)
ll.map(e => e.substring(0, 1) -> e).toMap
ll.map(e => e.substring(0, 1) -> e).mkMap
ll.map(e => e.substring(0, 1) -> e).flatmap
ll.map(e => e.substring(0, 1) -> e)
ll.map(e => e.substring(0, 1) -> e).flatten
ll.map(e => e.substring(0, 1) -> e).
ll.foldLeft(e => e.substring(0, 1) -> e)
ll.foldLeft(Map(String, List(String))(e => e.substring(0, 1) -> e)
ll.foldLeft(Map(String, List(String)))(e => e.substring(0, 1) -> e)
ll.foldLeft(Map(String, List[String]))(e => e.substring(0, 1) -> e)
ll.foldLeft(Map(String, List[String]()))(e => e.substring(0, 1) -> e)
ll.foldLeft(Map[String, List[String]()])(e => e.substring(0, 1) -> e)
ll.foldLeft(Map[String, List[String]]())(e => e.substring(0, 1) -> e)
ll.foldLeft(Map[String, List[String]]())(e: String => e.substring(0, 1) -> e)
ll.map => (e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2__
ll.map => (e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2))
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2))
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2)).sort
  def prpersMaker(tags: String): List[String] = {
    def gender(s: String) = if(s.contains("Masc")) "m" else if(s.contains("Fem")) "f" else "mf"
    def number(s: String) = if(s.contains("Sg")) "sg" else if(s.contains("Pl")) "pl" else "sp"
    def person(s: String) = if(s.contains("1P")) "p1" else if(s.contains("2P")) "p2" else "p3"
    def addtags(s: String) = List[String](person(s), gender(s), number(s))
    if(!tags.contains("Pron+Prep")) {
      List.empty[String]
    } else {
      val base = List("prn", "obj")
      base ++ addtags(tags)
    }
  }
prpersMaker("+Pron+Prep+3P+Sg+Masc")
val foo = List[String]("ba", "bla", null)
val foo = List[String]("ba", "bla", None)
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2)).sort
val ll = List("aa", "ab", "ac", "bb", "bc", "cc")
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2)).sort
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2))
ll.map(e => e.substring(0, 1) -> e)
val ll = List("aa", "ab", "ac", "bb", "bc", "cc")
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2))
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).map(case (k, v) => v)
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).map( case (k, v) => v)
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).map{case (k, v) => v}
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2))
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1)..map{case (k, v) => k -> v.map{_._2}}
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).map{case (k, v) => k -> v.map{_._2}}
ll.zipWithIndex
ll.zipWithIndex.map{e => (e._1, e._2 + 1)}
val f = "Magazyn KOT, podarowany w prezencie członkom klubu, cieszył się ogromnym powodzeniem i bez problemów znajdował czytelników o polskich korzeniach, którzy tłumaczyli teksty na hebrajski."
f.length
val tip = "+Foo+CU+Bar"
val tip = if(tags.startsWith("+")) tags.substring(1) else tags
val tags = "+Foo+CU+Bar"
val tip = if(tags.startsWith("+")) tags.substring(1) else tags
val bla = tip.split("\\+")
//val blah = bla.filter{
val l = List("CC", "CM", "CU")
val blah = bla.filter{!l.contains(_)}
val balaha = bla.filter{l.contains(_)}
val tags = "+Foo+CU+Bar+CM"
val tip = if(tags.startsWith("+")) tags.substring(1) else tags
val bla = tip.split("\\+")
val blah = bla.filter{!l.contains(_)}
val balaha = bla.filter{l.contains(_)}.mkString(",")
val tags = "+Foo+CU+Bar"
val tip = if(tags.startsWith("+")) tags.substring(1) else tags
val bla = tip.split("\\+")
val balaha = bla.filter{l.contains(_)}.mkString(",")
  val DIALECTS = List("CC", "CM", "CU")
  def getDialect(tags: String): String = {
    val tagsw = if(tags.startsWith("+")) tags.substring(1) else tags
    tagsw.split("\\+").filter{DIALECTS.contains(_)}.mkString(",")
  }
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2))
val foo ="+Verb+Pres"
foo.replace("+Verb", "+Vbser")
