import scala.xml.XML
val f = XML.load("test.xml")
import 4~._ie.tcd.slscs.itut.AinmNerCorpus
import ie.tcd.slscs.itut.AinmNerCorpus._
TEIHeader.readParagraphs(f)
import scala.xml._
val f = <foo/>
f.name
f
f.namespace
f.toString
import ie.tcd.slscs.itut.AinmNerCorpus._
val f = XML.load("test.xml")
import scala.xml.XML
val f = XML.load("test.xml")
TEIHeader.readParagraphs(f)
import scala.xml.XML
val f = XML.load("test.xml")
import ie.tcd.slscs.itut.AinmNerCorpus._
TEIHeader.readParagraphs(f)
import ie.tcd.slscs.itut.AinmNerCorpus._
import scala.xml.XML
val f = XML.load("test.xml")
TEIHeader.readParagraphs(f)
import ie.tcd.slscs.itut.AinmNerCorpus._
import scala.xml.XML
val f = XML.load("test.xml")
TEIHeader.readParagraphs(f)
val paras = TEIHeader.readParagraphs(f)
val para = paras(0)
para.getText
import ie.tcd.slscs.itut.gramadanj.FileUtils
val foo = FileUtils.isDirectory("/home/jim/www.ainm.ie")
val files = FileUtils.getFileListStartsWith("/home/jim/www.ainm.ie", "Bio")
files.toList
import scala.xml.XML
XML.loadFile(files(0))
import ie.tcd.slscs.itut.AinmNerCorpus
import ie.tcd.slscs.itut.AinmNerCorpus.TEIReader
AinmNerCorpus
val fo = EduInst("foo", "TCD", "")
val fo = AinmNerCorpus.EduInst("foo", "TCD", "")
import ie.tcd.slscs.itut.AinmNerCorpus.*
import ie.tcd.slscs.itut.AinmNerCorpus._
val fo = EduInst("foo", "TCD", "")
  def filterNERType(kind: String, l: List[NERText]): List[NERText] = {
    def filterinner(n: NERText, kind: String): NERText = n match {
      case EntityReference(t, k) = {
        if(k == kind) {
          EntityReference(t, k)
        } else {
          TextPart(t)
        }
      }
      case TextPart(t) => TextPart(t)
    }
    l.map{e => filterinner(e, kind)}
  }
import ie.tcd.slscs.itut.AinmNerCorpus._
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{readFile}
val docs = files.map{AinmProcess.readFile}
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{AinmProcess.readFile}
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{AinmProcess.readFile}
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{AinmProcess.readFile}
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{AinmProcess.readFile}
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{AinmProcess.readFile}
import ie.tcd.slscs.itut.AinmNerCorpus.AinmProcess
AinmProcess.getFileList("/home/jim/www.ainm.ie")
val files = AinmProcess.getFileList("/home/jim/www.ainm.ie")
val docs = files.map{AinmProcess.readFile}
val doc1 = docs(0)
AinmProcess.sentdetect.sentPosDetect("Chuir se e. Agus anois.")
val f = AinmProcess.sentdetect.sentPosDetect("Chuir se e. Agus anois.")
def splitParagraph(p: Paragraph): Array[Span] = AinmProcess.sentdetect.sentPosDetect(p.getText)
import  ie.tcd.slscs.itut.AinmNerCorpus.AinmReader
import  ie.tcd.slscs.itut.AinmNerCorpus._
def splitParagraph(p: Paragraph): Array[Span] = AinmProcess.sentdetect.sentPosDetect(p.getText)
import opennlp.tools.util.Span
def splitParagraph(p: Paragraph): Array[Span] = AinmProcess.sentdetect.sentPosDetect(p.getText)
  def splitParagraphs(l: List[Paragraphs]): List[Array[Span]] = l.map{splitParagraph}
  def splitParagraphs(l: List[Paragraph]): List[Array[Span]] = l.map{splitParagraph}
splitParagraphs(doc1)
val split = splitParagraphs(doc1)
val test = "thing to test"
test.replaceAll(" ", "_").toCharArray.sliding(2).toList
test.replaceAll(" ", "_").toCharArray.sliding(2).map{mkString}
test.replaceAll(" ", "_").toCharArray.sliding(2).map{_.mkString}
test.replaceAll(" ", "_").toCharArray.sliding(2).map{_.mkString}.toList
val s = Span(2, 3)
import opennlp.tools.util.Span
val s = Span(2, 3)
val s = new Span(2,3)
import  ie.tcd.slscs.itut.AinmNerCorpus._
import  ie.tcd.slscs.itut.AinmNerCorpus.AinmReader
val foo = "gaois.ie-crp-tmx-irish-legislation-2017-07-12.tmx"
foo.substring(0, foo.length - 4)
  abstract class TrRule(tag: String) {
    def getTag:String = tag
  }
  abstract class Token(tags: List[String]) {
    def getTags = tags
  }
  case class LemmaToken(lemma: String, tags: List[String]) extends Token(tags)
  case class TagsToken(tags: List[String]) extends Token(tags)
  abstract class AlignedToken(tags: List[String], pos: Int) extends Token(tags)
  case class LemmaAlignedToken(lemma: String, tags: List[String], pos: Int) extends AlignedToken(tags, pos)
  case class TagsAlignedToken(tags: List[String], pos: Int) extends AlignedToken(tags, pos)
  case class RulePiece(src: List[Token], trg: List[Token],
                       al: Map[Int, Array[Int]], srcmac: List[Macro],
                       trgmac: List[Macro], srceg: String, trgeg: String)
  case class MultiPartRule(tag: String, parts: List[RulePiece]) extends TrRule(tag)
  case class Rule(tag: String, src: List[Token], trg: List[Token],
                  srcal: Map[Int, Array[Int]], srcmac: List[Macro],
                  trgmac: List[Macro], srceg: String, trgeg: String) extends TrRule(tag)
  implicit def RuleToMultiPart(r: Rule): MultiPartRule = {
    val rp:RulePiece = RulePiece(r.src, r.trg, r.srcal, r.srcmac, r.trgmac, r.srceg, r.trgeg)
    MultiPartRule(r.tag, List[RulePiece](rp))
  }
  def flipMacro(pos: Int, mac: Macro): Macro = {
    Macro(mac.name, mac.params.map{e => if (e <= pos) e else -e})
  }
  case class Macro(name: String, params: List[Int])
  case class RulePiece(src: List[Token], trg: List[Token],
                       al: Map[Int, Array[Int]], srcmac: List[Macro],
                       trgmac: List[Macro], srceg: String, trgeg: String)
  case class MultiPartRule(tag: String, parts: List[RulePiece]) extends TrRule(tag)
  case class Rule(tag: String, src: List[Token], trg: List[Token],
                  srcal: Map[Int, Array[Int]], srcmac: List[Macro],
                  trgmac: List[Macro], srceg: String, trgeg: String) extends TrRule(tag)
  implicit def RuleToMultiPart(r: Rule): MultiPartRule = {
    val rp:RulePiece = RulePiece(r.src, r.trg, r.srcal, r.srcmac, r.trgmac, r.srceg, r.trgeg)
    MultiPartRule(r.tag, List[RulePiece](rp))
  }
  def flipMacro(pos: Int, mac: Macro): Macro = {
    Macro(mac.name, mac.params.map{e => if (e <= pos) e else -e})
  }
  def stringToMacro(s: String): Option[Macro] = {
    val in = s.split(":")
    if(in.length != 2) {
      None
    }
    val params = in(1).split(",").map{_.trim}.map{_.toInt}.toList
    Some(Macro(in(0), params))
  }
  implicit def stringToMacroList(s: String): List[Macro] = s.split(" ").flatMap{stringToMacro}.toList
stringToMacroList("agree:1,2")
flipMacro(2, m)
val m =stringToMacroList("agree:1,2")
flipMacro(2, m)
flipMacro(2, m(0))
flipMacro(1, m(0))
  def cart(l: List[List[String]]): List[List[String]] = l match {
    case Nil => List(Nil)
    case h :: t => for(e <- h; rest <- cart(t)) yield e :: rest
}
cart(List(List("a", "b"), List("1", "2", "3")))
val ll = List("aa", "ab", "ac", "bb", "bc", "cc")
ll.map => (e => e.substring(0, 1) -> e)
ll.map(e => e.substring(0, 1) -> e)
ll.map(e => e.substring(0, 1) -> e).toMap
ll.map(e => e.substring(0, 1) -> e).mkMap
ll.map(e => e.substring(0, 1) -> e).flatmap
ll.map(e => e.substring(0, 1) -> e)
ll.map(e => e.substring(0, 1) -> e).flatten
ll.map(e => e.substring(0, 1) -> e).
ll.foldLeft(e => e.substring(0, 1) -> e)
ll.foldLeft(Map(String, List(String))(e => e.substring(0, 1) -> e)
ll.foldLeft(Map(String, List(String)))(e => e.substring(0, 1) -> e)
ll.foldLeft(Map(String, List[String]))(e => e.substring(0, 1) -> e)
ll.foldLeft(Map(String, List[String]()))(e => e.substring(0, 1) -> e)
ll.foldLeft(Map[String, List[String]()])(e => e.substring(0, 1) -> e)
ll.foldLeft(Map[String, List[String]]())(e => e.substring(0, 1) -> e)
ll.foldLeft(Map[String, List[String]]())(e: String => e.substring(0, 1) -> e)
ll.map => (e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2__
ll.map => (e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2))
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2))
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2)).sort
  def prpersMaker(tags: String): List[String] = {
    def gender(s: String) = if(s.contains("Masc")) "m" else if(s.contains("Fem")) "f" else "mf"
    def number(s: String) = if(s.contains("Sg")) "sg" else if(s.contains("Pl")) "pl" else "sp"
    def person(s: String) = if(s.contains("1P")) "p1" else if(s.contains("2P")) "p2" else "p3"
    def addtags(s: String) = List[String](person(s), gender(s), number(s))
    if(!tags.contains("Pron+Prep")) {
      List.empty[String]
    } else {
      val base = List("prn", "obj")
      base ++ addtags(tags)
    }
  }
prpersMaker("+Pron+Prep+3P+Sg+Masc")
val foo = List[String]("ba", "bla", null)
val foo = List[String]("ba", "bla", None)
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2)).sort
val ll = List("aa", "ab", "ac", "bb", "bc", "cc")
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2)).sort
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2))
ll.map(e => e.substring(0, 1) -> e)
val ll = List("aa", "ab", "ac", "bb", "bc", "cc")
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2))
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).map(case (k, v) => v)
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).map( case (k, v) => v)
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).map{case (k, v) => v}
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2))
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1)..map{case (k, v) => k -> v.map{_._2}}
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).map{case (k, v) => k -> v.map{_._2}}
ll.zipWithIndex
ll.zipWithIndex.map{e => (e._1, e._2 + 1)}
val f = "Magazyn KOT, podarowany w prezencie członkom klubu, cieszył się ogromnym powodzeniem i bez problemów znajdował czytelników o polskich korzeniach, którzy tłumaczyli teksty na hebrajski."
f.length
val tip = "+Foo+CU+Bar"
val tip = if(tags.startsWith("+")) tags.substring(1) else tags
val tags = "+Foo+CU+Bar"
val tip = if(tags.startsWith("+")) tags.substring(1) else tags
val bla = tip.split("\\+")
//val blah = bla.filter{
val l = List("CC", "CM", "CU")
val blah = bla.filter{!l.contains(_)}
val balaha = bla.filter{l.contains(_)}
val tags = "+Foo+CU+Bar+CM"
val tip = if(tags.startsWith("+")) tags.substring(1) else tags
val bla = tip.split("\\+")
val blah = bla.filter{!l.contains(_)}
val balaha = bla.filter{l.contains(_)}.mkString(",")
val tags = "+Foo+CU+Bar"
val tip = if(tags.startsWith("+")) tags.substring(1) else tags
val bla = tip.split("\\+")
val balaha = bla.filter{l.contains(_)}.mkString(",")
  val DIALECTS = List("CC", "CM", "CU")
  def getDialect(tags: String): String = {
    val tagsw = if(tags.startsWith("+")) tags.substring(1) else tags
    tagsw.split("\\+").filter{DIALECTS.contains(_)}.mkString(",")
  }
ll.map(e => e.substring(0, 1) -> e).groupBy(_._1).mapValues(_.map(_._2))
val foo ="+Verb+Pres"
foo.replace("+Verb", "+Vbser")
val mp = Map("ng" -> "g", "bhf" -> "f")
val foo = List("a", "b", "c")
val bar = List("1")
for (a <- bar; b <- foo) yield a :: b
for (a <- bar; b <- foo) yield List(a) :: b
bar.zip(foo)
val a = List("1", "2", "3")
val b = Map("3" -> List(List("a"), List("a", "b"), List("a", "b", "c"))
)
case class TNode(v: String)
case class NTNode(v: List[List[String]])
abstract class Node
case class TNode(v: String) extends Node
case class NTNode(v: List[List[String]]) extends Node
def mkNodes(l: List[String]): List[Node] = {
def mkNode(s: String) = if(b.contains(s)) {
NTNode(b(s))
} else {
TNode(s)
}
l.map{mkNode}
}
mkNodes(a)
def expandNodes(l: List[Node]): List[List[String]] = {
def expandInner(n: Node, acc: List[List[String]]) = n match {
case TNode(s) => 
def expandNodes(l: List[Node]): List[List[String]] = {
def expandInner(n: List[Node], acc: List[List[String]]) = n match {
case Nil => acc
val s = "1"
val t = List("a", "b", "c")
val u = t.map{e => List(s, e)}
val s = List("1", "2")
val u = s.map{ a => t.map{ b => List(a, b)} }
val u = s.map{ a => t.map{ b => List(a, b)} }.flatten
case Node(s) :: xs => expandInner(xs, acc.map{ e => e :+ Node(s) }
case NTNode(v) :: xs => expandInner(xs, acc.map{ e => e.map{ f => List(e, f)}}.flatten)
def expandNodes(l: List[Node]): List[List[String]] = {
def expandInner(n: List[Node], acc: List[List[String]]) = n match {
case Nil => acc
case TNode(s) :: xs => expandInner(xs, acc.map{ e => e :+ Node(s) }
)
case NTNode(v) :: xs => expandInner(xs, acc.map{ e => e.map{ f => List(e, f)}}.flatten)
}
expandInner(l, List.empty[List[String]])
}
def expandNodes(l: List[Node]): List[List[String]] = {
def expandInner(n: List[Node], acc: List[List[String]]): List[List[String]] = n match {
case Nil => acc
case TNode(s) :: xs => expandInner(xs, acc.map{ e => e :+ Node(s) })
case NTNode(v) :: xs => expandInner(xs, acc.map{ e => e.map{ f => List(e, f)}}.flatten)
}
expandInner(l, List.empty[List[String]])
}
  def expandNodes(l: List[Node]): List[List[Node]] = {
    def expandInner(n: List[Node], acc: List[List[Node]]): List[List[Node]] = n match {
      case Nil => acc
      case TNode(s) :: xs => expandInner(xs, acc.map{ e => e :+ TNode(s) })
      case NTNode(v) :: xs => expandInner(xs, acc.map{ e: List[Node]  => v.map{ f: List[Node] => List(e, f)}}.flatten.flatten)
    }
    expandInner(l, List.empty[List[Node]])
  }
  abstract class Node
  case class TNode(v: String) extends Node
  case class NTNode(v: List[List[Node]]) extends Node
  def mkNodes(l: List[String], b: Map[String,List[List[Node]]]): List[Node] = {
    def mkNode(s: String) = if(b.contains(s)) {
      NTNode(b(s))
    } else {
      TNode(s)
    }
    l.map{mkNode}
  }
  def expandNodes(l: List[Node]): List[List[Node]] = {
    def expandInner(n: List[Node], acc: List[List[Node]]): List[List[Node]] = n match {
      case Nil => acc
      case TNode(s) :: xs => expandInner(xs, acc.map{ e => e :+ TNode(s) })
      case NTNode(v) :: xs => expandInner(xs, acc.map{ e: List[Node]  => v.map{ f: List[Node] => List(e, f)}}.flatten.flatten)
    }
    expandInner(l, List.empty[List[Node]])
  }
val b = Map("3" -> List(List("a"), List("a", "b"), List("a", "b", "c"))
)
val c = b.map{e -> (e._1, e.map{_.map{f => TNode(f)}}}
val c = b.map{e -> (e._1, e.map{_.map{f => TNode(f)}})}
val c = b.map{e -> (e._1, e._2.map{_.map{f => TNode(f)}})}
val foo = Map(1 -> 2, 2 -> 3)
foo.map{e => (e._1, e._2 + 1)}
def toNodes(b: Map[String, List[List[String]]]): List[List[Node]] = b.map{e => (e._1, e._2.map{_.map{g => TNode(g)}})}
def toNodes(b: Map[String, List[List[String]]]): Map[String, List[List[Node]]] = b.map{e => (e._1, e._2.map{_.map{g => TNode(g)}})}
c = toNodes(b)
val c = toNodes(b)
mkNodes(a)
val d = mkNodes(a, c)
expandNodes(d)
  def expandNodes(l: List[Node]): List[List[Node]] = {
    def expandInner(n: List[Node], acc: List[List[Node]]): List[List[Node]] = n match {
      case Nil => acc
      case TNode(s) :: xs => expandInner(xs, acc.map{ e => e :+ TNode(s) })
      case NTNode(v) :: xs => expandInner(xs, acc.flatMap{ e: List[Node]  => v.flatMap{ f: List[Node] => List(e, f)}})
    }
    expandInner(l, List.empty[List[Node]])
  }
expandNodes(d)
val u = s.map{ a => t.map{ b => List(a, b)} }.flatten
val u = p.map{ a => t.map{ b => List(a, b)} }.flatten
val p = List.empty[String]
val u = p.map{ a => t.map{ b => List(a, b)} }.flatten
val u = p.flatMap{ a => t.map{ b => List(a, b)} }
  def expandNodes(l: List[Node]): List[List[Node]] = {
    def expandInner(n: List[Node], acc: List[List[Node]]): List[List[Node]] = n match {
      case Nil => acc
      case TNode(s) :: xs => if(acc.isEmpty) {
        expandInner(xs, List(List(TNode(s))))
      } else {
        expandInner(xs, acc.map{ e => e :+ TNode(s) })
      }
      case NTNode(v) :: xs => if(acc.isEmpty) {
        expandInner(xs, v)
      } else {
        expandInner(xs, acc.flatMap { e: List[Node] => v.flatMap { f: List[Node] => List(e, f) } })
      }
    }
    expandInner(l, List.empty[List[Node]])
  }
expandNodes(d)
expandNodes(d).flatten
  def expandNodes(l: List[Node]): List[List[Node]] = {
    def expandInner(n: List[Node], acc: List[List[Node]]): List[List[Node]] = n match {
      case Nil => acc
      case TNode(s) :: xs => if(acc.isEmpty) {
        expandInner(xs, List(List(TNode(s))))
      } else {
        expandInner(xs, acc.map{ e => e :+ TNode(s) })
      }
      case NTNode(v) :: xs => if(acc.isEmpty) {
        expandInner(xs, v)
      } else {
        expandInner(xs, acc.flatMap { e: List[Node] => v.flatMap { f: List[Node] => List(List(e, f).flatten) } })
      }
    }
    expandInner(l, List.empty[List[Node]])
  }
expandNodes(d)
expandNodes(d).flatten
expandNodes(d)
val a = List("1", "2", "3" "4", "3")
val a = List("1", "2", "3", "4", "3")
val mp = Map("ng" -> "g", "bhf" -> "f")
val d = mkNodes(a, c)
expandNodes(d)
  val mutationStarts: Map[Char, List[String]] = Map('b' -> List("mb", "bh"), 'c' -> List("gc", "ch"), 'd' -> List("nd", "dh"),
    'f' -> List("bhf", "fh"), 'g' -> List("ng", "gh"), 'm' -> List("mh"), 'p' -> List("bp", "ph"), 's' -> List("ts", "sh"),
    't' -> List("dt", "th"), 'a' -> List("h-a", "t-a", "n-a"), 'e' -> List("h-e", "t-e", "n-e"),
    'i' -> List("h-i", "t-i", "n-i"), 'o' -> List("h-o", "t-o", "n-o"), 'u' -> List("h-u", "t-u", "n-u"),
    'á' -> List("h-á", "t-á", "n-á"), 'é' -> List("h-é", "t-é", "n-é"),
    'í' -> List("h-í", "t-í", "n-í"), 'ó' -> List("h-ó", "t-ó", "n-ó"), 'ú' -> List("h-ú", "t-ú", "n-ú"),
    'B' -> List("mB", "Bh"), 'C' -> List("gC", "Ch"), 'D' -> List("nD", "Dh"),
    'F' -> List("bhF", "Fh"), 'G' -> List("nG", "Gh"), 'M' -> List("Mh"), 'P' -> List("bP", "Ph"), 'S' -> List("tS", "Sh"),
    'T' -> List("dT", "Th"), 'A' -> List("hA", "tA", "nA"), 'E' -> List("hE", "tE", "nE"),
    'I' -> List("hI", "tI", "nI"), 'O' -> List("hO", "tO", "nO"), 'U' -> List("hU", "tU", "nU"),
    'Á' -> List("hÁ", "tÁ", "nÁ"), 'É' -> List("hÉ", "tÉ", "nÉ"),
    'Í' -> List("hÍ", "tÍ", "nÍ"), 'Ó' -> List("hÓ", "tÓ", "nÓ"), 'Ú' -> List("hÚ", "tÚ", "nÚ"))
def find_beginning(s: String, l: List[String]): Int = {
for(ent <- l) {
if(s.startsWith(ent) {
s.length
}
val foo = List("bh", "mb")
def fbeg(s: String, l: List[String]): Int = {
val f = l.dropWhile(e => !s.startsWith(e))
if(f.length == 0) {
0
} else {
f.head.length
}
fbeg("bad", foo)
fbeg("bhad", foo)
fbeg("mbad", foo)
  val mutationStarts: Map[Char, List[String]] = Map('b' -> List("mb", "bh"), 'c' -> List("gc", "ch"), 'd' -> List("nd", "dh"),
    'f' -> List("bhf", "fh"), 'g' -> List("ng", "gh"), 'm' -> List("mh"), 'p' -> List("bp", "ph"), 's' -> List("ts", "sh"),
    't' -> List("dt", "th"), 'a' -> List("h-a", "t-a", "n-a"), 'e' -> List("h-e", "t-e", "n-e"),
    'i' -> List("h-i", "t-i", "n-i"), 'o' -> List("h-o", "t-o", "n-o"), 'u' -> List("h-u", "t-u", "n-u"),
    'á' -> List("h-á", "t-á", "n-á"), 'é' -> List("h-é", "t-é", "n-é"),
    'í' -> List("h-í", "t-í", "n-í"), 'ó' -> List("h-ó", "t-ó", "n-ó"), 'ú' -> List("h-ú", "t-ú", "n-ú"),
    'B' -> List("mB", "Bh"), 'C' -> List("gC", "Ch"), 'D' -> List("nD", "Dh"),
    'F' -> List("bhF", "Fh"), 'G' -> List("nG", "Gh"), 'M' -> List("Mh"), 'P' -> List("bP", "Ph"), 'S' -> List("tS", "Sh"),
    'T' -> List("dT", "Th"), 'A' -> List("hA", "tA", "nA"), 'E' -> List("hE", "tE", "nE"),
    'I' -> List("hI", "tI", "nI"), 'O' -> List("hO", "tO", "nO"), 'U' -> List("hU", "tU", "nU"),
    'Á' -> List("hÁ", "tÁ", "nÁ"), 'É' -> List("hÉ", "tÉ", "nÉ"),
    'Í' -> List("hÍ", "tÍ", "nÍ"), 'Ó' -> List("hÓ", "tÓ", "nÓ"), 'Ú' -> List("hÚ", "tÚ", "nÚ"))
  def findBeginning(s: String, l: List[String]): Int = {
    val f = l.dropWhile(e => !s.startsWith(e))
    if(f.length == 0) {
      0
    } else {
      f.head.length
    }
  }
  def stemWord(a: String, b: String): String = {
    if(a == "" || b == "") {
      ""
    }
    val first_char = a.charAt(0)
    val j = findBeginning(b, mutationStarts(first_char))
    val i = if(j == 0) 0 else 1
    val comp_a = a.substring(i)
    val comp_b = b.substring(j)
    val inner = (comp_a, comp_b).zipped.takeWhile(Function.tupled(_ == _)).map(_._1).mkString
    if(i != 0) {
      first_char + inner
    } else {
      inner
    }
  }
stemWord("bad", "mbaid")
val strs = List("thing", "is", "shortest")
strs.reduceLeft(_.length < _.length)
strs.reduceLeft((a, b) => a.length < b.length)
strs.reduceLeft((a: String, b:String) => a.length < b.length)
strs.reduceLeft((a, b) => if(a.length < b.length) a else b)
val strs = List("thing", "is", "shortest", "at")
strs.reduceLeft((a, b) => if(a.length < b.length) a else b)
val f = List("at", "as", "art")
val s = f.reduceLeft((a, b) => if(a.length < b.length) a else b)
val g = f.filter(_.length == s.length)
"foo".startsWith("")
"foo".startsWith("a")
val a = (1, 2, 3)
val b = (2, 3, 4)
val c = (3, 4, 5)
val abc = List(a, b, c)
val e = ""
e.split(" ")
import ie.tcd.slscs.itut.RuleConverter
import ie.tcd.slscs.itut.RuleConverter.RuleHolder._
import ie.tcd.slscs.itut.ApertiumTransfer.Text._
import ie.tcd.slscs.itut.ApertiumTransfer.Text.RuleContainer._
RuleContainer.fromString("NP | <n> | <n> | 1-1 | check_human:1 | | dog | madra")
val r1 = RuleContainer.fromString("NP | <n> | <n> | 1-1 | check_human:1 | | dog | madra")
import ie.tcd.slscs.itut.RuleConverter._
val c = CatItem("n.*")
val m = Map("n" -> c)
RuleHolder.convertRuleContainer(r1, m)
val m = Map("n" -> List(c))
RuleHolder.convertRuleContainer(r1, m)
RuleContainer.fromString("NP | <n> | <n> | 1-1 | check_human:1 | foo:1 | dog | madra")
val r1 = RuleContainer.fromString("NP | <n> | <n> | 1-1 | check_human:1 | | dog | madra")
RuleHolder.convertRuleContainer(r1, m)
import ie.tcd.slscs.itut.RuleConverter
import ie.tcd.slscs.itut.ApertiumTransfer.Text._
import ie.tcd.slscs.itut.RuleConverter._
import ie.tcd.slscs.itut.ApertiumTransfer.Text.RuleContainer._
import ie.tcd.slscs.itut.RuleConverter.RuleHolder._
val r1 = RuleContainer.fromString("NP | <n> | <n> | 1-1 | check_human:1 | | dog | madra")
val c = CatItem("n.*")
val m = Map("n" -> List(c))
RuleHolder.convertRuleContainer(r1, m)
RuleHolder.catItemToJCatItem(c)
val cc = RuleHolder.catItemToJCatItem(c)
cc.getTags
cc.getLemma
cc.getName
c.tags
val cc = RuleHolder.catItemToJCatItem(CatItem("foo", "n.sg")
)
cc.getTags
cc.getTagsList
val cd: ie.tcd.slscs.itut.ApertiumTransfer.CatItem = new ie.tcd.slscs.itut.ApertiumTransfer.CatItem("n", "n.sg")
cd.getTags
cd.getTagsList
cat cati = CatItem("foo", "n,sg")
val cati = CatItem("foo", "n,sg")
cat cati = CatItem("foo", "n.sg")
val cati = CatItem("foo", "n.sg")
val cati = CatItem("n.sg", "foo")
val cc = RuleHolder.catItemToJCatItem(cati)
cc.getTags
cc.getLemma
cc.getName
import ie.tcd.slscs.itut.ApertiumTransfer.Text._
import ie.tcd.slscs.itut.RuleConverter._
import ie.tcd.slscs.itut.ApertiumTransfer.Text.RuleContainer._
import ie.tcd.slscs.itut.RuleConverter.RuleHolder._
val r1 = RuleContainer.fromString("NP | <n> | <n> | 1-1 | check_human:1 | | dog | madra")
val c = CatItem("n.*")
val m = Map("n" -> List(c))
RuleHolder.convertRuleContainer(r1, m)
RuleHolder.catItemToJCatItem(c)
val cc = RuleHolder.catItemToJCatItem(c)
cc.getTags
RuleHolder.convertRuleContainer(r1, m)
val r2 = RuleContainer.fromString(" | foo<n> | <n> | 1-1 | check_human:1 | | dog | madra")
RuleHolder.convertRuleContainer(r2, m)
val rls = s"""
NP | <n> | <n> | 1-1 | check_human:1;check_def:1;check_profession:1 | | dog | madra
| <n><list:definites> | an<det><def> <n> | 0-1 1-2 | check_human:1;check_def:1;check_profession:1 | | Monday | an Luan
"""
rls.split("\n")
rls.split("\n").filter(!_.equals(""))
rls.split("\n").filter(!_.equals("") && !_.startsWith("#"))
rls.split("\n").filter((!_.equals("") && !_.startsWith("#")))
rls.split("\n").filter(e => !e.equals("") && !e.startsWith("#"))
rls.split("\n").filter(e => !e.equals("") && !e.startsWith("#")).map{e => RuleHolder.convertRuleContainer(e, m)}
rls.split("\n").filter(e => !e.equals("") && !e.startsWith("#")).map{e => RuleHolder.convertRuleContainer(RuleContainer.fromString(e), m)}
val l = List(    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 6.0, 7.0,
    8.0, 9.0, 10.0, 11.0, 13.0, 14.0, 16.0, 18.0, 20.0, 22.0, 25.0, 28.0, 32.0,
    35.0, 40.0, 45.0, 51.0, 57.0, 64.0, 71.0, 80.0, 90.0, 101.0, 114.0, 128.0,
    142.0, 159.0, 179.0, 202.0, 227.0, 256.0, 284.0, 318.0, 359.0, 405.0,
    455.0, 512.0, 568.0, 638.0, 719.0, 811.0, 911.0, 1024.0, 1137.0, 1276.0,
    1438.0, 1622.0, 1823.0, 2048.0, 2273.0, 2552.0, 2875.0, 3244.0, 3645.0, 
    4096.0, 4547.0, 5104.0, 5751.0, 6488.0, 7291.0, 8192.0, 9093.0, 10207.0, 
    11502.0, 12976.0, 14582.0, 16384.0, 18350.0, 20644.0, 23429.0,
    26214.0, 29491.0, 32767)
val ll = List(        0.,     0.,     0.,     0.,     0.,
0.,     0.,     0.,     0.,     0.,
0.,     0.,     0.,     6.,     7.,
8.,     9.,    10.,    11.,    13.,
14.,    16.,    18.,    20.,    22.,
25.,    28.,    32.,    35.,    40.,
45.,    51.,    57.,    64.,    71.,
80.,    90.,   101.,   114.,   128.,
142.,   159.,   179.,   202.,   227.,
256.,   284.,   318.,   359.,   405.,
455.,   512.,   568.,   638.,   719.,
811.,   911.,  1024.,  1137.,  1276.,
1438.,  1622.,  1823.,  2048.,  2273.,
2552.,  2875.,  3244.,  3645.,  4096.,
4547.,  5104.,  5751.,  6488.,  7291.,
8192.,  9093., 10207., 11502., 12976.,
14582., 16384., 18350., 20644., 23429.,
26214., 29491., 32767.
val ll = List(        0.0,     0.0,     0.0,     0.0,     0.0,
        0.0,     0.0,     0.0,     0.0,     0.0,
        0.0,     0.0,     0.0,     6.0,     7.0,
        8.0,     9.0,    10.0,    11.0,    13.0,
        14.0,    16.0,    18.0,    20.0,    22.0,
        25.0,    28.0,    32.0,    35.0,    40.0,
        45.0,    51.0,    57.0,    64.0,    71.0,
        80.0,    90.0,   101.0,   114.0,   128.0,
        142.0,   159.0,   179.0,   202.0,   227.0,
        256.0,   284.0,   318.0,   359.0,   405.0,
        455.0,   512.0,   568.0,   638.0,   719.0,
        811.0,   911.0,  1024.0,  1137.0,  1276.0,
        1438.0,  1622.0,  1823.0,  2048.0,  2273.0,
        2552.0,  2875.0,  3244.0,  3645.0,  4096.0,
        4547.0,  5104.0,  5751.0,  6488.0,  7291.0,
        8192.0,  9093.0, 10207.0, 11502.0, 12976.0,
        14582.0, 16384.0, 18350.0, 20644.0, 23429.0,
        26214.0, 29491.0, 32767.0)
l == ll
import com.ibm.icu.text.RuleBasedNumberFormat._
val ukEnglish =
        "%simplified:\n"
        + "    -x: minus >>;\n"
        + "    x.x: << point >>;\n"
        + "    zero; one; two; three; four; five; six; seven; eight; nine;\n"
        + "    ten; eleven; twelve; thirteen; fourteen; fifteen; sixteen;\n"
        + "        seventeen; eighteen; nineteen;\n"
        + "    20: twenty[->>];\n"
        + "    30: thirty[->>];\n"
        + "    40: forty[->>];\n"
        + "    50: fifty[->>];\n"
        + "    60: sixty[->>];\n"
        + "    70: seventy[->>];\n"
        + "    80: eighty[->>];\n"
        + "    90: ninety[->>];\n"
        + "    100: << hundred[ >>];\n"
        + "    1000: << thousand[ >>];\n"
        + "    1,000,000: << million[ >>];\n"
        + "    1,000,000,000,000: << billion[ >>];\n"
        + "    1,000,000,000,000,000: =#,##0=;\n"
        + "%alt-teens:\n"
        + "    =%simplified=;\n"
        + "    1000>: <%%alt-hundreds<[ >>];\n"
        + "    10,000: =%simplified=;\n"
        + "    1,000,000: << million[ >%simplified>];\n"
        + "    1,000,000,000,000: << billion[ >%simplified>];\n"
        + "    1,000,000,000,000,000: =#,##0=;\n"
        + "%%alt-hundreds:\n"
        + "    0: SHOULD NEVER GET HERE!;\n"
        + "    10: <%simplified< thousand;\n"
        + "    11: =%simplified= hundred>%%empty>;\n"
        + "%%empty:\n"
        + "    0:;"
        + "%ordinal:\n"
        + "    zeroth; first; second; third; fourth; fifth; sixth; seventh;\n"
        + "        eighth; ninth;\n"
        + "    tenth; eleventh; twelfth; thirteenth; fourteenth;\n"
        + "        fifteenth; sixteenth; seventeenth; eighteenth;\n"
        + "        nineteenth;\n"
        + "    twentieth; twenty->>;\n"
        + "    30: thirtieth; thirty->>;\n"
        + "    40: fortieth; forty->>;\n"
        + "    50: fiftieth; fifty->>;\n"
        + "    60: sixtieth; sixty->>;\n"
        + "    70: seventieth; seventy->>;\n"
        + "    80: eightieth; eighty->>;\n"
        + "    90: ninetieth; ninety->>;\n"
        + "    100: <%simplified< hundredth; <%simplified< hundred >>;\n"
        + "    1000: <%simplified< thousandth; <%simplified< thousand >>;\n"
        + "    1,000,000: <%simplified< millionth; <%simplified< million >>;\n"
        + "    1,000,000,000,000: <%simplified< billionth;\n"
        + "        <%simplified< billion >>;\n"
        + "    1,000,000,000,000,000: =#,##0=;"
        + "%default:\n"
        + "    -x: minus >>;\n"
        + "    x.x: << point >>;\n"
        + "    =%simplified=;\n"
        + "    100: << hundred[ >%%and>];\n"
        + "    1000: << thousand[ >%%and>];\n"
        + "    100,000>>: << thousand[>%%commas>];\n"
        + "    1,000,000: << million[>%%commas>];\n"
        + "    1,000,000,000,000: << billion[>%%commas>];\n"
        + "    1,000,000,000,000,000: =#,##0=;\n"
        + "%%and:\n"
        + "    and =%default=;\n"
        + "    100: =%default=;\n"
        + "%%commas:\n"
        + "    ' and =%default=;\n"
        + "    100: , =%default=;\n"
        + "    1000: , <%default< thousand, >%default>;\n"
        + "    1,000,000: , =%default=;"
        + "%%lenient-parse:\n"
        + "    & ' ' , ',' ;\n";
val ukEnglish = s"""
    %simplified:
    -x: minus >>;
    x.x: << point >>;
    zero; one; two; three; four; five; six; seven; eight; nine;
    ten; eleven; twelve; thirteen; fourteen; fifteen; sixteen;
        seventeen; eighteen; nineteen;
    20: twenty[->>];
    30: thirty[->>];
    40: forty[->>];
    50: fifty[->>];
    60: sixty[->>];
    70: seventy[->>];
    80: eighty[->>];
    90: ninety[->>];
    100: << hundred[ >>];
    1000: << thousand[ >>];
    1,000,000: << million[ >>];
    1,000,000,000,000: << billion[ >>];
    1,000,000,000,000,000: =#,##0=;
%alt-teens:
    =%simplified=;
    1000>: <%%alt-hundreds<[ >>];
    10,000: =%simplified=;
    1,000,000: << million[ >%simplified>];
    1,000,000,000,000: << billion[ >%simplified>];
    1,000,000,000,000,000: =#,##0=;
%%alt-hundreds:
    0: SHOULD NEVER GET HERE!;
    10: <%simplified< thousand;
    11: =%simplified= hundred>%%empty>;
%%empty:
    0:;"
%ordinal:
    zeroth; first; second; third; fourth; fifth; sixth; seventh;
        eighth; ninth;
    tenth; eleventh; twelfth; thirteenth; fourteenth;
        fifteenth; sixteenth; seventeenth; eighteenth;
        nineteenth;
    twentieth; twenty->>;
    30: thirtieth; thirty->>;
    40: fortieth; forty->>;
    50: fiftieth; fifty->>;
    60: sixtieth; sixty->>;
    70: seventieth; seventy->>;
    80: eightieth; eighty->>;
    90: ninetieth; ninety->>;
    100: <%simplified< hundredth; <%simplified< hundred >>;
    1000: <%simplified< thousandth; <%simplified< thousand >>;
    1,000,000: <%simplified< millionth; <%simplified< million >>;
    1,000,000,000,000: <%simplified< billionth;
        <%simplified< billion >>;
    1,000,000,000,000,000: =#,##0=;"
%default:
    -x: minus >>;
    x.x: << point >>;
    =%simplified=;
    100: << hundred[ >%%and>];
    1000: << thousand[ >%%and>];
    100,000>>: << thousand[>%%commas>];
    1,000,000: << million[>%%commas>];
    1,000,000,000,000: << billion[>%%commas>];
    1,000,000,000,000,000: =#,##0=;
%%and:
    and =%default=;
    100: =%default=;
%%commas:
    ' and =%default=;
    100: , =%default=;
    1000: , <%default< thousand, >%default>;
    1,000,000: , =%default=;"
%%lenient-parse:
    & ' ' , ',' ;;
"""
val sp = new RuleBasedNumberFormat(ukEnglish, Locale.US)
import com.ibm.icu.text._
val sp = new RuleBasedNumberFormat(ukEnglish, Locale.US)
import java.util.Locale
val sp = new RuleBasedNumberFormat(ukEnglish, Locale.US)
val simp = s"""
    %simplified:
    -x: minus >>;
    x.x: << point >>;
    zero; one; two; three; four; five; six; seven; eight; nine;
    ten; eleven; twelve; thirteen; fourteen; fifteen; sixteen;
        seventeen; eighteen; nineteen;
    20: twenty[->>];
    30: thirty[->>];
    40: forty[->>];
    50: fifty[->>];
    60: sixty[->>];
    70: seventy[->>];
    80: eighty[->>];
    90: ninety[->>];
    100: << hundred[ >>];
    1000: << thousand[ >>];
    1,000,000: << million[ >>];
    1,000,000,000,000: << billion[ >>];
    1,000,000,000,000,000: =#,##0=;
%alt-teens:
    =%simplified=;
    1000>: <%%alt-hundreds<[ >>];
    10,000: =%simplified=;
    1,000,000: << million[ >%simplified>];
    1,000,000,000,000: << billion[ >%simplified>];
    1,000,000,000,000,000: =#,##0=;
"""
val sp = new RuleBasedNumberFormat(simp, Locale.US)
val simp = s"""
    %simplified:
    -x: minus >>;
    x.x: << point >>;
    zero; one; two; three; four; five; six; seven; eight; nine;
    ten; eleven; twelve; thirteen; fourteen; fifteen; sixteen;
        seventeen; eighteen; nineteen;
    20: twenty[->>];
    30: thirty[->>];
    40: forty[->>];
    50: fifty[->>];
    60: sixty[->>];
    70: seventy[->>];
    80: eighty[->>];
    90: ninety[->>];
    100: << hundred[ >>];
    1000: << thousand[ >>];
    1,000,000: << million[ >>];
    1,000,000,000,000: << billion[ >>];
    1,000,000,000,000,000: =#,##0=;
%alt-teens:
    =%simplified=;
    1000>: <%%alt-hundreds<[ >>];
    10,000: =%simplified=;
    1,000,000: << million[ >%simplified>];
    1,000,000,000,000: << billion[ >%simplified>];
    1,000,000,000,000,000: =#,##0=;
%%alt-hundreds:
    0: SHOULD NEVER GET HERE!;
    10: <%simplified< thousand;
    11: =%simplified= hundred>%%empty>;
"""
val sp = new RuleBasedNumberFormat(simp, Locale.US)
val nl = s"""
 -x: min >>;
x.x: << komma >>;
(zero?); een; twee; drie; vier; vijf; zes; zeven; acht; negen;
tien; elf; twaalf; dertien; veertien; vijftien; zestien;
zeventien; achtien; negentien;
20: [>> en ]twintig;
30: [>> en ]dertig;
40: [>> en ]veertig;
50: [>> en ]vijftig;
60: [>> en ]zestig;
70: [>> en ]zeventig;
80: [>> en ]tachtig;
90: [>> en ]negentig;
100: << honderd[ >>];
1000: << duizend[ >>];
1,000,000: << miljoen[ >>];
1,000,000,000: << biljoen[ >>];
1,000,000,000,000: =#,##0=
"""
val sp = new RuleBasedNumberFormat(nl, Locale.NL)
val sp = new RuleBasedNumberFormat(nl)
val sb = new StringBuffer()
sp.format(1223, sb)
sp.format(1223, nl)
sp.format(23, nl)
sp.format(23)
sp.format(123)
sp.parse("drie en twintig")
sp.parse("een honderd drie en twintig")
