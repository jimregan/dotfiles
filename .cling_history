#include <stdio.h>
printf("%02d", 2);
.q
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//RUN: cat %s | %cling -Xclang -verify "-DCLING=\" %cling \"" | FileCheck %s
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//RUN: %rm /tmp/__cling_fwd_*
// CLING - the C++ LLVM-based InterpreterG :)
// CLING - the C++ LLVM-based InterpreterG :)
// CLING - the C++ LLVM-based InterpreterG :)
// CLING - the C++ LLVM-based InterpreterG :)
// CLING - the C++ LLVM-based InterpreterG :)
// CLING - the C++ LLVM-based InterpreterG :)
//
//
//
//
//
//XFAIL:*
//
#include "cling/Interpreter/Interpreter.h"
// This file is dual-licensed: you can choose to license it under the University
// This file is dual-licensed: you can choose to license it under the University
// This file is dual-licensed: you can choose to license it under the University
// This file is dual-licensed: you can choose to license it under the University
// This file is dual-licensed: you can choose to license it under the University
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// of Illinois Open Source License or the GNU Lesser General Public License. See
// of Illinois Open Source License or the GNU Lesser General Public License. See
// of Illinois Open Source License or the GNU Lesser General Public License. See
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
// LICENSE.TXT for details.
// LICENSE.TXT for details.
// LICENSE.TXT for details.
// LICENSE.TXT for details.
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -I%S -Xclang -verify
// RUN: cat %s | %cling -I %S -Xclang -verify
// RUN: cat %s | %cling -I %S -Xclang -verify
// RUN: cat %s | %cling -I %S -Xclang -verify
// RUN:cat %s |  %cling -I %S -Xclang -verify 2>&1 | FileCheck -allow-empty %s
//------------------------------------------------------------------------------
//
// XFAIL: *
// Test stlFwd
// Test testInline
// Test incompleteType
// RUN: cat %s | %cling -I %S -Xclang -verify
//   XFAIL: *
// REQUIRES: vanilla-cling
// ROOT-8283
.rawInput 1
// Test forwardDeclaration
//All the currently failing stuff
//   until enum autoloading is fixed.
class __attribute__((annotate("Def.h"))) C; //expected-note + {{}}
inline int localInline() { return 5; }
.rawInput 1
//
.T Fail.h fwd_fail.h
int id(int) __attribute__((annotate("Def.h")));
//XFAIL: *
// Test FwdPrinterTest
.T Stlinc.h stl_test.h
.rawInput 0
// Test similar to ROOT-7037
localInline();
C c; //expected-error {{variable has incomplete type 'C'}} expected-warning@1 0+ {{Note: 'C' can be found in Def.h}}
class __attribute__((annotate("Def.h"))) C;
// Equivalent to parsing the dictionary preamble
.T Def2b.h fwd_Def2b.h
namespace N {
  void nested() __attribute__((annotate("Def.h")));
}
.q
template <typename T> class __attribute__((annotate("Def.h"))) Gen;
template <> class __attribute__((annotate("Def.h"))) Gen<int> ;
template <> class __attribute__((annotate("Spc.h"))) Gen<float>;
template <typename T,typename U> class  __attribute__((annotate("Def.h"))) Partial;
template <typename T> class __attribute__((annotate("Spc.h"))) Partial<T,int>;
#include "Def.h"
localInline();
.undo
.undo
localInline();
extern "C" int printf(const char*, ...);
#include "Inline.h"
#include "Spc.h"
//expected-no-diagnostics
.q
testInline(101)
// CHECK: 101
.undo
testInline(201)
// CHECK-NEXT: 201
testInline(202)
// CHECK-NEXT: 202
testInline(203)
// CHECK-NEXT: 203
.undo  // testInline()
.undo  // testInline()
.undo  // testInline()
testInline(301)
// CHECK-NEXT: 301
.undo  // testInline()
testInline(testInlineRet(301))
// CHECK-NEXT: 602
.undo  // testInline()
testInline(testInlineRet(401))
// CHECK-NEXT: 802
.undo  // testInline()
.undo  // #include "Inline.h"
testInline(501) // expected-error {{use of undeclared identifier 'testInline'}}
#include "Inline.h"
testInline(testInlineRet(606))
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify 2>&1 | FileCheck %s
#include <stdio.h>
// CHECK-NEXT: 1212
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify | FileCheck %s
// XFAIL:*
// Test whether the interpreter is able to generate properly the symbols
// and the vtables of classes.
#include "cling/Interpreter/Interpreter.h"
#include "fwd_Def2b.h"
// Then doing the autoparsing
#include "Def2b.h"
A<int> ai2;
#include "fwd_fail.h"
#include "Fail.h"
// And then do both a second time with a different template instantiation.
.T Def2c.h fwd_Def2c.h
#include "FakeFwd.h" //Because we skip function templates having default function arguments
#include "FunctionTemplate.h"
//expected-no-diagnostics
.q
#include "fwd_Def2c.h"
#include "Def2c.h"
// In some implementations the AutoloadingVisitor was stripping the default
// template parameter value from the class template definition leading to
// compilation error at this next line:
A<float> af2;
// We want to make sure that forward template carying default are not
// affected and that forward declaration are properly cleaned-up (if needed).
template <typename T = int> class DefaultInFwd;
template <typename T> class WithDefaultAndFwd;
.T Def2.h fwd_Def2.h
#include "fwd_Def2.h"
// In some implementation the AutoloadingVisitor, when called upon by the next
// #includes, was not properly removing default value that was attached to
// this following class template forward declaration (the default comes from
// the forward declaration in fwd_Def2.h). See ROOT-8443.
template <typename T> class TemplateWithUserForward;
// The includsion of nesting/h2.h is not (yet) supported as it is included
// in the forward declaration generation step via a #include with a path
// relative to its includer (h1.h) and this we can not properly record
// that this is the same thing as this one (or at least it is harder than
// what we do for now).
// #include "nesting/h2.h"
#include "nesting/h1.h"
#include "Def2sub.h"
#include "Def2.h"
DefaultInFwd<> dif;
WithDefaultAndFwd<> wdaf;
TemplateWithUserForward<> twuf;
TemplateWithAllDefault<> twad;
WithDefaultInH1<> wdh1;
WithDefaultInH2<> wdh2;
// In some implementation the AutoloadingVisitor was not when Def2sub.h, which
// contains the definition for CtorWithDefault, and then the implementation
// was also looping over all element of the decl chain without skipping definition,
// resulting in a loss of the default parameter values for the method/functions of
// CtorWithDefault when AutoloadingVisitor was called upon because of the inclusion
// Def2.h
CtorWithDefault c;
M::N::A mna;
M::N::D mnd;
struct TERD {
    const char *Name;
    TERD(const char *N) : Name(N) { printf("TERD::TERD::%s\n", Name); }
    ~TERD() { printf("TERD::~TERD::%s\n", Name); }
};
static TERD& inst01() {
    static TERD st01("inst01");
    return st01;
}
static TERD& inst02() {
    static TERD st02("inst02");
    return st02;
}
inst01();
.T Enum.h fwd_enums.h
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify 2>&1 | FileCheck %s
// FIXME: cat %s | %cling -fsyntax-only -Xclang -verify 2>&1
// Test to check functions registered via atexit are intercepted, and __dso_handle
// is properly overridden in for child interpreters.
#include <cstdlib>
inst01();
inst01();
//      CHECK: TERD::TERD::inst01
inst02();
inst02();
inst02();
// CHECK-NEXT: TERD::TERD::inst02
// expected-no-diagnostics
.q
#include "fwd_enums.h"
#include "Enum.h"
//expected-no-diagnostics
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -I%S -Xclang -verify  | FileCheck %s
// Test externC_GlobalDecl
extern "C" int printf(const char*,...);
printf("Starting C++ globals check\n");
// CHECK: Starting C++ globals check
#define BEGIN_DECL_
#define _END_DECL
#include "CGlobalDecl.h"
.undo
#include "CGlobalDecl.h"
.undo
printf("C++ globals included and undone\n");
// CHECK: C++ globals included and undone
printf("Starting C globals check\n");
// CHECK: Starting C globals check
#undef BEGIN_DECL_
#undef _END_DECL
#define BEGIN_DECL_  extern "C" {
#define _END_DECL    }
#include "CGlobalDecl.h"
.undo
#include "CGlobalDecl.h"
printf("C globals included and undone\n");
// CHECK: C globals included and undone
// expected-no-diagnostics
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling 2>&1 | FileCheck %s
.storeState "preUnload"
.rawInput 1
int g(); int f(int i) { if (i != 1) return g(); return 0; } int g() { return f(1); } int x = f(0);
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling 2>&1 | FileCheck %s
extern "C" int printf(const char* fmt, ...);
.storeState "preUnload"
class MyClass{
private:
  double member;
public:
  MyClass() : member(42){}
  static int get12(){ return 12; }
  double getMember(){ return member; }
}; MyClass m; m.getMember(); MyClass::get12();
.rawInput 0
.undo
.compareState "preUnload"
.undo
.compareState "preUnload"
//CHECK-NOT: Differences
float MyClass = 1.1
//CHECK-NOT: Differences
float f = 1.1
#include "cling/Interpreter/Interpreter.h"
//CHECK: (float) 1.1
.q
//CHECK: (float) 1.1
int g = 42
//CHECK: (int) 42
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling 2>&1 | FileCheck %s
// XFAIL:*
extern "C" int printf(const char* fmt, ...);
// force emission of cxa_atexit such that it doesn't pollute the diff.
class MyClass{public: ~MyClass(){} }mm;
.storeState "preUnload"
class ClassWithDtor{
private:
  int N;
public:
  ClassWithDtor() : N(0){ N++; }
  ~ClassWithDtor() {
    N--;
    printf("Dtor called, N=%d\n", N);
  }
}; ClassWithDtor m;
.undo
//CHECK: Dtor called, N=0
.compareState "preUnload"
//CHECK-NOT: Differences
// Make sure that the static template member inits get unloaded correctly.
// See CodeGenModule::EmitCXXGlobalVarDeclInitFunc() - they get emitted *next*
// to GLOBAL__I_a, not as call nodes within GLOBAL__I_a.
.storeState "preUnload3"
struct XYZ {
   XYZ(int I = -10): m(I) {}
   int m;
};
template <typename T> struct S {
   static XYZ one;
   static XYZ two;
};
template <typename T> XYZ S<T>::one = XYZ(12);
template <typename T> XYZ S<T>::two = XYZ(17);
XYZ a = XYZ(12);
XYZ b = XYZ(12);
int T(){
   S<int> o;
   return o.one.m;
}
.undo 7
.compareState "preUnload3"
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -I%S -Xclang -verify  | FileCheck %s
// Test externCUndo
.storeState "A"
extern "C" int printf(const char*,...);
.storeState "B"
// Make sure we have exactly one symbol of ~X(), i.e. that the unloading does
// not remove it and CodeGen re-emits in upon seeing a new use in X c;
12  // This is a temporary fix, not to allow .undo to try to unload RuntimePrintvalue.h
extern "C" int printf(const char*,...);
extern "C" int printf(const char*,...);
extern "C" int printf(const char*,...);
extern "C" int printf(const char*,...);
extern "C" {
  int printf(const char*,...);
  int abs(int);
  double atof(const char *);
  void free(void* ptr);
}
.undo // extern "C" {}
.undo // printf
.undo // printf
.undo // printf
.undo // printf
.compareState "B"
printf("Unloaded alot\n");
// CHECK: Unloaded alot
.undo // printf()
.undo // printf
.compareState "A"
printf("FAIL\n"); // expected-error@2 {{use of undeclared identifier 'printf'}}
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -I%S -Xclang -verify 2>&1 | FileCheck %s
// Tests undoing of macro definitions
// Invoke the printer to get it in the undo queue early
"TEST"
    // If this is not here, the test hangs on first .undo 3 below. Should be investigated further.
.storeState "preUnload2"
// CHECK: (const char [5]) "TEST"
// Make sure one Transactin can handle redefinitions
#include "Macros.h"
// expected-warning@Macros.h:3 {{'TEST' macro redefined}}
// expected-note@Macros.h:2 {{previous definition is here}}
// expected-warning@Macros.h:4 {{'TEST' macro redefined}}
// expected-note@Macros.h:3 {{previous definition is here}}
// expected-warning@Macros.h:5 {{'TEST' macro redefined}}
// expected-note@Macros.h:4 {{previous definition is here}}
// expected-warning@Macros.h:6 {{'TEST' macro redefined}}
// expected-note@Macros.h:5 {{previous definition is here}}
TEST
// CHECK: (const char [7]) "TEST 4"
.undo //print
.undo //include
.undo // FIXME: REMOVE once print unloading is merged
TEST // expected-error@2 {{use of undeclared identifier 'TEST'}}
#define TEST "DEFINED"
#undef TEST
.undo
TEST
// CHECK: (const char [8]) "DEFINED"
.undo // print
.undo // define
.undo // FIXME: REMOVE once print unloading is merged
TEST // expected-error@2 {{use of undeclared identifier 'TEST'}}
// Make sure one Transactin can handle undef, redef
#define TESTB
#include "Macros.h"
// expected-warning@Macros.h:19 {{'TEST' macro redefined}}
// expected-note@Macros.h:18 {{previous definition is here}}
TEST // CHECK: (const char [7]) "TEST G"
extern "C" int printf(const char*, ...);
struct X {
   X(): i(12) {}
   ~X() { static int I = 0; printf("~X: %d\n", ++I); }
   int i;
};
X a;
.q
int S() {
   X b;
   return a.i + b.i;
}
S() // CHECK: (int) 24
.undo 3 // Remove up to "X a;"
// CHECK-NEXT: ~X: 1
// CHECK-NEXT: ~X: 2
X c;
.undo 3
// RUN: %rm "Inlines.h.pch"
// RUN: %cling -x c++-header %S/Inputs/Inlines.h -o Inlines.h.pch
// RUN: cat %s | %cling -I%p -Xclang -trigraphs -Xclang -include-pch -Xclang Inlines.h.pch  2>&1 | FileCheck %s
//XFAIL:*
#include "Inputs/Inlines.h"
extern "C" int printf(const char*, ...);
CompGen a;
CompGen b = a;
//.storeState "a"
printf("%d %d\n", a.InlineFunc(), b.InlineFunc());
.undo 1
printf("%d %d\n", a.InlineFunc(), b.InlineFunc());
 //.compareState "a"
 // CHECK: I was executed
 // CHECK: I was executed
.q
// RUN: %mkdir "%T/Rel/Path" || true
// RUN: %rm "CompGen.h.pch" && %rm "%T/Rel/Path/Relative.pch"
// RUN: clang -x c++-header -fexceptions -fcxx-exceptions -std=c++14 -pthread %S/Inputs/CompGen.h -o CompGen.h.pch
// RUN: clang -x c++-header -fexceptions -fcxx-exceptions -std=c++14 -pthread %S/Inputs/CompGen.h -o %T/Rel/Path/Relative.pch
// RUN: cat %s | %cling -I%p -Xclang -include-pch -Xclang CompGen.h.pch  2>&1 | FileCheck %s
// RUN: cat %s | %cling -I%p -I%T/Rel/Path -include-pch Relative.pch 2>&1 | FileCheck %s
//.storeState "a"
.x TriggerCompGen.h
.x TriggerCompGen.h
 // CHECK: I was executed
 // CHECK: I was executed
 //.compareState "a"
// RUN: %mkdir "%T/Rel/Path" || true
// RUN: %rm "CompGen.h.pch" && %rm "%T/Rel/Path/Relative.pch"
// RUN: clang -x c++-header -fexceptions -fcxx-exceptions -std=c++14 -pthread %S/Inputs/CompGen.h -o CompGen.h.pch
// RUN: clang -x c++-header -fexceptions -fcxx-exceptions -std=c++14 -pthread %S/Inputs/CompGen.h -o %T/Rel/Path/Relative.pch
// RUN: cat %s | %cling -I%p -Xclang -include-pch -Xclang CompGen.h.pch  2>&1 | FileCheck %s
// RUN: cat %s | %cling -I%p -I%T/Rel/Path -include-pch Relative.pch 2>&1 | FileCheck %s
//.storeState "a"
.x TriggerCompGen.h
.x TriggerCompGen.h
 // CHECK: I was executed
 // CHECK: I was executed
 //.compareState "a"
// RUN: %rm "CompGen2.h.pch"
// RUN: %cling -x c++-header %S/Inputs/CompGen.h -o CompGen2.h.pch
// RUN: cat %s | %cling -I%p -Xclang -include-pch -Xclang CompGen2.h.pch  2>&1 | FileCheck %s
//.storeState "a"
.x TriggerCompGen.h
.x TriggerCompGen.h
 // CHECK: I was executed
 // CHECK: I was executed
 //.compareState "a"
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -I%p
.storeState "a"
#include "ProtectedClass.h"
.undo
.compareState "a"
// CHECK-NOT: Differences
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -I%p 2>&1 | FileCheck %s
// Test that we re-read file, e.g. that we uncache symbols and file content.
extern "C" int printf(const char*,...);
// work around ROOT-8240
42 // CHECK: (int) 42
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling 2>&1 | FileCheck %s
// Test the ability of unloading the last transaction. Here as a matter of fact
// we unload the wrapper as well and TODO: decrement the unique wrapper counter.
extern "C" int printf(const char* fmt, ...);
printf("Force printf codegeneration. Otherwise CG will defer it and .storeState will be unhappy.\n");
//CHECK: Force printf codegeneration. Otherwise CG will defer it and .storeState will be unhappy.
.storeState "preUnload"
int f = 0;
.undo
int f() {
  printf("Now f is a function\n");
  return 0;
} int a = f(); //CHECK: Now f is a function
.undo
.compareState "preUnload"
//CHECK-NOT: Differences
double f = 3.14
// ROOT-7858: forget symbols
.L macro1.h
macro() // CHECK: version 1
//CHECK: (int) 1
.U macro1.h
.L macro2.h
macro() // CHECK: 2.version 2
//CHECK: (int) 2
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -I %S -Xclang -verify
// Test transactionPoolReuse
.undo
//expected-no-diagnostics
.q
//CHECK: (double) 3.14
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling 2>&1 | FileCheck %s
// Test that input is not discarded if the last line has no newline.
extern "C" int printf(const char*, ...);
printf("DONE!\n"); // CHECK: DONE!
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -std=gnu99 -x c -Xclang -verify 2>&1 | FileCheck %s
// RUN: cat %s | %cling -D__STRICT_ANSI__ -std=gnu++11 -Xclang -verify 2>&1 | FileCheck %s
// RUN: cat %s | %cling -D__STRICT_ANSI__ -std=gnu++14 -Xclang -verify 2>&1 | FileCheck %s
// RUN: cat %s | %cling -D__STRICT_ANSI__ -std=gnu++1z -Xclang -verify 2>&1 | FileCheck %s
// REQUIRES: not_system-windows
#ifdef __cplusplus
extern "C" int printf(const char*, ...);
#else
int printf(const char*, ...);
#endif
typeof (int) Val = 22;
typeof (const char*) This = "THIS";
printf("TEST: %d '%s'\n", Val, This);
// CHECK: TEST: 22 'THIS'
// expected-no-diagnostics
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -std=gnu99 -x c -Xclang -verify 2>&1 | FileCheck %s
// RUN: cat %s | %cling -D__STRICT_ANSI__ -std=gnu++11 -Xclang -verify 2>&1 | FileCheck %s
// RUN: cat %s | %cling -D__STRICT_ANSI__ -std=gnu++14 -Xclang -verify 2>&1 | FileCheck %s
// RUN: cat %s | %cling -D__STRICT_ANSI__ -std=gnu++1z -Xclang -verify 2>&1 | FileCheck %s
// REQUIRES: not_system-windows
#ifdef __cplusplus
extern "C" int printf(const char*, ...);
#else
int printf(const char*, ...);
#endif
typeof (int) Val = 22;
typeof (const char*) This = "THIS";
printf("TEST: %d '%s'\n", Val, This);
// CHECK: TEST: 22 'THIS'
// expected-no-diagnostics
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -std=gnu99 -x c -Xclang -verify 2>&1 | FileCheck %s
// RUN: cat %s | %cling -D__STRICT_ANSI__ -std=gnu++11 -Xclang -verify 2>&1 | FileCheck %s
// RUN: cat %s | %cling -D__STRICT_ANSI__ -std=gnu++14 -Xclang -verify 2>&1 | FileCheck %s
// RUN: cat %s | %cling -D__STRICT_ANSI__ -std=gnu++1z -Xclang -verify 2>&1 | FileCheck %s
// REQUIRES: not_system-windows
#ifdef __cplusplus
extern "C" int printf(const char*, ...);
#else
int printf(const char*, ...);
#endif
typeof (int) Val = 22;
typeof (const char*) This = "THIS";
printf("TEST: %d '%s'\n", Val, This);
// CHECK: TEST: 22 'THIS'
// expected-no-diagnostics
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -std=gnu99 -x c -Xclang -verify 2>&1 | FileCheck %s
// RUN: cat %s | %cling -D__STRICT_ANSI__ -std=gnu++11 -Xclang -verify 2>&1 | FileCheck %s
// RUN: cat %s | %cling -D__STRICT_ANSI__ -std=gnu++14 -Xclang -verify 2>&1 | FileCheck %s
// RUN: cat %s | %cling -D__STRICT_ANSI__ -std=gnu++1z -Xclang -verify 2>&1 | FileCheck %s
// REQUIRES: not_system-windows
#ifdef __cplusplus
extern "C" int printf(const char*, ...);
#else
int printf(const char*, ...);
#endif
typeof (int) Val = 22;
typeof (const char*) This = "THIS";
printf("TEST: %d '%s'\n", Val, This);
// CHECK: TEST: 22 'THIS'
// expected-no-diagnostics
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
//RUN: cat %s | %cling 2>&1 | FileCheck %s
#include <vector>
std::vector<char> l {'a', 'b', '\''};
*(l.begin() + 2) // CHECK: (char) '''
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -noruntime -Xclang -verify 2>&1 | FileCheck %s
// Test noruntimeTest
extern "C" int printf(const char*,...);
int TEST = 9;
TEST
// CHECK-NOT: (int) 9
printf("TEST: %d\n", TEST);
// CHECK: TEST: 9
// expected-no-diagnostics
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: %cling -C -E -P  %s | %cling -nostdinc++ -Xclang -verify 2>&1 | FileCheck %s
// RUN: %cling -C -E -P -DCLING_NO_BUILTIN %s | %cling -nostdinc++ -nobuiltininc -Xclang -verify 2>&1 | FileCheck %s
// expected-error@input_line_1:1 {{'new' file not found}}
//      CHECK: Warning in cling::IncrementalParser::CheckABICompatibility():
// CHECK-NEXT:  Possible C++ standard library mismatch, compiled with {{.*$}}
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: %cling -C -E -P  %s | %cling -nostdinc++ -Xclang -verify 2>&1 | FileCheck %s
// RUN: %cling -C -E -P -DCLING_NO_BUILTIN %s | %cling -nostdinc++ -nobuiltininc -Xclang -verify 2>&1 | FileCheck %s
// expected-error@input_line_1:1 {{'new' file not found}}
//      CHECK: Warning in cling::IncrementalParser::CheckABICompatibility():
// CHECK-NEXT:  Possible C++ standard library mismatch, compiled with {{.*$}}
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify 2>&1 | FileCheck %s
// Actually test clang::DeclContext::removeDecl(). This function in clang is
// the main method that is used for the error recovery. This means when there
// is an error in cling's input we need to revert all the declarations that came
// in from the same transaction. Even when we have anonymous declarations we
// need to be able to remove them from the declaration context. In a compiler's
// point of view there is no way that one can call removeDecl() and pass in anon
// decl, because the method is used when shadowing decls, which must have names.
// The issue is (and we patched it) is that removeDecl is trying to remove the
// anon decl (which doesn't have name) from the symbol (lookup) tables, which
// doesn't make sense.
// The current test checks if that codepath in removeDecl still exists because
// it is important for the stable error recovery in cling
.storeState "testMyClass"
class MyClass {
  struct {
    int a;
    error_here; // expected-error {{C++ requires a type specifier for all declarations}}
  };
};
.compareState "testMyClass"
 // CHECK-NOT: File with AST differencies stored in: testMyClassAST.diff
.storeState "testStructX"
struct X {
  union {
    float f3;
    double d2;
  } named;
  union {
    int i;
    float f;
    union {
      float f2;
      mutable double d;
    };
  };
  void test_unqual_references();
  struct {
    int a;
    float b;
  };
  void test_unqual_references_const() const;
  mutable union { // expected-error{{anonymous union at class scope must not have a storage specifier}}
    float c1;
    double c2;
  };
};
.compareState "testStructX"
// CHECK-NOT: File with AST differencies stored in: testStructXAST.diff
// Make FileCheck happy with having at least one positive rule:
int a = 5
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -I%p 2>&1 | FileCheck %s
// XFAIL: *
.storeState "testCurrentFailures"
#include "Overloads.h"
// CHECK: (int) 5
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %built_cling -fno-rtti -Xclang -verify 2>&1 | FileCheck %s
// Test that user can override the DiagnosicsClient without error
#include <cling/Interpreter/Interpreter.h>
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify 2>&1 | FileCheck %s
// This file should be used as regression test for the value printing subsystem
// Reproducers of fixed bugs should be put here
int Var = 43;
auto LD = []  { return Var; };
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -I%p -Xclang -verify 2>&1
.storeState "a"
auto LR = [&] { return Var; };
auto LC = [=] { return Var; } // expected-warning {{captures will be by reference, not copy}}
#include "HeaderFileProtector.h"
.compareState "a"
// CHECK-NOT: Differences
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -I%p -Xclang -verify 2>&1
extern "C" int printf(const char* fmt, ...);
#define NN 5
int printNN() {
  printf("NN=%d", NN);
  return 0;
}
printNN();
.storeState "MacroDef"
#include "MacroDef.h"
.compareState "MacroDef"
// CHECK-NOT: Differences
printNN();
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify 2>&1 | FileCheck %s
#define BEGIN_NAMESPACE namespace test_namespace {
#define END_NAMESPACE }
.rawInput 1
BEGIN_NAMESPACE int j; END_NAMESPACE // expected-note {{previous definition is here}}
.storeState "testMacroExpansion"
BEGIN_NAMESPACE int j; END_NAMESPACE // expected-error {{redefinition of 'j'}}
.compareState "testMacroExpansion"
.rawInput 0
// CHECK-NOT: Differences
// Make FileCheck happy with having at least one positive rule:
int a = 5
// CHECK: ((lambda) &) @0x{{.*}}
++Var;
LC()
// CHECK-NEXT: (int) 44
LD() == LR() && LD() == LC()
// CHECK-NEXT: (bool) true
auto LL = [=,&Var] { return Var; };
// expected-error@input_line_24:2 {{'Var' cannot be captured because it does not have automatic storage duration}}
// expected-note@input_line_13:2 {{'Var' declared here}}
// expected-warning@input_line_24:2 {{captures will be by reference, not copy}}
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -I%p 2>&1 | FileCheck %s
// The main issue is that expected - error is not propagated to the source file and
// the expected diagnostics get misplaced.
.x CannotDotX.h()
// expected-warning{{'CannotDotX' missing falling back to .L}}
// Here we cannot revert MyClass from CannotDotX.h
.L CannotDotX.h
MyClass m;
// CHECK: MyClass ctor called
.L CannotDotX.h
// CHECK: MyClass dtor called
.q
error_here;
.compareState "testCurrentFailures"
// CHECK: (int) 5
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -I%p -Xclang -verify 2>&1 | FileCheck %s
// Test the removal of decls from the redeclaration chain, which are marked as
// redeclarables.
extern int my_int;
.rawInput 1
int my_funct();
.rawInput 0
.storeState "testRedeclarables"
#include "Redeclarables.h"
.compareState "testRedeclarables"
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -v -Xclang -verify 2>&1 | FileCheck %s
int i = 0;
.storeState "A"
.storeState "B"
.storeState "C"
.undo
// CHECK: Unloading Transaction forced state 'A' to be destroyed
// CHECK-NEXT: Unloading Transaction forced state 'B' to be destroyed
// CHECK-NEXT: Unloading Transaction forced state 'C' to be destroyed
.compareState "D"
.compareState "E"
.compareState "F"
// CHECK-NEXT: The store point name D does not exist.Unbalanced store / compare
// CHECK-NEXT: The store point name E does not exist.Unbalanced store / compare
// CHECK-NEXT: The store point name F does not exist.Unbalanced store / compare
// expected-no-diagnostics
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -I%p -Xclang -verify 2>&1 | FileCheck %s
// Test the removal of decls which are stored in vector of redeclarables
.rawInput 1
extern int __my_i;
template<typename T> T TemplatedF(T t);
template<> double TemplatedF(double); // forward declare TemplatedF
int OverloadedF(int i);
float OverloadedF(float f){ return f + 100.111f;}
double OverloadedF(double d){ return d + 10.11f; };
namespace test { int y = 0; }
.rawInput 0
.storeState "testSubsequentDecls"
#include "SubsequentDecls.h"
.compareState "testSubsequentDecls"
// CHECK-NOT: Differences
int my_funct() {
  return 20;
}
int my_int = 20;
my_int
// CHECK-NOT: Differences
TemplatedF((int)2)
// CHECK: IncrementalExecutor::executeFunction: symbol '{{.*}}' unresolved while linking [cling interface function]!
// CHECK: You are probably missing the definition of int {{.*}}TemplatedF<int>(int)
// CHECK: Maybe you need to load the corresponding shared library?
template<> int TemplatedF(int i) { return i + 100; }
int OverloadedF(int i) { return i + 100;}
int __my_i = 10
// CHECK-NOT: Differences
 // This is broken case where we want to declare a function inside a wrapper
 // function, when the error recovery kicks in it segfaults.
double sin(double);
// Make FileCheck happy with having at least one positive rule:
int a = 5
#include "llvm/ADT/SmallVector.h"
#include <string>
#include <regex>
#include "cling/Interpreter/LookupHelper.h"
static void atexit_1() {
  printf("atexit_1\n");
}
static void atexit_2() {
  printf("atexit_2\n");
}
static void atexit_3() {
  printf("atexit_3\n");
}
atexit(atexit_1);
.undo
// Undoing the registration should call the function
// CHECK: atexit_1
at_quick_exit(atexit_2);
.undo
// Make sure at_quick_exit is resolved correctly (mangling issues on gcc < 5)
// CHECK-NEXT: atexit_2
// Test reverse ordering in a single transaction.
static void atexitA() { printf("atexitA\n"); }
static void atexitB() { printf("atexitB\n"); }
static void atexitC() { printf("atexitC\n"); }
{
  std::atexit(atexitA);
  std::atexit(atexitB);
  std::atexit(atexitC);
}
.undo
// CHECK-NEXT: atexitC
// CHECK-NEXT: atexitB
// CHECK-NEXT: atexitA
atexit(atexit_3);
cling::Interpreter * gChild = 0;
// CHECK: (int) 5
.q
{
  const char* kArgV[1] = {"cling"};
  cling::Interpreter ChildInterp(*gCling, 1, kArgV);
  gChild = &ChildInterp;
  ChildInterp.declare("static void atexit_c() { printf(\"atexit_c %d\\n\", gChild==__dso_handle); }");
  ChildInterp.execute("atexit(atexit_c);");
}
#include "cling/Utils/AST.h"
// ChildInterp
// CHECK: atexit_c 1
static void atexit_f() {
  printf("atexit_f %s\n", gCling==__dso_handle ? "true" : "false");
}
at_quick_exit(atexit_f);
void atExit0 () {
  printf("atExit0\n");
}
void atExit1 () {
  printf("atExit1\n");
}
void atExit2 () {
  printf("atExit2\n");
}
void atExitA () {
  printf("atExitA\n");
  std::atexit(&atExit0);
}
void atExitB () {
  printf("atExitB\n");
  std::atexit(&atExit1);
  std::atexit(&atExit2);
}
// Recursion in a Transaction
{
  std::atexit(&atExitA);
  std::atexit(&atExitB);
}
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling --enable-implicit-auto-keyword | FileCheck %s
// XFAIL: *
// ROOT-5324
b = 1
//CHECK: (int) 1
b += 1
.undo
//CHECK: (int) 2
b = 0
// CHECK-NEXT: atExitB
// CHECK-NEXT: atExit2
// CHECK-NEXT: atExit1
// CHECK-NEXT: atExitA
// CHECK-NEXT: atExit0
// Recusion at shutdown
//CHECK: (int) 0
a = b
struct ShutdownRecursion {
  static void DtorAtExit0() { printf("ShutdownRecursion0\n"); }
  static void DtorAtExit1() { printf("ShutdownRecursion1\n"); }
  static void DtorAtExit2() { printf("ShutdownRecursion2\n"); }
  ~ShutdownRecursion() {
    printf("~ShutdownRecursion\n");
    atexit(&DtorAtExit0);
    atexit(&DtorAtExit1);
    atexit(&DtorAtExit2);
  }
} Out;
//CHECK: (int) 0
int c = a
//CHECK: (int) 0
// end ROOT-5324
auto explicitAuto = "test";
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify 2>&1 | FileCheck %s
// XFAIL: *
// Test the ability of including a wrong file see diagnostics and remove the
// cached files so that all the changes are going to be seen next time it gets
// included.
.storeState "testUncacheFile"
explicitAuto
#include <iostream>
// expected-no-diagnostics
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling --enable-implicit-auto-keyword | FileCheck %s
// XFAIL: *
class MyClass {
public:
  int i;
  MyClass(int a) : i(a) {};
};
MyClass* my1 = new MyClass(0); my1->i = 10; my2 = new MyClass(my1->i); my1->i++;
my1->i
//CHECK: (int) 11
my2->i
//CHECK: (int) 10
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %built_cling -I%p | FileCheck %s
#include "cling/Interpreter/Interpreter.h"
// CHECK: (int) 20
my_funct()
// CHECK: (int) 10
OverloadedF(__my_i)
// CHECK: (int) 20
.q
// CHECK: (int) 110
TemplatedF(__my_i)
// CHECK: (int) 110
TemplatedF((double)3.14)
// CHECK: IncrementalExecutor::executeFunction: symbol '{{.*}}' unresolved while linking [cling interface function]!
// CHECK: You are probably missing the definition of double {{.*}}TemplatedF<double>(double)
// CHECK: Maybe you need to load the corresponding shared library?
// ROOT-7295
#include <vector>
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %built_cling -I%p | FileCheck %s
// The tests shows the basic control flow structures that contain dynamic
// expressions. There are several cases that could be distinguished.
// 1. IfStmt with dynamic expression in the condition like if (h->Draw())
// In that case we know that the condition is going to be implicitly
// casted to bool. Clang does it even for integral types.
//   1.1 if the dynamic expression result type is bool no cast is needed
//       and there shouldn't be problems at all.
//   1.2 if the dynamic expression is of integral type like int clang
//       makes implicit cast. I've tested with few examples and it works
//       even without the cast
// The real problem is that if we want to stick to clang's AST in the same
// way as clang builds it we need to have implicit casts for the dynamic
// expressions which return type differs from bool. The problem is we cannot
// do that at compile time because we don't know the return type of the
// expression.
#include "cling/Interpreter/Interpreter.h"
std::vector<float> a; // expected-note {{previous definition is here}}
std::vector<float> a; // expected-error {{redefinition of 'a'}}
.q
#include "clang/AST/Decl.h"
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %built_cling -I%p | FileCheck %s
// We should revise the destruction of the LifetimeHandlers, because
// its destructor uses gCling and the CompilerInstance, which are
// already gone
#include "cling/Interpreter/Interpreter.h"
//CHECK: (const char*) "test"
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %built_cling -I%p | FileCheck %s
// This test tests the hook that cling expects in clang and enables it
// at compile time. However that is not actual dynamic lookup because
// the compiler uses the hook at compile time, since we enable it on
// creation. When a symbol lookup fails in compile time, clang asks its
// externally attached sources whether they could provide the declaration
// that is being lookedup. In the current test our external source is enabled
// so it provides it on the fly, and no transformations to delay the lookup
// are performed.
#include "cling/Interpreter/Interpreter.h"
#include "dirent.h" // For lightweight dir access.
typedef llvm::SmallVector<std::string, 16> Includes;
Includes includePaths;
gCling->GetIncludePaths(includePaths, /*system=*/true, /*withflags=*/false);
DIR *dir;
struct dirent *ent;
static std::regex dirsToIgnore("(.*)/backward");
#include <fstream>
// cleanup
remove("TmpClassDef.h");
// clang caches the missed too. If the file is missing it doesn't matter whether
// we create it later or not.
#include "TmpClassDef.h"
std::ofstream myfile;
myfile.open("TmpClassDef.h");
myfile << "class MyClass{};\n"
myfile << "error_here;";
myfile << "// expected-error {{C++ requires a type specifier for all declarations}}\n"
myfile.close();
#include "TmpClassDef.h"
myfile.open("TmpClassDef.h");
myfile << "class MyClass{ \n";
myfile << "public: \n";
myfile << "  int gimme12(){\n";
myfile << "    return 12;\n"
myfile << "  }\n"
myfile << "};\n";
myfile.close();
#include "TmpClassDef.h"
MyClass my;
my.gimme12()
// CHECK: (int const) 12
.compareState "testUncacheFile"
// CHECK-NOT: File with AST differencies stored in: testUncacheFileAST.diff
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %built_cling -I%p  | FileCheck %s
#include "cling/Interpreter/Interpreter.h"
#include <cling/Utils/Diagnostics.h>
#include <cling/Utils/Output.h>
#include <clang/Frontend/CompilerInstance.h>
#include "cling/Interpreter/InterpreterCallbacks.h"
#include "cling/Interpreter/InterpreterCallbacks.h"
#include "cling/Interpreter/InterpreterCallbacks.h"
#include "cling/Interpreter/InterpreterCallbacks.h"
.dynamicExtensions
std::unique_ptr<cling::test::SymbolResolverCallback> SRC;
SRC.reset(new cling::test::SymbolResolverCallback(gCling))
gCling->setCallbacks(std::move(SRC));
#include "llvm/Support/Casting.h"
.rawInput
template <typename T> struct C {
   virtual void f() {}
   static int S;
};
template<typename T> int C<T>::S = 12;
template class C<int>;
// Nested in function class
void f() {
  class NestedC {
  public:
    virtual void g() {}
  };
}
.rawInput
const cling::LookupHelper& lh = gCling->getLookupHelper();
clang::Sema& S = gCling->getSema();
const clang::NamedDecl* D = 0;
clang::DeclContext* DC = 0;
DC = llvm::dyn_cast_or_null<clang::DeclContext>(const_cast<clang::Decl*>(lh.findScope("C<int>")));
// Fixed size arrays
int a[5] = {1,2,3,4,5};
h->PrintArray(a, 5); // CHECK: 12345
float b[4][5] = {
  {1,2,3,4,5},
  {6,7,8,9,10},
  {11,12,13,14,15},
  {16,17,18,19,20},
};
h1->PrintArray(b, 4); // CHECK: 1234567891011121314151617181920
int c[3][4][5] = {
  {
    {1,2,3,4,5},
    {6,7,8,9,10},
    {11,12,13,14,15},
    {16,17,18,19,20},
  },
  {
    {1,2,3,4,5},
    {6,7,8,9,10},
    {11,12,13,14,15},
    {16,17,18,19,20},
  },
  {
    {1,2,3,4,5},
    {6,7,8,9,10},
    {11,12,13,14,15},
    {16,17,18,19,20},
  }
};
h2->PrintArray(c, 3); // CHECK: 123456789101112131415161718192012345678910111213141516171819201234567891011121314151617181920
D = cling::utils::Lookup::Named(&S, "S", DC);
gCling->getAddressOfGlobal(D)
//CHECK-NOT: (void *) 0x0
D = cling::utils::Lookup::Named(&S, "f", DC);
gCling->getAddressOfGlobal(D)
//TODO-CHECK-NOT: (void *) 0x0
.rawInput
// Nested classes
class N1 {
public:
  class N2 {
  public:
    class N3 {
    public:
      virtual void fN3() {}
    };
    virtual void fN2() = 0;
  };
};
.rawInput
DC = llvm::dyn_cast_or_null<clang::DeclContext>(const_cast<clang::Decl*>(lh.findScope("N1::N2")));
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %built_cling -I%p 2>&1 | FileCheck %s
// Test failures of dynamic lookups.
// This test tests the hook that cling expects in clang and enables it
// at compile time. However that is not actual dynamic lookup because
// the compiler uses the hook at compile time, since we enable it on
// creation. When a symbol lookup fails in compile time, clang asks its
// externally attached sources whether they could provide the declaration
// that is being lookedup. In the current test our external source is enabled
// so it provides it on the fly, and no transformations to delay the lookup
// are performed.
#include "cling/Interpreter/Interpreter.h"
D = cling::utils::Lookup::Named(&S, "fN2", DC);
gCling->getAddressOfGlobal(D)
//CHECK-NOT: (void *) 0x0
.rawInput
// vbases
class V { public: virtual void fV() {} };
class B1 : virtual public V { /* ... */ };
class B2 : virtual public V { /* ... */ };
class B3 : public V { /* ... */ };
class X : public B1, public B2, public B3 {
public:
  virtual void fV(){}
  struct S {
    virtual void fS() {}
  };
};
.rawInput
DC = llvm::dyn_cast_or_null<clang::DeclContext>(const_cast<clang::Decl*>(lh.findScope("X")));
#include "cling/Interpreter/InterpreterCallbacks.h"
D = cling::utils::Lookup::Named(&S, "fV", DC);
gCling->getAddressOfGlobal(D)
//CHECK-NOT: (void *) 0x0
DC = llvm::dyn_cast_or_null<clang::DeclContext>(const_cast<clang::Decl*>(lh.findScope("X::S")));
extern "C" int printf(const char*,...);
.dynamicExtensions
D = cling::utils::Lookup::Named(&S, "fS", DC);
gCling->getAddressOfGlobal(D)
//CHECK-NOT: (void *) 0x0
std::unique_ptr<cling::test::SymbolResolverCallback> SRC;
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify 2>&1 | FileCheck %s
#include "cling/Interpreter/Interpreter.h"
SRC.reset(new cling::test::SymbolResolverCallback(gCling))
.dynamicExtensions 1
gCling->setCallbacks(std::move(SRC));
std::unique_ptr<cling::test::SymbolResolverCallback> SRC;
int a[5] = {1,2,3,4,5};
if (h->PrintArray(a, 5)) { // runtime result type bool
  whatever->PrintString("Replaced in then.\n");
  printf("\n%s\n", "Array Printed Successfully!");
}
SRC.reset(new cling::test::SymbolResolverCallback(gCling))
gCling->setCallbacks(std::move(SRC));
// CHECK: 12345
// CHECK: Replaced in then.
// CHECK: Array Printed Successfully!
int b, c = 1;
// Note that in case of function not returning bool we need an ImplicitCast
// which is tricky because we don't know the type of the function
if (h->Add(b, c)) { // runtime result type int
  printf("\n%s\n", "Sum more than 0!");
}
// CHECK: Sum more than 0!
for (int i = 0; i < 2; ++i) {
  dependentInLoop->Add(b, c);
 }
.x LifetimeHandler.h
//CHECK-NOT:(int) 1
.q
.dynamicExtensions 1
// CHECK: Alpha's single arg ctor called {{.*Interpreter.*}}
// CHECK: After Alpha is Beta {{.*Interpreter.*}}
// CHECK: Alpha dtor called {{.*Interpreter.*}}
Alpha a(sadasds->getVersion());
std::unique_ptr<cling::test::SymbolResolverCallback> SRC;
printf("%s\n", a.getVar()); // CHECK: {{.*Interpreter.*}}
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: clang -shared -DCLING_EXPORT=%dllexport %S/address_lib.c -olibaddress_lib%shlibext
// RUN: cat %s | %built_cling -L. -fno-rtti | FileCheck %s
extern "C" int printf(const char*,...);
#include "cling/Interpreter/Interpreter.h"
int res = h->Add10(h->Add10(h->Add10(0))) // CHECK: (int) 30
SRC.reset(new cling::test::SymbolResolverCallback(gCling))
.q
gCling->setCallbacks(std::move(SRC));
// Limited regexp support, cannot do file by file.
std::string filesToIgnore = "bfd.h;bfdlink.h;";
// LLVM/Clang internals, cannot be directly included:
filesToIgnore += "varargs.h;wmmintrin.h;altivec.h;";
filesToIgnore += "shaintrin.h;xopintrin.h;lzcntintrin.h;rdseedintrin.h;";
filesToIgnore += "pmmintrin.h;tmmintrin.h;ia32intrin.h;bmiintrin.h;arm_neon.h;";
filesToIgnore += "prfchwintrin.h;fmaintrin.h;bmi2intrin.h;ammintrin.h;";
filesToIgnore += "module.modulemap;smmintrin.h;Intrin.h;avxintrin.h;tbmintrin.h;";
filesToIgnore += "f16cintrin.h;nmmintrin.h;__wmmintrin_aes.h;popcntintrin.h;";
filesToIgnore += "__wmmintrin_pclmul.h;rtmintrin.h;fma4intrin.h;avx2intrin.h;";
// Wrong setups, i.e not self-contained header files:
filesToIgnore += "dlg_colors.h;dialog.h;plugin-api.h;regexp.h;etip.h;dlg_keys.h;";
filesToIgnore += "cursesw.h;cursesm.h;cursesf.h;cursslk.h;cursesapp.h;term_entry.h;";
filesToIgnore += "cursesp.h;ft2build.h;shared_mutex;ciso646;cxxabi.h;";
// AUX:
filesToIgnore += "Makefile;CMakeLists.txt;";
jksghdgsjdf->getVersion() // CHECK: {{.*Interpreter.*}}
.rawInput 1
bool has_suffix(const std::string &str, const std::string &suffix) {
    return str.size() >= suffix.size() &&
           str.compare(str.size() - suffix.size(), suffix.size(), suffix) == 0;
}
.rawInput 0
std::string fwdDeclFile;
std::string nestedCling = CLING; nestedCling += " -Xclang -verify ";
std::string sourceCode;
for (int i = 0; i < 1 /*includePaths.size()*/; ++i) { // We know STL is first.
  if (std::regex_match(includePaths[i], dirsToIgnore))
    continue;
  if ((dir = opendir(includePaths[i].c_str())) != NULL) {
    /* print all the files and directories within directory */
    while ((ent = readdir(dir)) != NULL) {
      if (filesToIgnore.find(ent->d_name) != std::string::npos)
        continue;
      if (includePaths[i] == "." && !has_suffix(ent->d_name, ".h"))
        continue;
      if (ent->d_type == DT_REG && strcmp(ent->d_name, ".") && strcmp(ent->d_name, "..")) {
        fwdDeclFile = "/tmp/__cling_fwd_"; fwdDeclFile += ent->d_name;
        gCling->GenerateAutoloadingMap(ent->d_name, fwdDeclFile);
        // Run it in separate cling and assert it went all fine:
        sourceCode = " \"//expected-no-diagnostics\"";
        sourceCode += " '#include \"" + fwdDeclFile + "\"'";
        sourceCode += std::string(" '#include \"") + ent->d_name + "\"'";
        if (system((nestedCling + sourceCode).c_str()))
          printf("fail: %s\n", (nestedCling + sourceCode).c_str());
        //printf("%s\n", ent->d_name);
        else puts("pass\n");
      }
    }
    closedir(dir);
  }
 }
hsdghfjagsp->Draw() // CHECK: (int) 12
h->Add10(h->Add10(h->Add10(0))) // CHECK: (int) 30
h->PrintString(std::string("test")); // CHECK: test
int a[5] = {1,2,3,4,5};
h->PrintArray(a, 5); // CHECK: 12345
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling 2>&1 | FileCheck %s
#include "cling/Interpreter/Interpreter.h"
.dynamicExtensions
std::unique_ptr<cling::test::SymbolResolverCallback> SRC;
SRC.reset(new cling::test::SymbolResolverCallback(gCling))
gCling->setCallbacks(std::move(SRC));
jksghdgsjdf->getVersion() // CHECK: {{.*Interpreter.*}}
hsdghfjagsp->Draw() // CHECK: (int) 12
h->PrintString(std::string("test")); // CHECK: test
int a[5] = {1,2,3,4,5};
h->PrintArray(a, 5); // CHECK: 12345
// ROOT-6650
std::string* s = new std::string(h->getVersion());
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify | FileCheck %s
#include "cling/Interpreter/Interpreter.h"
using namespace cling::utils;
DiagnosticsStore LC(gCling->getCI()->getDiagnostics(), false);
gCling->echo("error");
// When preprocessed out is supported, test that reporting works too.
// LC.Report();
for (const auto& D : LC) {
  cling::outs() << "STORED <" << D.getMessage() << ">\n";
}
// CHECK: STORED <use of undeclared identifier 'error'>
// expected-no-diagnostics
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling 2>&1 | FileCheck %s
#include "cling/Interpreter/Interpreter.h"
#include "cling/Interpreter/InterpreterCallbacks.h"
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %built_cling -Xclang -verify 2>&1 | FileCheck %s
// Make sure we are correctly parsing the arguments for CIFactory::createCI
#include "cling/Interpreter/InvocationOptions.h"
#define TEST01 "A  B  C  D  E  F"
gCling->getMacroValue("TEST01")
// CHECK: (std::string) "A  B  C  D  E  F"
#define TEST02 0  1  2  3  4  5  6  7
gCling->getMacroValue("TEST02")
// CHECK-NEXT: (std::string) "0 1 2 3 4 5 6 7"
#define TEST03 STRIP "STRING" TEST
gCling->getMacroValue("TEST03")
// CHECK-NEXT: (std::string) "STRIP STRING TEST"
#define TEST03 STRIP "STRING" TEST
gCling->getMacroValue("TEST03", 0)
// CHECK-NEXT: (std::string) "STRIP "STRING" TEST"
#define TEST04(A,B,C) A ##B #C
gCling->getMacroValue("TEST04")
// CHECK-NEXT: (std::string) "A ## B # C"
// expected-no-diagnostics
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -DTEST_PATH="\"%/p/\"" -Xclang -verify 2>&1 | FileCheck %s
#include "cling/Interpreter/Interpreter.h"
#include "cling/Utils/AST.h"
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %built_cling -fno-rtti | FileCheck %s
// This test makes sure the interpreter doesn't create many useless empty
// transactions.
// Author: Vassil Vassilev
#include "cling/Interpreter/Interpreter.h"
#include "cling/Interpreter/Value.h"
gCling->echo("1;");
// CHECK: (int) 1
cling::Value V;
gCling->echo("2;", &V);
V
// CHECK-NEXT: (int) 2
// CHECK-NEXT: (cling::Value &) boxes [(int) 2]
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: clang -shared -DCLING_EXPORT=%dllexport %S/call_lib.c -o%T/libcall_lib2%shlibext
// RUN: cat %s | %cling -L%T | FileCheck %s
.L libcall_lib2
extern "C" int cling_testlibrary_function();
int i = cling_testlibrary_function();
extern "C" int printf(const char* fmt, ...);
printf("got i=%d\n", i); // CHECK: got i=66
.q
const char* argv[] = {
  "progname",
  "-",
  "-xobjective-c",
  "FileToExecuteA",
  "-isysroot",
  "APAth",
  "-nobuiltininc",
  "-v",
  "FileToExecuteB",
  "-L/Path/To/Libs",
  "-lTest"
};
const int argc = sizeof(argv)/sizeof(argv[0]);
cling::CompilerOptions COpts(argc, argv);
COpts.Language
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: clang -shared -DCLING_EXPORT=%dllexport %S/call_lib.c -o%T/libcall_lib%shlibext
// RUN: cat %s | %cling -L%T | FileCheck %s
.L libcall_lib
extern "C" int cling_testlibrary_function();
cling_testlibrary_function()
#include "clang/AST/Decl.h"
// CHECK: (unsigned int) 1
COpts.SysRoot
// CHECK-NEXT: (unsigned int) 1
COpts.NoBuiltinInc
// CHECK-NEXT: (unsigned int) 1
COpts.NoCXXInc
// CHECK-NEXT: (unsigned int) 0
// library caller options: arguments passed as is
COpts.Remaining
// CHECK-NEXT: {{.*}} { "progname", "-", "-xobjective-c", "FileToExecuteA", "-isysroot", "APAth", "-nobuiltininc", "-v", "FileToExecuteB", "-L/Path/To/Libs", "-lTest" }
argv[6] = "-nostdinc++";
cling::InvocationOptions IOpts(argc, argv);
IOpts.Inputs
// CHECK-NEXT: {{.*}} { "-", "FileToExecuteA", "FileToExecuteB" }
IOpts.LibSearchPath
// CHECK-NEXT: {{.*}} { "/Path/To/Libs" }
IOpts.LibsToLoad
// CHECK-NEXT: {{.*}} { "Test" }
IOpts.CompilerOpts.Language
// CHECK-NEXT: (unsigned int) 1
IOpts.CompilerOpts.SysRoot
// CHECK-NEXT: (unsigned int) 1
IOpts.CompilerOpts.NoBuiltinInc
// CHECK-NEXT: (unsigned int) 0
IOpts.CompilerOpts.NoCXXInc
// CHECK-NEXT: (unsigned int) 1
// user options from main: filtered by cling (no '-')
IOpts.CompilerOpts.Remaining
// Windows translates -nostdinc++ to -nostdinc++. Ignore that fact for the test.
// CHECK-NEXT: {{.*}} { "progname", "-xobjective-c", "FileToExecuteA", "-isysroot", "APAth", {{.*}}, "-v", "FileToExecuteB" }
// expected-no-diagnostics
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %built_cling -fno-rtti 2>&1 | FileCheck %s
// Test findArgList
#include "cling/Interpreter/Interpreter.h"
.dynamicExtensions 1
std::unique_ptr<cling::test::SymbolResolverCallback> SRC;
SRC.reset(new cling::test::SymbolResolverCallback(gCling, false))
// CHECK: (int) 66
gCling->setCallbacks(std::move(SRC));
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %built_cling -fno-rtti 2>&1 | FileCheck %s
// Test lookupData
.rawInput 1
#include "cling/Interpreter/Interpreter.h"
p.q // CHECK: {{input_line_.*: error: use of undeclared identifier 'p'}}
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %built_cling -fno-rtti 2>&1 | FileCheck %s
// Test lookupFunctionArgs()
.rawInput
#include "cling/Interpreter/Interpreter.h"
#include "cling/Interpreter/Value.h"
#include <cmath>
cling::Value V;
V // CHECK: (cling::Value &) <<<invalid>>> @0x{{.*}}
gCling->evaluate("return 1;", V);
V // CHECK: (cling::Value &) boxes [(int) 1]
gCling->evaluate("(void)V", V);
V // CHECK-NEXT: (cling::Value &) boxes [(void) ]
// Returns must put the result in the Value.
bool cond = true;
gCling->evaluate("if (cond) return \"true\"; else return 0;", V);
V // CHECK-NEXT: (cling::Value &) boxes [(const char [5]) "true"]
gCling->evaluate("if (cond) return; else return 12;", V);
V // CHECK-NEXT: (cling::Value &) boxes [(void) ]
gCling->evaluate("if (cond) return; int aa = 12;", V);
V // CHECK-NEXT: (cling::Value &) boxes [(void) ]
gCling->evaluate("cond = false; if (cond) return \"true\"; else return 0;", V);
V // CHECK-NEXT: (cling::Value &) boxes [(int) 0]
gCling->evaluate("bool a = [](){return true;};", V);
V // CHECK-NEXT: (cling::Value &) boxes [(bool) true]
gCling->evaluate("auto a = 12.3; a;", V);
V // CHECK: (cling::Value &) boxes [(double) 12.300000]
long LongV = 17;
gCling->evaluate("LongV;", V);
V // CHECK: (cling::Value &) boxes [(long) 17]
int* IntP = (int*)0x12;
gCling->evaluate("IntP;", V);
V // CHECK: (cling::Value &) boxes [(int *) 0x12 <invalid memory address>]
cling::Value Result;
gCling->evaluate("V", Result);
// Here we check what happens for record type like cling::Value; they are returned by reference.
Result // CHECK: (cling::Value &) boxes [(cling::Value &) boxes [(int *) 0x12 <invalid memory address>]]
V // CHECK: (cling::Value &) boxes [(int *) 0x12 <invalid memory address>]
// Savannah #96277
gCling->evaluate("gCling->declare(\"double sin(double);\"); double one = sin(3.1416/2);", V);
V // CHECK: (cling::Value &) boxes [(double) 1.0000000]
gCling->process("double one = sin(3.1416/2); // expected-note {{previous definition is here}}", &V);
V // CHECK: (cling::Value &) boxes [(double) 1.0000000]
one // CHECK: (double) 1
int one; // expected-error {{redefinition of 'one' with a different type: 'int' vs 'double'}}
// Make sure that PR#98434 doesn't get reintroduced.
.rawInput
void f(int) { return; }
.rawInput
gCling->evaluate("f", V);
V.isValid() //CHECK: {{\([_]B|b}}ool) true
// end PR#98434
// Multi-dim arrays (ROOT-7016)
gCling->evaluate("int multiDimArray[2][3][4]{{{1,2,3,4},{11,12,13,14},{21,22,23,24}},"
                 "{{101,102,103,104},{111,112,113,114},{121,122,123,124}}};", V);
V // CHECK-NEXT: (cling::Value &) boxes [(int [2][3][4]) { { { 1, 2, 3, 4 }, { 11, 12, 13, 14 }, { 21, 22, 23, 24 } }, { { 101, 102, 103, 104 }, { 111, 112, 113, 114 }, { 121, 122, 123, 124 } } }]
// Check lifetime of objects in Value
.rawInput 1
struct WithDtor {
   static int fgCount;
   WithDtor() { ++fgCount; }
   WithDtor(const WithDtor&) { ++fgCount; }
   ~WithDtor() { --fgCount; }
};
int WithDtor::fgCount = 0;
WithDtor getWithDtor() { return WithDtor(); }
#include <vector>
std::vector<WithDtor> getWithDtorVec() { std::vector<WithDtor> ret; ret.resize(7); return ret; }
.rawInput 0
cling::Value* VOnHeap = new cling::Value();
gCling->evaluate("getWithDtor()", *VOnHeap);
*VOnHeap //CHECK: (cling::Value &) boxes [(WithDtor) @0x{{.*}}]
WithDtor::fgCount //CHECK: (int) 1
delete VOnHeap;
WithDtor::fgCount //CHECK: (int) 0
// Check destructor call for templates
VOnHeap = new cling::Value();
gCling->evaluate("getWithDtorVec()", *VOnHeap);
*VOnHeap //CHECK: (cling::Value &) boxes [(std::vector<WithDtor>) {{{ (@0x.*, )*@0x.* }}}]
WithDtor::fgCount //CHECK: (int) 7
delete VOnHeap;
WithDtor::fgCount //CHECK: (int) 0
// long doubles (tricky for the JIT).
gCling->evaluate("17.42L", V);
V // CHECK: (cling::Value &) boxes [(long double) 17.42{{[0-9]*}}L]
// Test references, temporaries
.rawInput 1
extern "C" int printf(const char*,...);
struct Tracer {
  std::string Content;
  int Instance;
  static int InstanceCount;
  Tracer(const char* str): Content(str), Instance(++InstanceCount) {
    dump("ctor");
  }
  Tracer(const Tracer& o): Content(o.Content + "+"), Instance(++InstanceCount) {
    dump("copy");
  }
  ~Tracer() { dump("dtor");}
  std::string asStr() const {
    return Content + "{" + std::to_string(Instance) + "}";
  }
  void dump(const char* tag) { printf("%s:%s\n", asStr().c_str(), tag); }
};
int Tracer::InstanceCount = 0;
Tracer ObjMaker() { return Tracer("MADE"); }
Tracer& RefMaker() { static Tracer R("REF"); return R; }
const Tracer& ConstRefMaker() {static Tracer R("CONSTREF"); return R;}
namespace cling {
  // FIXME: inline printValue is not used by PrintClingValue()!
  std::string printValue(const Tracer* const p, const Tracer* const u,
                         const Value& V) {
    return p->asStr();
  }
}
void dumpTracerSVR(cling::Value& svr) {
  ((Tracer*)svr.getAs<void*>())->dump("dump");
}
.rawInput 0
// Creating the static in constructs one object. It gets returned by
// reference; it should only be destructed by ~JIT, definitely not by
// ~Value (which should only store a Tracer&)
gCling->evaluate("RefMaker()", V);
// This is the local static:
// CHECK: REF{1}:ctor
printf("RefMaker() done\n"); // CHECK-NEXT: RefMaker() done
V // CHECK-NEXT: (cling::Value &) boxes [(Tracer &) @{{.*}}]
dumpTracerSVR(V); // CHECK-NEXT: REF{1}:dump
// Setting a new value should destruct the old - BUT it's a ref thus no
// destruction.
// Create a temporary. Copies it into V through placement-new and copy
// construction. The latter is elided; the temporary *is* what's stored in V.
// Thus all we see is the construction of the temporary.
gCling->evaluate("ObjMaker()", V);
// The temporary gets created:
// CHECK-NEXT:MADE{2}:ctor
printf("ObjMaker() done\n"); //CHECK-NEXT: ObjMaker() done
V // CHECK-NEXT: (cling::Value &) boxes [(Tracer) @{{.*}}]
dumpTracerSVR(V); // CHECK-NEXT: MADE{2}:dump
// Creating a variable:
Tracer RT("VAR"); // CHECK-NEXT: VAR{3}:ctor
// The following is a declRefExpr of lvalue type. We explicitly treat this as
// a reference; i.e. the cling::Value will claim to store a Tracer&. No extra
// construction, no extra allocation should happen.
//
// Setting a new value should destruct the old:
// CHECK-NEXT: MADE{2}:dtor
gCling->evaluate("RT", V); // should not call any ctor!
printf("RT done\n"); //CHECK-NEXT: RT done
V // CHECK-NEXT: (cling::Value &) boxes [(Tracer &) @{{.*}}]
dumpTracerSVR(V); // CHECK-NEXT: VAR{3}:dump
// The following creates a copy, explicitly. This temporary object is then put
// into the Value.
//
gCling->evaluate("(Tracer)RT", V);
// Copies RT:
//CHECK-NEXT: VAR+{4}:copy
printf("(Tracer)RT done\n"); //CHECK-NEXT: RT done
V // CHECK-NEXT: (cling::Value &) boxes [(Tracer) @{{.*}}]
gCling->execute("1;");
extern "C" int printf(const char* fmt, ...);
gCling->execute("printf(\"%d\", printf(\"%d\",1));");
dumpTracerSVR(V); // CHECK-NEXT: VAR+{4}:dump
// CHECK: 11
// Check eval of array var
Tracer arrV[] = {ObjMaker(), ObjMaker(), ObjMaker()};
// The array is built:
//CHECK-NEXT: MADE{5}:ctor
//CHECK-NEXT: MADE{6}:ctor
//CHECK-NEXT: MADE{7}:ctor
gCling->evaluate("arrV", V);
// Now V gets destructed...
//CHECK-NEXT: VAR+{4}:dtor
// ...and the elements are copied:
//CHECK-NEXT: MADE+{8}:copy
//CHECK-NEXT: MADE+{9}:copy
//CHECK-NEXT: MADE+{10}:copy
V // CHECK-NEXT: (cling::Value &) boxes [(Tracer [3]) { @{{.*}}, @{{.*}}, @{{.*}} }]
// Explicitly destory the copies
V = cling::Value()
//CHECK-NEXT: MADE+{10}:dtor
//CHECK-NEXT: MADE+{9}:dtor
//CHECK-NEXT: MADE+{8}:dtor
//CHECK-NEXT: (cling::Value &) <<<invalid>>> @0x{{.*}}
gCling->evaluate("arrV", V);
//CHECK-NEXT: MADE+{11}:copy
//CHECK-NEXT: MADE+{12}:copy
//CHECK-NEXT: MADE+{13}:copy
// Destruct the variables with static storage:
// Destruct arrV:
//CHECK-NEXT: MADE{7}:dtor
//CHECK-NEXT: MADE{6}:dtor
//CHECK-NEXT: MADE{5}:dtor
// CHECK-NEXT: VAR{3}:dtor
// CHECK-NEXT: REF{1}:dtor
// V going out of scope
//CHECK-NEXT: MADE+{13}:dtor
//CHECK-NEXT: MADE+{12}:dtor
//CHECK-NEXT: MADE+{11}:dtor
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %built_cling -fno-rtti 2>&1 | FileCheck %s
// Test Lookup::Named and Namespace, used in quick simple lookups.
#include "cling/Interpreter/Interpreter.h"
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %built_cling -fno-rtti 2>&1 | FileCheck %s
// Test findScope, which is essentially is a DeclContext.
#include "cling/Interpreter/Interpreter.h"
gCling->AddIncludePaths(TEST_PATH "Paths/A:" TEST_PATH "Paths/B:"
                        TEST_PATH "Paths/C");
#include "A.h"
#include "B.h"
#include "C.h"
gCling->AddIncludePath(TEST_PATH "Paths/D");
#include "D.h"
TestA
// CHECK: (const char *) "TestA"
TestB
// CHECK: (const char *) "TestB"
TestC
// CHECK: (const char *) "TestC"
TestD
// CHECK: (const char *) "TestD"
// expected-no-diagnostics
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %built_cling -fno-rtti 2>&1 | FileCheck %s
// Test findClassTemplate, which is esentially is a DeclContext.
#include "cling/Interpreter/Interpreter.h"
#include "cling/Interpreter/Transaction.h"
#include "cling/Interpreter/LookupHelper.h"
#include "clang/AST/ASTContext.h"
#include "cling/Interpreter/LookupHelper.h"
#include "cling/Utils/Output.h"
#include "clang/AST/ASTContext.h"
#include "cling/Interpreter/LookupHelper.h"
#include "cling/Utils/Output.h"
#include "clang/AST/ASTContext.h"
#include "clang/AST/GlobalDecl.h"
#include "cling/Interpreter/LookupHelper.h"
#include "cling/Utils/AST.h"
#include "clang/AST/Decl.h"
#include "cling/Interpreter/LookupHelper.h"
#include "clang/AST/Decl.h"
#include "cling/Interpreter/LookupHelper.h"
#include "clang/AST/Decl.h"
#include "clang/AST/Decl.h"
const char* comp(void* A, void* B) {
  if (A == B) { return "equal"; }
  else { printf("[%p %p] ", A, B); return "DIFFER!"; }
}
bool fromJIT = false;
clang::Sema& sema = gCling->getSema();
int gMyGlobal = 12;
void* addr1 = &gMyGlobal;
clang::NamedDecl* D = cling::utils::Lookup::Named(&sema, "gMyGlobal");
if (!D) printf("gMyGlobal decl not found!\n");
clang::VarDecl* VD = llvm::cast<clang::VarDecl>(D);
void* addr2 = gCling->getAddressOfGlobal(clang::GlobalDecl(VD), &fromJIT);
if (!fromJIT) printf("gMyGlobal should come from JIT!\n");
printf("gMyGlobal: %s\n", comp(addr1, addr2)); // CHECK: gMyGlobal: equal
.rawInput
namespace N {
   int gMyGlobal = 13;
}
.rawInput
void* addrN1 = &N::gMyGlobal;
clang::NamespaceDecl* ND = cling::utils::Lookup::Namespace(&sema, "N");
if (!ND) printf("namespace N decl not found!\n");
fromJIT = false;
VD = llvm::cast<clang::VarDecl>(cling::utils::Lookup::Named(&sema, "gMyGlobal", ND));
if (!VD) printf("N::gMyGlobal decl not found!\n");
void* addrN2 = gCling->getAddressOfGlobal(clang::GlobalDecl(VD), &fromJIT);
if (!fromJIT) printf("N::gMyGlobal should come from JIT!\n");
printf("N::gMyGlobal: %s\n", comp(addrN1, addrN2)); //CHECK: N::gMyGlobal: equal
.L address_lib
extern "C" {
  int gLibGlobal;
  extern const char gByteAlign0, gByteAlign1, gByteAlign2, gByteAlign3;
}
void* addrL1 = &gLibGlobal;
fromJIT = true;
VD = llvm::cast<clang::VarDecl>(cling::utils::Lookup::Named(&sema, "gLibGlobal"));
if (!VD) printf("gLibGlobal decl not found!\n");
void* addrL2 = gCling->getAddressOfGlobal(clang::GlobalDecl(VD), &fromJIT);
if (fromJIT) printf("gLibGlobal should NOT come from JIT!\n");
printf("gLibGlobal: %s\n", comp(addrL1, addrL2)); //CHECK-NEXT: gLibGlobal: equal
static bool symalign(clang::Sema& sema) {
  bool b0, b1, b2, b3;
  clang::VarDecl
  *g0 = llvm::cast<clang::VarDecl>(cling::utils::Lookup::Named(&sema, "gByteAlign0")),
  *g1 = llvm::cast<clang::VarDecl>(cling::utils::Lookup::Named(&sema, "gByteAlign1")),
  *g2 = llvm::cast<clang::VarDecl>(cling::utils::Lookup::Named(&sema, "gByteAlign2")),
  *g3 = llvm::cast<clang::VarDecl>(cling::utils::Lookup::Named(&sema, "gByteAlign3"));
  gCling->getAddressOfGlobal(clang::GlobalDecl(g0), &b0);
  gCling->getAddressOfGlobal(clang::GlobalDecl(g1), &b1);
  gCling->getAddressOfGlobal(clang::GlobalDecl(g2), &b2);
  gCling->getAddressOfGlobal(clang::GlobalDecl(g3), &b3);
  return !b0 && !b1 && !b2 && !b3;
}
symalign(sema)
// CHECK-NEXT: (bool) true
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %built_cling -fno-rtti 2>&1 | FileCheck %s
// Test Interpreter::lookupType()
//
#include "cling/Interpreter/Interpreter.h"
#include "clang/AST/Type.h"
#include <cstdio>
using namespace cling;
using namespace llvm;
.rawInput 1
namespace Functions {
void Next();
}
using namespace Functions;
namespace Next {
class Inside_Next {};
}
namespace AnotherNext {
class Inside_AnotherNext {};
}
.rawInput 0
clang::Sema& S = gCling->getSema();
const LookupHelper& lookup = gCling->getLookupHelper();
LookupHelper::DiagSetting diags = LookupHelper::WithDiagnostics;
const clang::NamedDecl *decl{nullptr};
decl = utils::Lookup::Named(&S, "AnotherNext", nullptr);
decl
//CHECK: (const clang::NamedDecl *) 0x{{[1-9a-f][0-9a-f]*$}}
decl->getQualifiedNameAsString().c_str()
//CHECK-NEXT: ({{[^)]+}}) "AnotherNext"
const clang::DeclContext *context = dyn_cast<clang::DeclContext>(decl);
context
//CHECK: (const clang::DeclContext *) 0x{{[1-9a-f][0-9a-f]*$}}
decl = utils::Lookup::Named(&S, "Inside_AnotherNext", context);
decl
//CHECK: (const clang::NamedDecl *) 0x{{[1-9a-f][0-9a-f]*$}}
decl->getQualifiedNameAsString().c_str()
//CHECK-NEXT: ({{[^)]+}}) "AnotherNext::Inside_AnotherNext"
// Now test the ambiguities.
decl = utils::Lookup::Named(&S, "Next", nullptr);
decl
//CHECK: (const clang::NamedDecl *) 0x{{f+[ $]}}
const clang::Decl* nextDecl = lookup.findScope("Next", diags);
nextDecl
//CHECK: (const clang::Decl *) 0x{{[1-9a-f][0-9a-f]*$}}
cast<clang::NamedDecl>(nextDecl)->getQualifiedNameAsString().c_str()
//CHECK-NEXT: ({{[^)]+}}) "Next"
context = llvm::dyn_cast<clang::DeclContext>(nextDecl);
context
//CHECK: (const clang::DeclContext *) 0x{{[1-9a-f][0-9a-f]*$}}
decl = utils::Lookup::Named(&S, "Inside_Next", context);
decl
//CHECK: (const clang::NamedDecl *) 0x{{[1-9a-f][0-9a-f]*$}}
// Now test looking up non-existing things.
// In global scope
decl = utils::Lookup::Named(&S, "DoesNotExist", nullptr);
decl
//CHECK: (const clang::NamedDecl *) {{0x0*$|nullptr}}
// In a namespace
decl = utils::Lookup::Named(&S, "EvenLess", context);
decl
//CHECK: (const clang::NamedDecl *) {{0x0*$|nullptr}}
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -fno-rtti 2>&1 | FileCheck %s
// XFAIL:*
// This test assures that varidiac funcions can be found by our string-based
// lookup.
#include "cling/Interpreter/Interpreter.h"
#include "clang/AST/Type.h"
#include <cstdio>
using namespace std;
using namespace llvm;
using namespace cling;
.rawInput 1
class A {};
.rawInput 0
const LookupHelper& lookup = gCling->getLookupHelper();
LookupHelper::DiagSetting diags = LookupHelper::WithDiagnostics;
const clang::Decl* cl_A = lookup.findScope("A", diags);
printf("cl_A: 0x%lx\n", (unsigned long) cl_A);
//CHECK: cl_A: 0x{{[1-9a-f][0-9a-f]*$}}
cast<clang::NamedDecl>(cl_A)->getQualifiedNameAsString().c_str()
//CHECK-NEXT: ({{[^)]+}}) "A"
.rawInput 1
namespace N {
class A {};
}
.rawInput 0
const clang::Decl* cl_A_in_N = lookup.findScope("N::A", diags);
printf("cl_A_in_N: 0x%lx\n", (unsigned long) cl_A_in_N);
//CHECK: cl_A_in_N: 0x{{[1-9a-f][0-9a-f]*$}}
cast<clang::NamedDecl>(cl_A_in_N)->getQualifiedNameAsString().c_str()
//CHECK-NEXT: ({{[^)]+}}) "N::A"
.rawInput 1
namespace N {
namespace M {
namespace P {
class A {};
}
}
}
.rawInput 0
const clang::Decl* cl_A_in_NMP = lookup.findScope("N::M::P::A", diags);
cl_A_in_NMP
//CHECK: (const clang::Decl *) 0x{{[1-9a-f][0-9a-f]*$}}
cast<clang::NamedDecl>(cl_A_in_NMP)->getQualifiedNameAsString().c_str()
//CHECK-NEXT: ({{[^)]+}}) "N::M::P::A"
.rawInput 1
template <class T> class B { T b; };
.rawInput 0
const clang::Decl* cl_B_int = lookup.findScope("B<int>", diags);
printf("cl_B_int: 0x%lx\n", (unsigned long) cl_B_int);
//CHECK-NEXT: cl_B_int: 0x{{[1-9a-f][0-9a-f]*$}}
//
//  Test optional returned type is as spelled by the user.
//
typedef int Int_t;
.rawInput 1
template <typename T> struct W { T member; };
.rawInput 0
const clang::Type* resType = 0;
lookup.findScope("W<Int_t>", diags, &resType);
//resType->dump();
clang::QualType(resType,0).getAsString().c_str()
//CHECK-NEXT: ({{[^)]+}}) "W<Int_t>"
.rawInput 1
namespace Functions {
void Next();
}
using namespace Functions;
namespace Next {}
.rawInput 0
const clang::Decl* cl_Next = lookup.findScope("Next", diags);
printf("cl_Next: 0x%lx\n", (unsigned long) cl_Next);
//CHECK-NEXT: cl_Next: 0x{{[1-9a-f][0-9a-f]*$}}
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling 2>&1 | FileCheck %s
// Test to check the functionality of the multiple interpreters.
// Create a "child" interpreter and use gCling as its "parent".
#include "cling/Interpreter/Interpreter.h"
#include "clang/AST/Expr.h"
#include "clang/AST/Expr.h"
#include <stdio.h>
using namespace cling;
void generateNestedTransaction(int depth) {
  if (!depth)
    return;
  cling::Interpreter::PushTransactionRAII RAIIT(gCling);
  if (depth | 0x1) { // if odd
    char buff[100];
    sprintf(buff, "int i%d;", depth);
    gCling->process(buff);
  } // this will cause every even transaction to be reused.
  generateNestedTransaction(--depth);
}
generateNestedTransaction(5);
const cling::Transaction* T = gCling->getFirstTransaction();
while(T) {
  if (T->empty())
    printf("Empty transaction detected!\n");
  else if (T->getWrapperFD() && T->getWrapperFD()->getKind() != clang::Decl::Function)
    printf("Unexpected wrapper kind!\n");
  if (T->getState() != Transaction::kCommitted)
    printf("Unexpected transaction state!\n");
  //T->printStructure();
  T = T->getNext();
}
#include "clang/AST/Decl.h"
#include "clang/AST/DeclTemplate.h"
printf("Just make FileCheck(CHECK-NOT) happy.\n")
//CHECK-NOT:Empty transaction detected!
//CHECK-NOT:Unexpected wrapper kind!
//CHECK-NOT:Unexpected transaction state!
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify
// XFAIL: powerpc64
//This file checks a pointer load operation for null prt dereference.
int *p = 0;
int x;
x = *p + 2; // expected-warning {{null passed to a callee that requires a non-null argument}}
x = 2 + *p; // expected-warning {{null passed to a callee that requires a non-null argument}}
x = *p > 2; // expected-warning {{null passed to a callee that requires a non-null argument}}
x = 2 > *p; // expected-warning {{null passed to a callee that requires a non-null argument}}
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify
// XFAIL: powerpc64
//This file checks a pointer load operation for null prt dereference.
int *p = 0;;
double x;
x = double(*p); // expected-warning {{null passed to a callee that requires a non-null argument}}
void *q = 0;
int y;
y = int(*(int *)q); // expected-warning {{null passed to a callee that requires a non-null argument}}
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify
// XFAIL: powerpc64
//This file checks that the execution ends after a null prt dereference.
#include <stdlib.h>
int *p = (int*)0x1;
*p; exit(1); // expected-warning {{invalid memory pointer passed to a callee:}}
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify
// XFAIL: powerpc64
//This file checks an if statement for null prt dereference.
#include <stdlib.h>
int* p = 0;
if (*p) { exit(1); } // expected-warning {{null passed to a callee that requires a non-null argument}}
if (true) { *p; exit(1); } // expected-warning {{null passed to a callee that requires a non-null argument}}
if (false) {} else { *p; exit(1); } // expected-warning {{null passed to a callee that requires a non-null argument}}
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify
// XFAIL: powerpc64
//This file checks a dereference of an invalid memory address pointer..
int *p = (int*)0x1;
*p; // expected-warning {{invalid memory pointer passed to a callee:}}
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify
// XFAIL: powerpc64
//This file checks a pointer load operation for null prt dereference.
int *p;
int x;
x = *p; // expected-warning {{null passed to a callee that requires a non-null argument}}
extern "C" int printf(const char* fmt, ...);
class MyClass {
public:
  int a;
};
MyClass *m = 0;
if (m->a) {  printf("MyClass's a=%d", m->a);} // expected-warning {{null passed to a callee that requires a non-null argument}}
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify
// XFAIL: powerpc64
// This test verifies that we get nice warning if a method on null ptr object is
// called.
extern "C" int printf(const char* fmt, ...);
class MyClass {
private:
  int a;
public:
  MyClass() : a(1){}
  int getA(){return a;}
};
MyClass* my = 0;
my->getA() // expected-warning {{null passed to a callee that requires a non-null argument}}
struct AggregatedNull {
  MyClass* m;
  AggregatedNull() : m(0) {}
}
AggregatedNull agrNull;
agrNull.m->getA(); // expected-warning {{null passed to a callee that requires a non-null argument}}
#include "clang/AST/Type.h"
#include "clang/AST/DeclTemplate.h"
class Left {
  int m_LeftValue;
public:
  Left() : m_LeftValue(-1) {}
  int getLeftValue() { return m_LeftValue; }
  void setLeftValue(int v) { m_LeftValue = v; }
};
class Right {
  int m_RightValue;
public:
  Right() : m_RightValue(-2) {}
  int getRightValue() { return m_RightValue; }
   void setRightValue(int v) { m_RightValue = v; }
};
class Bottom: public Right, public Left {
   int m_BottomValue;
public:
   Bottom() : m_BottomValue(-3) {}
   int getBottomValue() { return m_BottomValue; }
   void setBottomValue(int v) { m_BottomValue = v; }
};
template <typename T> void TemplateFunc() {
   T *b = new T;
   b->setBottomValue(3);
   b->setRightValue(2);
   b->setLeftValue(1);
   if (b->getBottomValue() != 3)
      printf("fail: expected bottom value to be 3 but got %d\n",
             b->getBottomValue());
   if (b->getRightValue() != 2)
      printf("fail: expected right value to be 3 but got %d\n",
             b->getRightValue());
   if (b->getLeftValue() != 1)
      printf("fail: expected left value to be 3 but got %d\n",
             b->getLeftValue());
}
template <typename Q> void TemplateFuncUnrelated() {
   Bottom *b = new Bottom;
   b->setBottomValue(3);
   b->setRightValue(2);
   b->setLeftValue(1);
   if (b->getBottomValue() != 3)
      printf("fail: expected bottom value to be 3 but got %d\n",
             b->getBottomValue());
   if (b->getRightValue() != 2)
      printf("fail: expected right value to be 3 but got %d\n",
             b->getRightValue());
   if (b->getLeftValue() != 1)
      printf("fail: expected left value to be 3 but got %d\n",
             b->getLeftValue());
}
TemplateFunc<Bottom>();
TemplateFuncUnrelated<MyClass>();
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify | FileCheck %s
// XFAIL: powerpc64
//This file checks a call instruction. The called function has arguments with nonnull attribute.
extern "C" int printf(const char* fmt, ...);
.rawInput 1
extern "C" int cannotCallWithNull(int* p = 0);
extern "C" int cannotCallWithNull(int* p) __attribute__((nonnull(1))); //expected-note@1{{declared 'nonnull' here}}
extern "C" int cannotCallWithNull(int* p);
extern "C" int cannotCallWithNull(int* p);
.rawInput 0
extern "C" int cannotCallWithNull(int* p) {
  if (!p) // expected-warning {{nonnull parameter 'p' will evaluate to 'true' on first encounter}}
    printf("Must not be called with p=0.\n");
  return 1;
}
int *q = 0;
cannotCallWithNull(q); // expected-warning {{null passed to a callee that requires a non-null argument}}
//CHECK-NOT: Must not be called with p=0.
cannotCallWithNull(new int(4))
#include "clang/Sema/Sema.h"
#include "clang/Sema/Sema.h"
//CHECK: (int) 1
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify
// XFAIL: powerpc64
// We must be able to handle cases where, there is a custom function that has
// attributes non-null arguments and we should be able to add a non-null arg
// attribute to a say library function.
// Qualified functions.
extern "C" int printf(const char* fmt, ...);
namespace custom_namespace {
  void standaloneFunc(void* p, int q, float* s) __attribute__((nonnull(1,3))) { // expected-warning {{GCC does not allow 'nonnull' attribute in this position on a function definition}} //expected-note@2{{declared 'nonnull' here}} //expected-note@2{{declared 'nonnull' here}}
    if (!p || !s) // expected-warning {{nonnull parameter 'p' will evaluate to 'true' on first encounter}} // expected-warning {{nonnull parameter 's' will evaluate to 'true' on first encounter}}
      printf("Must not be called with 0 args.\n");
  }
  void standaloneFunc2(void* p, int q, float* s) __attribute__((nonnull(3))); //expected-note@6{{declared 'nonnull' here}}
  void standaloneFunc2(void* p, int q, float* s) {
    if (!s) // expected-warning {{nonnull parameter 's' will evaluate to 'true' on first encounter}}
      printf("Must not be called with 0 args.\n");
  }
}
// This can be a function defined in a library or somewhere else. Use printf for example
extern "C" int printf(const char* fmt, ...) __attribute__((nonnull(1)));
int* pNull = 0;
float* fNull = 0;
int* p = new int(1);
float* f = new float(0.0);
const char* charNull = 0;
custom_namespace::standaloneFunc(pNull, 1, fNull); // expected-warning {{null passed to a callee that requires a non-null argument}}
custom_namespace::standaloneFunc(pNull, 1, f); // expected-warning {{null passed to a callee that requires a non-null argument}}
custom_namespace::standaloneFunc(p, 1, fNull); // expected-warning {{null passed to a callee that requires a non-null argument}}
printf(charNull, ""); // expected-warning {{null passed to a callee that requires a non-null argument}}
int trampoline() {
  custom_namespace::standaloneFunc(pNull, 1, fNull);
  custom_namespace::standaloneFunc(pNull, 1, f);
  custom_namespace::standaloneFunc(p, 1, fNull);
  return 1;
}
//trampoline()
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify
// XFAIL: powerpc64
//This file checks a pointer store operation for null ptr dereference.
int *p;
*p = 6; // expected-warning {{null passed to a callee that requires a non-null argument}}
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify
// This test verifies that we do not produce a warning when
// - an iterator is derefed;
// - a lambda function is derefed.
#include <vector>
class MyClass;
std::vector<MyClass*> vect(3);
for (auto it = vect.begin(); it != vect.end(); ++it) MyClass* ptr = *it;
 // expected-no-diagnostics
auto lamb =[](int x){return x;};
*lamb;
 // expected-no-diagnostics
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: %mkdir "%T/subdir" || true
// RUN: %rm "%T/subdir/libtest%shlibext"
// RUN: clang -DCLING_EXPORT=%dllexport -shared %S/call_lib.c -o %T/subdir/libtest%shlibext
// RUN: cat %s | %cling -I %S -DENVVAR_LIB="\"%/T/subdir\"" -DENVVAR_INC="\"%/p/subdir\"" -Xclang -verify 2>&1 | FileCheck %s
extern "C" int cling_testlibrary_function();
#ifndef _WIN32
 #include <stdlib.h>
#else
 extern "C" int _putenv_s(const char *name, const char *value);
 #define setenv(n, v, o) _putenv_s(n,v)
#endif
::setenv("ENVVAR_INC", ENVVAR_INC, 1);
::setenv("ENVVAR_LIB", ENVVAR_LIB, 1);
#pragma cling add_include_path("$ENVVAR_INC")
#include "Include_header.h"
include_test()
#include "cling/Interpreter/LookupHelper.h"
#include "clang/AST/Type.h"
// CHECK: OK(int) 0
#pragma cling add_library_path("$ENVVAR_LIB")
#pragma cling load("libtest")
cling_testlibrary_function()
// CHECK: (int) 66
#pragma cling add_library_path("$NONEXISTINGVARNAME")
//expected-no-diagnostics
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: clang -shared -DCLING_EXPORT=%dllexport %S/call_lib.c -o%T/libcall_lib%shlibext
// RUN: cat %s | %cling -L %T -Xclang -verify 2>&1 | FileCheck %s
#pragma cling load("DoesNotExistPleaseRecover")
// expected-error@input_line_13:1{{'DoesNotExistPleaseRecover' file not found}}
#pragma cling load("libcall_lib")
extern "C" int cling_testlibrary_function();
cling_testlibrary_function()
// CHECK: (int) 66
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -I%S -Xclang -verify 2>&1 | FileCheck %s
// FIXME: When printing can be properly unloaded don't force it here
"BEGIN"
#include "cling/Interpreter/LookupHelper.h"
#include "clang/AST/ASTContext.h"
#include <cstdio>
#include <string>
using namespace std;
using namespace llvm;
void dumpDecl(const char* title, const clang::Decl* D) {
  printf("%s: 0x%lx\n", title, (unsigned long) D);
  std::string S;
  llvm::raw_string_ostream OS(S);
  dyn_cast<clang::NamedDecl>(D)
    ->getNameForDiagnostic(OS, D->getASTContext().getPrintingPolicy(),
                           /*Qualified=*/true);
  printf("%s name: %s\n", title, OS.str().c_str());
  D->print(cling::outs());
}
.rawInput
//
//  We need to fetch the global scope declaration,
//  otherwise known as the translation unit decl.
//
const cling::LookupHelper& lookup = gCling->getLookupHelper();
cling::LookupHelper::DiagSetting diags = cling::LookupHelper::WithDiagnostics;
const clang::Decl* G = lookup.findScope("", diags);
printf("G: 0x%lx\n", (unsigned long) G);
//CHECK: G: 0x{{[1-9a-f][0-9a-f]*$}}
//
//  Some tools for printing.
//
.rawInput 1
void G_f() { int x = 1; }
void G_a(int v) { int x = v; }
// CHECK: (const char [6]) "BEGIN"
#pragma cling load("P0.h", "P1.h","P2.h")
void G_b(int vi, double vd) { int x = vi; double y = vd; }
ValueA
void G_c(int vi, int vj) { int x = vi; int y = vj; }
void G_c(int vi, double vd) { int x = vi; double y = vd; }
template <class T> void G_d(T v) { T x = v; }
// Note: In CINT, looking up a class template specialization causes
//       instantiation, but looking up a function template specialization
//       does not, so we explicitly request the instantiations we are
//       going to lookup so they will be there to find.
template void G_d(int);
template void G_d(double);
namespace N {
// CHECK-NEXT: (const char *) "ValueA"
void H_f() { int x = 1; }
void H_a(int v) { int x = v; }
ValueB
void H_b(int vi, double vd) { int x = vi; double y = vd; }
void H_c(int vi, int vj) { int x = vi; int y = vj; }
void H_c(int vi, double vd) { int x = vi; double y = vd; }
template <class T> void H_d(T v) { T x = v; }
// Note: In CINT, looking up a class template specialization causes
//       instantiation, but looking up a function template specialization
//       does not, so we explicitly request the instantiations we are
//       going to lookup so they will be there to find.
template void H_d(int);
template void H_d(double);
} // namespace N
class B {
private:
   long m_B_i;
   double m_B_d;
   int* m_B_ip;
public:
   virtual ~B() { delete m_B_ip; m_B_ip = 0; }
   B() : m_B_i(0), m_B_d(0.0), m_B_ip(0) {}
   B(int vi, double vd) : m_B_i(vi), m_B_d(vd), m_B_ip(0) {}
   template <class T> B(T v) : m_B_i(0), m_B_d(0.0), m_B_ip(0) { m_B_i = (T) v; }
   template <class T> B(T* v) : m_B_i(0), m_B_d(0.0), m_B_ip(0) { m_B_i = (long) (T*) v; m_B_d = 1.0; }
   void B_f() { int x = 1; }
   void B_g(int v) { int x = v; }
   void B_h(int vi, double vd) { int x = vi; double y = vd; }
   void B_j(int vi, int vj) { int x = vi; int y = vj; }
   void B_j(int vi, double vd) { int x = vi; double y = vd; }
   template <class T> void B_k(T v) { T x = v; }
   void B_m(const int& v) { int y = v; }
   const long &B_n() const { return m_B_i; }
   long &B_n() { return m_B_i; }
   const long &B_o() const { return m_B_i; }
   long B_p(float) const { return 0; }
   int B_p(int) { return 0; }
   void* operator new(std::size_t sz) { return ::operator new(sz); }
   void* operator new(std::size_t sz, void* arena) { return arena; }
   void* operator new[](std::size_t sz) { return ::operator new[](sz); }
   void* operator new[](std::size_t sz, void* arena) { return arena; }
   void operator delete(void* vp) { ::operator delete(vp); }
   void operator delete(void* vp, void* arena) {}
   void operator delete[](void* vp) { ::operator delete[](vp); }
   void operator delete[](void* vp, void* arena) {}
   B& operator*() { return *this; }
   B operator+(B b) { return b; }
};
// CHECK-NEXT: (const char *) "ValueB"
ValueC
class A : public B {
private:
   int m_A_i;
   double m_A_d;
public:
   void A_f() { int x = 1; }
   void A_g(int v) { int x = v; }
   void A_h(int vi, double vd) { int x = vi; double y = vd; }
   void A_j(int vi, int vj) { int x = vi; int y = vj; }
   void A_j(int vi, double vd) { int x = vi; double y = vd; }
   template <class T> void A_k(T v) { T x = v; }
   void A_m(const int& v) { int y = v; }
   void* operator new(std::size_t sz) { return ::operator new(sz); }
   void* operator new(std::size_t sz, void* arena) { return arena; }
   void* operator new[](std::size_t sz) { return ::operator new[](sz); }
   void* operator new[](std::size_t sz, void* arena) { return arena; }
   void operator delete(void* vp) { ::operator delete(vp); }
   void operator delete(void* vp, void* arena) {}
   void operator delete[](void* vp) { ::operator delete[](vp); }
   void operator delete[](void* vp, void* arena) {}
   void A_n(B& b) { b.B_f(); }
   void A_n(const char *msg, int ndim = 0) { if (ndim) ++msg; }
};
// CHECK-NEXT: (const char *) "ValueC"
.undo
.undo
.undo
.undo
// FIXME: When print Transactions are properly parenteted remove these
.undo
.undo
.undo
ValueA // expected-error {{use of undeclared identifier 'ValueA'}}
B b_obj;
#pragma cling load "P0.h" "P1.h" "P2.h"
ValueA
B* b_ptr = &b_obj;
B* b_ary = new B[3];
// CHECK-NEXT: (const char *) "ValueA"
ValueB
// CHECK-NEXT: (const char *) "ValueB"
ValueC
char b_arena[sizeof(B)*10];
char b_ary_arena[256];
.rawInput 0
//
//  We need these class declarations.
//
// CHECK-NEXT: (const char *) "ValueC"
.undo
.undo
.undo
.undo
const clang::Decl* class_A = lookup.findScope("A", diags);
// FIXME: When print Transactions are properly parenteted remove these
.undo
.undo
.undo
ValueB // expected-error {{use of undeclared identifier 'ValueB'}}
#pragma cling(load, "P0.h", "P1.h", "P2.h")
ValueA
printf("class_A: 0x%lx\n", (unsigned long) class_A);
//CHECK: class_A: 0x{{[1-9a-f][0-9a-f]*$}}
const clang::Decl* class_B = lookup.findScope("B", diags);
// CHECK-NEXT: (const char *) "ValueA"
ValueB
// CHECK-NEXT: (const char *) "ValueB"
ValueC
printf("class_B: 0x%lx\n", (unsigned long) class_B);
//CHECK-NEXT: class_B: 0x{{[1-9a-f][0-9a-f]*$}}
//
// CHECK-NEXT: (const char *) "ValueC"
#pragma cling load "P0.h P1.h P2.h"
//  We need to fetch the namespace N declaration.
ValueD
//
const clang::Decl* namespace_N = lookup.findScope("N", diags);
// CHECK-NEXT: (const char *) "ValueD"
.q
printf("namespace_N: 0x%lx\n", (unsigned long) namespace_N);
//CHECK: namespace_N: 0x{{[1-9a-f][0-9a-f]*$}}
//
//  Test finding a global function taking no args.
//
const clang::FunctionDecl* G_f_args = lookup.findFunctionArgs(G, "G_f", "", diags);
const clang::FunctionDecl* G_f_proto = lookup.findFunctionProto(G, "G_f", "", diags);
printf("G_f_args: 0x%lx\n", (unsigned long) G_f_args);
//CHECK-NEXT: G_f_args: 0x{{[1-9a-f][0-9a-f]*$}}
G_f_args->print(cling::outs());
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify 2>&1 | FileCheck %s
extern "C" int printf(const char*,...);
#include "cling/Interpreter/Interpreter.h"
//CHECK-NEXT: void G_f() {
//CHECK-NEXT:     int x = 1;
//CHECK-NEXT: }
printf("G_f_proto: 0x%lx\n", (unsigned long) G_f_proto);
//CHECK: G_f_proto: 0x{{[1-9a-f][0-9a-f]*$}}
G_f_proto->print(cling::outs());
//CHECK-NEXT: void G_f() {
//CHECK-NEXT:     int x = 1;
//CHECK-NEXT: }
//
//  Test finding a global function taking a single int argument.
//
const clang::FunctionDecl* G_a_args = lookup.findFunctionArgs(G, "G_a", "0", diags);
const clang::FunctionDecl* G_a_proto = lookup.findFunctionProto(G, "G_a", "int", diags);
printf("G_a_args: 0x%lx\n", (unsigned long) G_a_args);
//CHECK: G_a_args: 0x{{[1-9a-f][0-9a-f]*$}}
G_a_args->print(cling::outs());
//CHECK-NEXT: void G_a(int v) {
//CHECK-NEXT:     int x = v;
//CHECK-NEXT: }
printf("G_a_proto: 0x%lx\n", (unsigned long) G_a_proto);
//CHECK: G_a_proto: 0x{{[1-9a-f][0-9a-f]*$}}
G_a_proto->print(cling::outs());
//CHECK-NEXT: void G_a(int v) {
//CHECK-NEXT:     int x = v;
//CHECK-NEXT: }
//
//  Test finding a global function taking an int and a double argument.
//
const clang::FunctionDecl* G_b_args = lookup.findFunctionArgs(G, "G_b", "0,0.0", diags);
const clang::FunctionDecl* G_b_proto = lookup.findFunctionProto(G, "G_b", "int,double", diags);
printf("G_b_args: 0x%lx\n", (unsigned long) G_b_args);
//CHECK: G_b_args: 0x{{[1-9a-f][0-9a-f]*$}}
G_b_args->print(cling::outs());
//CHECK-NEXT: void G_b(int vi, double vd) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     double y = vd;
//CHECK-NEXT: }
printf("G_b_proto: 0x%lx\n", (unsigned long) G_b_proto);
//CHECK: G_b_proto: 0x{{[1-9a-f][0-9a-f]*$}}
G_b_proto->print(cling::outs());
//CHECK-NEXT: void G_b(int vi, double vd) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     double y = vd;
//CHECK-NEXT: }
//
//  Test finding a global overloaded function.
//
const clang::FunctionDecl* G_c1_args = lookup.findFunctionArgs(G, "G_c", "0,0", diags);
const clang::FunctionDecl* G_c1_proto = lookup.findFunctionProto(G, "G_c", "int,int", diags);
printf("G_c1_args: 0x%lx\n", (unsigned long) G_c1_args);
//CHECK: G_c1_args: 0x{{[1-9a-f][0-9a-f]*$}}
G_c1_args->print(cling::outs());
//CHECK-NEXT: void G_c(int vi, int vj) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     int y = vj;
//CHECK-NEXT: }
printf("G_c1_proto: 0x%lx\n", (unsigned long) G_c1_proto);
//CHECK: G_c1_proto: 0x{{[1-9a-f][0-9a-f]*$}}
G_c1_proto->print(cling::outs());
//CHECK-NEXT: void G_c(int vi, int vj) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     int y = vj;
//CHECK-NEXT: }
const clang::FunctionDecl* G_c2_args = lookup.findFunctionArgs(G, "G_c", "0,0.0", diags);
const clang::FunctionDecl* G_c2_proto = lookup.findFunctionProto(G, "G_c", "int,double", diags);
printf("G_c2_args: 0x%lx\n", (unsigned long) G_c2_args);
//CHECK: G_c2_args: 0x{{[1-9a-f][0-9a-f]*$}}
G_c2_args->print(cling::outs());
//CHECK-NEXT: void G_c(int vi, double vd) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     double y = vd;
//CHECK-NEXT: }
printf("G_c2_proto: 0x%lx\n", (unsigned long) G_c2_proto);
//CHECK: G_c2_proto: 0x{{[1-9a-f][0-9a-f]*$}}
G_c2_proto->print(cling::outs());
//CHECK-NEXT: void G_c(int vi, double vd) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     double y = vd;
//CHECK-NEXT: }
//
//  Test finding simple global template instantiations.
//
const clang::FunctionDecl* G_d1_args = lookup.findFunctionArgs(G, "G_d<int>", "0", diags);
const clang::FunctionDecl* G_d1_proto = lookup.findFunctionProto(G, "G_d<int>", "int", diags);
printf("G_d1_args: 0x%lx\n", (unsigned long) G_d1_args);
//CHECK: G_d1_args: 0x{{[1-9a-f][0-9a-f]*$}}
G_d1_args->print(cling::outs());
//CHECK-NEXT: template<> void G_d<int>(int v) {
//CHECK-NEXT:     int x = v;
//CHECK-NEXT: }
printf("G_d1_proto: 0x%lx\n", (unsigned long) G_d1_proto);
//CHECK: G_d1_proto: 0x{{[1-9a-f][0-9a-f]*$}}
G_d1_proto->print(cling::outs());
//CHECK-NEXT: template<> void G_d<int>(int v) {
//CHECK-NEXT:     int x = v;
//CHECK-NEXT: }
const clang::FunctionDecl* G_d2_args = lookup.findFunctionArgs(G, "G_d<double>", "0.0", diags);
const clang::FunctionDecl* G_d2_proto = lookup.findFunctionProto(G, "G_d<double>", "double", diags);
printf("G_d2_args: 0x%lx\n", (unsigned long) G_d2_args);
//CHECK: G_d2_args: 0x{{[1-9a-f][0-9a-f]*$}}
G_d2_args->print(cling::outs());
//CHECK-NEXT: template<> void G_d<double>(double v) {
//CHECK-NEXT:     double x = v;
//CHECK-NEXT: }
printf("G_d2_proto: 0x%lx\n", (unsigned long) G_d2_proto);
//CHECK: G_d2_proto: 0x{{[1-9a-f][0-9a-f]*$}}
G_d2_proto->print(cling::outs());
//CHECK-NEXT: template<> void G_d<double>(double v) {
//CHECK-NEXT:     double x = v;
//CHECK-NEXT: }
//
//  Test finding a namespace function taking no args.
//
const clang::FunctionDecl* H_f_args = lookup.findFunctionArgs(namespace_N, "H_f", "", diags);
const clang::FunctionDecl* H_f_proto = lookup.findFunctionProto(namespace_N, "H_f", "", diags);
#include "cling/MetaProcessor/MetaProcessor.h"
printf("H_f_args: 0x%lx\n", (unsigned long) H_f_args);
//CHECK: H_f_args: 0x{{[1-9a-f][0-9a-f]*$}}
H_f_args->print(cling::outs());
//CHECK-NEXT: void H_f() {
//CHECK-NEXT:     int x = 1;
//CHECK-NEXT: }
printf("H_f_proto: 0x%lx\n", (unsigned long) H_f_proto);
//CHECK: H_f_proto: 0x{{[1-9a-f][0-9a-f]*$}}
H_f_proto->print(cling::outs());
//CHECK-NEXT: void H_f() {
//CHECK-NEXT:     int x = 1;
//CHECK-NEXT: }
//
//  Test finding a namespace function taking a single int argument.
//
const clang::FunctionDecl* H_a_args = lookup.findFunctionArgs(namespace_N, "H_a", "0", diags);
const clang::FunctionDecl* H_a_proto = lookup.findFunctionProto(namespace_N, "H_a", "int", diags);
printf("H_a_args: 0x%lx\n", (unsigned long) H_a_args);
//CHECK: H_a_args: 0x{{[1-9a-f][0-9a-f]*$}}
H_a_args->print(cling::outs());
//CHECK-NEXT: void H_a(int v) {
//CHECK-NEXT:     int x = v;
//CHECK-NEXT: }
printf("H_a_proto: 0x%lx\n", (unsigned long) H_a_proto);
//CHECK: H_a_proto: 0x{{[1-9a-f][0-9a-f]*$}}
H_a_proto->print(cling::outs());
//CHECK-NEXT: void H_a(int v) {
//CHECK-NEXT:     int x = v;
//CHECK-NEXT: }
//
//  Test finding a namespace function taking an int and a double argument.
//
const clang::FunctionDecl* H_b_args = lookup.findFunctionArgs(namespace_N, "H_b", "0,0.0", diags);
const clang::FunctionDecl* H_b_proto = lookup.findFunctionProto(namespace_N, "H_b", "int,double", diags);
printf("H_b_args: 0x%lx\n", (unsigned long) H_b_args);
//CHECK: H_b_args: 0x{{[1-9a-f][0-9a-f]*$}}
H_b_args->print(cling::outs());
//CHECK-NEXT: void H_b(int vi, double vd) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     double y = vd;
//CHECK-NEXT: }
printf("H_b_proto: 0x%lx\n", (unsigned long) H_b_proto);
//CHECK: H_b_proto: 0x{{[1-9a-f][0-9a-f]*$}}
H_b_proto->print(cling::outs());
//CHECK-NEXT: void H_b(int vi, double vd) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     double y = vd;
//CHECK-NEXT: }
//
//  Test finding a namespace overloaded function.
//
const clang::FunctionDecl* H_c1_args = lookup.findFunctionArgs(namespace_N, "H_c", "0,0", diags);
const clang::FunctionDecl* H_c1_proto = lookup.findFunctionProto(namespace_N, "H_c", "int,int", diags);
printf("H_c1_args: 0x%lx\n", (unsigned long) H_c1_args);
//CHECK: H_c1_args: 0x{{[1-9a-f][0-9a-f]*$}}
H_c1_args->print(cling::outs());
//CHECK-NEXT: void H_c(int vi, int vj) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     int y = vj;
//CHECK-NEXT: }
printf("H_c1_proto: 0x%lx\n", (unsigned long) H_c1_proto);
//CHECK: H_c1_proto: 0x{{[1-9a-f][0-9a-f]*$}}
H_c1_proto->print(cling::outs());
//CHECK-NEXT: void H_c(int vi, int vj) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     int y = vj;
//CHECK-NEXT: }
const clang::FunctionDecl* H_c2_args = lookup.findFunctionArgs(namespace_N, "H_c", "0,0.0", diags);
// #include "cling/Utils/Output.h"
//Declare something in the parent interpreter
int foo(){ return 42; }
// OR
//gCling->declare("void foo(){ cling::outs() << \"foo(void)\\n\"; }");
const char* argV[1] = {"cling"};
// Declare something in the child interpreter, then execute it from the child
// interpreter, and check if function overload resolution works.
// All needs to happen in one parent statement, or else the contract
// that the parent is not modified during the child's lifetime
// is violated.
{
  cling::Interpreter ChildInterp(*gCling, 1, argV);
  ChildInterp.declare("void foo(int i){ printf(\"foo(int) = %d\\n\", i); }\n");
  ChildInterp.echo("foo()"); //CHECK: (int) 42
  ChildInterp.echo("foo(1)"); //CHECK: foo(int) = 1
}
const clang::FunctionDecl* H_c2_proto = lookup.findFunctionProto(namespace_N, "H_c", "int,double", diags);
printf("H_c2_args: 0x%lx\n", (unsigned long) H_c2_args);
//CHECK: H_c2_args: 0x{{[1-9a-f][0-9a-f]*$}}
H_c2_args->print(cling::outs());
//CHECK-NEXT: void H_c(int vi, double vd) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     double y = vd;
//CHECK-NEXT: }
printf("H_c2_proto: 0x%lx\n", (unsigned long) H_c2_proto);
//CHECK: H_c2_proto: 0x{{[1-9a-f][0-9a-f]*$}}
H_c2_proto->print(cling::outs());
//CHECK-NEXT: void H_c(int vi, double vd) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     double y = vd;
//CHECK-NEXT: }
//
//  Test finding simple namespace template instantiations.
//
const clang::FunctionDecl* H_d1_args = lookup.findFunctionArgs(namespace_N, "H_d<int>", "0", diags);
.q
const clang::FunctionDecl* H_d1_proto = lookup.findFunctionProto(namespace_N, "H_d<int>", "int", diags);
printf("H_d1_args: 0x%lx\n", (unsigned long) H_d1_args);
//CHECK: H_d1_args: 0x{{[1-9a-f][0-9a-f]*$}}
H_d1_args->print(cling::outs());
//CHECK-NEXT: template<> void H_d<int>(int v) {
//CHECK-NEXT:     int x = v;
//CHECK-NEXT: }
printf("H_d1_proto: 0x%lx\n", (unsigned long) H_d1_proto);
//CHECK: H_d1_proto: 0x{{[1-9a-f][0-9a-f]*$}}
H_d1_proto->print(cling::outs());
//CHECK-NEXT: template<> void H_d<int>(int v) {
//CHECK-NEXT:     int x = v;
//CHECK-NEXT: }
const clang::FunctionDecl* H_d2_args = lookup.findFunctionArgs(namespace_N, "H_d<double>", "0.0", diags);
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify 2>&1 | FileCheck %s
// Test blockComments
(/*
   1
   2
   3 */
  8
  // single line 1
  /* single line 2*/
)
const clang::FunctionDecl* H_d2_proto = lookup.findFunctionProto(namespace_N, "H_d<double>", "double", diags);
printf("H_d2_args: 0x%lx\n", (unsigned long) H_d2_args);
//CHECK: H_d2_args: 0x{{[1-9a-f][0-9a-f]*$}}
H_d2_args->print(cling::outs());
//CHECK-NEXT: template<> void H_d<double>(double v) {
//CHECK-NEXT:     double x = v;
//CHECK-NEXT: }
printf("H_d2_proto: 0x%lx\n", (unsigned long) H_d2_proto);
//CHECK: H_d2_proto: 0x{{[1-9a-f][0-9a-f]*$}}
H_d2_proto->print(cling::outs());
//CHECK-NEXT: template<> void H_d<double>(double v) {
//CHECK-NEXT:     double x = v;
//CHECK-NEXT: }
//
//  Test finding a member function taking no args.
//
const clang::FunctionDecl* func_A_f_args = lookup.findFunctionArgs(class_A, "A_f", "", diags);
const clang::FunctionDecl* func_A_f_proto = lookup.findFunctionProto(class_A, "A_f", "", diags);
printf("func_A_f_args: 0x%lx\n", (unsigned long) func_A_f_args);
//CHECK: func_A_f_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_f_args->print(cling::outs());
//CHECK-NEXT: void A_f() {
//CHECK-NEXT:     int x = 1;
//CHECK-NEXT: }
printf("func_A_f_proto: 0x%lx\n", (unsigned long) func_A_f_proto);
//CHECK: func_A_f_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_f_proto->print(cling::outs());
//CHECK-NEXT: void A_f() {
//CHECK-NEXT:     int x = 1;
//CHECK-NEXT: }
//
//  Test finding a member function taking an int arg.
//
const clang::FunctionDecl* func_A_g_args = lookup.findFunctionArgs(class_A, "A_g", "0", diags);
const clang::FunctionDecl* func_A_g_proto = lookup.findFunctionProto(class_A, "A_g", "int", diags);
printf("func_A_g_args: 0x%lx\n", (unsigned long) func_A_g_args);
//CHECK: func_A_g_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_g_args->print(cling::outs());
//CHECK-NEXT: void A_g(int v) {
//CHECK-NEXT:     int x = v;
//CHECK-NEXT: }
printf("func_A_g_proto: 0x%lx\n", (unsigned long) func_A_g_proto);
//CHECK: func_A_g_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_g_proto->print(cling::outs());
//CHECK-NEXT: void A_g(int v) {
//CHECK-NEXT:     int x = v;
//CHECK-NEXT: }
//
//  Test finding a member function taking an int and a double argument.
//
const clang::FunctionDecl* func_A_h_args = lookup.findFunctionArgs(class_A, "A_h", "0,0.0", diags);
const clang::FunctionDecl* func_A_h_proto = lookup.findFunctionProto(class_A, "A_h", "int,double", diags);
printf("func_A_h_args: 0x%lx\n", (unsigned long) func_A_h_args);
//CHECK: func_A_h_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_h_args->print(cling::outs());
//CHECK-NEXT: void A_h(int vi, double vd) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     double y = vd;
//CHECK-NEXT: }
printf("func_A_h_proto: 0x%lx\n", (unsigned long) func_A_h_proto);
using namespace std;
//
//  Test Data.
//
.rawInput 1
class A {};
namespace N {
class B {};
namespace M {
class C {};
} // namespace M
} // namespace N
typedef int my_int;
using clang::QualType;
using cling::LookupHelper;
.rawInput 0
const LookupHelper& lookup = gCling->getLookupHelper();
//CHECK: func_A_h_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_h_proto->print(cling::outs());
//CHECK-NEXT: void A_h(int vi, double vd) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     double y = vd;
//CHECK-NEXT: }
//
//  Test finding an overloaded member function.
//
const clang::FunctionDecl* func_A_j1_args = lookup.findFunctionArgs(class_A, "A_j", "0,0", diags);
QualType cl_A = lookup.findType("A", LookupHelper::WithDiagnostics);
const clang::FunctionDecl* func_A_j1_proto = lookup.findFunctionProto(class_A, "A_j", "int,int", diags);
cl_A.getAsString().c_str()
printf("func_A_j1_args: 0x%lx\n", (unsigned long) func_A_j1_args);
//CHECK: func_A_j1_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_j1_args->print(cling::outs());
//CHECK-NEXT: void A_j(int vi, int vj) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     int y = vj;
//CHECK-NEXT: }
printf("func_A_j1_proto: 0x%lx\n", (unsigned long) func_A_j1_proto);
//CHECK: func_A_j1_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_j1_proto->print(cling::outs());
//CHECK-NEXT: void A_j(int vi, int vj) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     int y = vj;
//CHECK-NEXT: }
const clang::FunctionDecl* func_A_j2_args = lookup.findFunctionArgs(class_A, "A_j", "0,0.0", diags);
const clang::FunctionDecl* func_A_j2_proto = lookup.findFunctionProto(class_A, "A_j", "int,double", diags);
printf("func_A_j2_args: 0x%lx\n", (unsigned long) func_A_j2_args);
//CHECK: func_A_j2_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_j2_args->print(cling::outs());
//CHECK-NEXT: void A_j(int vi, double vd) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     double y = vd;
//CHECK-NEXT: }
printf("func_A_j2_proto: 0x%lx\n", (unsigned long) func_A_j2_proto);
//CHECK: func_A_j2_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_j2_proto->print(cling::outs());
//CHECK: ({{[^)]+}}) "class A"
QualType cl_B_in_N = lookup.findType("N::B", LookupHelper::WithDiagnostics);
//CHECK-NEXT: void A_j(int vi, double vd) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     double y = vd;
//CHECK-NEXT: }
//
//  Test finding simple member function template instantiations.
//
const clang::FunctionDecl* func_A_k1_args = lookup.findFunctionArgs(class_A, "A_k<int>", "0", diags);
cl_B_in_N.getAsString().c_str()
const clang::FunctionDecl* func_A_k1_proto = lookup.findFunctionProto(class_A, "A_k<int>", "int", diags);
printf("func_A_k1_args: 0x%lx\n", (unsigned long) func_A_k1_args);
//CHECK: func_A_k1_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_k1_args->print(cling::outs());
//CHECK-NEXT: template<> void A_k<int>(int v) {
//CHECK-NEXT:     int x = v;
//CHECK-NEXT: }
printf("func_A_k1_proto: 0x%lx\n", (unsigned long) func_A_k1_proto);
//CHECK: func_A_k1_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_k1_proto->print(cling::outs());
//CHECK-NEXT: template<> void A_k<int>(int v) {
//CHECK-NEXT:     int x = v;
//CHECK-NEXT: }
const clang::FunctionDecl* func_A_k2_args = lookup.findFunctionArgs(class_A, "A_k<double>", "0.0", diags);
const clang::FunctionDecl* func_A_k2_proto = lookup.findFunctionProto(class_A, "A_k<double>", "double", diags);
//CHECK: ({{[^)]+}}) "class N::B"
QualType cl_C_in_M = lookup.findType("N::M::C", LookupHelper::WithDiagnostics);
cl_C_in_M.getAsString().c_str()
printf("func_A_k2_args: 0x%lx\n", (unsigned long) func_A_k2_args);
//CHECK: func_A_k2_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_k2_args->print(cling::outs());
//CHECK-NEXT: template<> void A_k<double>(double v) {
//CHECK-NEXT:     double x = v;
//CHECK-NEXT: }
printf("func_A_k2_proto: 0x%lx\n", (unsigned long) func_A_k2_proto);
//CHECK: func_A_k2_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_k2_proto->print(cling::outs());
//CHECK-NEXT: template<> void A_k<double>(double v) {
//CHECK-NEXT:     double x = v;
//CHECK-NEXT: }
//
//  Test finding a member function taking a const int reference arg.
//
const clang::FunctionDecl* func_A_m_args = lookup.findFunctionArgs(class_A, "A_m", "0", diags);
const clang::FunctionDecl* func_A_m_proto = lookup.findFunctionProto(class_A, "A_m", "const int&", diags);
printf("func_A_m_args: 0x%lx\n", (unsigned long) func_A_m_args);
//CHECK: func_A_m_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_m_args->print(cling::outs());
//CHECK: ({{[^)]+}}) "class N::M::C"
QualType builtin_int = lookup.findType("int", LookupHelper::WithDiagnostics);
//CHECK-NEXT: void A_m(const int &v) {
//CHECK-NEXT:     int y = v;
//CHECK-NEXT: }
printf("func_A_m_proto: 0x%lx\n", (unsigned long) func_A_m_proto);
//CHECK: func_A_m_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_m_proto->print(cling::outs());
builtin_int.getAsString().c_str()
//CHECK-NEXT: void A_m(const int &v) {
//CHECK-NEXT:     int y = v;
//CHECK-NEXT: }
//
//  Test finding a member function taking an obj reference arg.
//
const clang::FunctionDecl* func_A_n_args = lookup.findFunctionArgs(class_A, "A_n", "*(new B())", diags);
const clang::FunctionDecl* func_A_n_proto = lookup.findFunctionProto(class_A, "A_n", "B&", diags);
printf("func_A_n_args: 0x%lx\n", (unsigned long) func_A_n_args);
//CHECK: func_A_n_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_n_args->print(cling::outs());
//CHECK-NEXT: void A_n(B &b) {
//CHECK-NEXT:   b.B_f();
//CHECK-NEXT: }
printf("func_A_n_proto: 0x%lx\n", (unsigned long) func_A_n_proto);
//CHECK: func_A_n_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_n_proto->print(cling::outs());
//CHECK-NEXT: void A_n(B &b) {
//CHECK-NEXT:   b.B_f();
//CHECK-NEXT: }
//
//  Test finding a member function taking with a default argument.
//
const clang::FunctionDecl* func_A_n2_args = lookup.findFunctionArgs(class_A, "A_n", "\"\"", diags);
//CHECK: ({{[^)]+}}) "int"
QualType typedef_my_int = lookup.findType("my_int", LookupHelper::WithDiagnostics);
typedef_my_int.getAsString().c_str()
const clang::FunctionDecl* func_A_n2_proto = lookup.findFunctionProto(class_A, "A_n", "const char *", diags);
printf("func_A_n2_args: 0x%lx\n", (unsigned long) func_A_n2_args);
//CHECK: func_A_n2_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_n2_args->print(cling::outs());
//CHECK-NEXT: void A_n(const char *msg, int ndim = 0) {
//CHECK-NEXT:    if (ndim)
//CHECK-NEXT:       ++msg;
//CHECK-NEXT: }
printf("func_A_n2_proto: 0x%lx\n", (unsigned long) func_A_n2_proto);
//CHECK: func_A_n2_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_A_n2_proto->print(cling::outs());
//CHECK-NEXT: void A_n(const char *msg, int ndim = 0) {
//CHECK-NEXT:    if (ndim)
//CHECK-NEXT:       ++msg;
//CHECK-NEXT: }
//
//  Test finding a member function taking no args in a base class.
//
const clang::FunctionDecl* func_B_F_args = lookup.findFunctionArgs(class_A, "B_f", "", diags);
const clang::FunctionDecl* func_B_F_proto = lookup.findFunctionProto(class_A, "B_f", "", diags);
//CHECK: ({{[^)]+}}) "my_int"
.q
printf("func_B_F_args: 0x%lx\n", (unsigned long) func_B_F_args);
//CHECK: func_B_F_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_F_args->print(cling::outs());
//CHECK-NEXT: void B_f() {
//CHECK-NEXT:     int x = 1;
//CHECK-NEXT: }
printf("func_B_F_proto: 0x%lx\n", (unsigned long) func_B_F_proto);
//CHECK: func_B_F_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_F_proto->print(cling::outs());
//CHECK-NEXT: void B_f() {
//CHECK-NEXT:     int x = 1;
//CHECK-NEXT: }
//
//  Test finding a member function taking an int arg in a base class.
//
const clang::FunctionDecl* func_B_G_args = lookup.findFunctionArgs(class_A, "B_g", "0", diags);
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify
// Check that decl extraction doesn't complain about unrelated decls
.rawInput 1
namespace UNRELATED { void name(); }
using namespace UNRELATED;
.rawInput 0
int name = 12;
// Check that decl extraction doesn't complain about unrelated decls
.rawInput 1
namespace N { void injected(); } // expected-note {{target of using declaration}}
const clang::FunctionDecl* func_B_G_proto = lookup.findFunctionProto(class_A, "B_g", "int", diags);
using N::injected; // expected-note {{using declaration}}
.rawInput 0
int injected = 13; // expected-error {{declaration conflicts with target of using declaration already in scope}}
// Check that decl extraction does complain about clashing decls
extern "C" double likeSin(double); // expected-note {{previous definition is here}}
int likeSin = 14; // expected-error {{redefinition of 'likeSin' as different kind of symbol}}
// Test a weakness in the declaration extraction of types (ROOT-5248).
class MyClass; // this type...
extern MyClass* my;
class MyClass { // and that type used to not be redecls
public:
  MyClass* getMyClass() {
    return 0;
  }
} cl;
MyClass* my = cl.getMyClass();
.q
printf("func_B_G_args: 0x%lx\n", (unsigned long) func_B_G_args);
//CHECK: func_B_G_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_G_args->print(cling::outs());
//CHECK-NEXT: void B_g(int v) {
//CHECK-NEXT:     int x = v;
//CHECK-NEXT: }
printf("func_B_G_proto: 0x%lx\n", (unsigned long) func_B_G_proto);
//CHECK: func_B_G_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_G_proto->print(cling::outs());
//CHECK-NEXT: void B_g(int v) {
//CHECK-NEXT:     int x = v;
//CHECK-NEXT: }
//
//  Test finding a member function taking an int and a double argument
//  in a base class.
//
const clang::FunctionDecl* func_B_h_args = lookup.findFunctionArgs(class_A, "B_h", "0,0.0", diags);
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify 2>&1 | FileCheck %s
// Tests continuation of a line with , or \
// Be careful saving this file: some editors strip the trailing spaces at bottom
extern "C" int printf(const char*, ...);
int Ac = 15,
    Bc = 25,
    Cc = 35;
Ac
const clang::FunctionDecl* func_B_h_proto = lookup.findFunctionProto(class_A, "B_h", "int,double", diags);
printf("func_B_h_args: 0x%lx\n", (unsigned long) func_B_h_args);
//CHECK: func_B_h_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_h_args->print(cling::outs());
//CHECK-NEXT: void B_h(int vi, double vd) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     double y = vd;
//CHECK-NEXT: }
printf("func_B_h_proto: 0x%lx\n", (unsigned long) func_B_h_proto);
//CHECK: func_B_h_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_h_proto->print(cling::outs());
//CHECK-NEXT: void B_h(int vi, double vd) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     double y = vd;
//CHECK-NEXT: }
//
//  Test finding a member function taking an int and a double argument
//  in a base class using the preparse types.
//
llvm::SmallVector<clang::QualType, 4> types;
// CHECK: (int) 8
// Check nested indentation works
/*
 {
  (
   [
   ]
  )
 }
*/
// Check nested indentation doesn't error on mismatched closures
/*
  {
    [
      (
      }
    )
  ]
*/
( 5
  /*
   + 1
   + 2
   + 3 */
  + 4
  // single line 1
  /* single line 2*/
)
// CHECK-NEXT: (int) 9
/*
  This should work
  // As should this // */
/*
  This will warn
  // /* */ // expected-warning {{within block comment}}
.rawInput 1
*/ // expected-error {{expected unqualified-id}}
.rawInput 0
// This is a side effect of wrapping, expression is compiled as */; so 2 errors
*/ // expected-error@2 {{expected expression}} expected-error@3 {{expected expression}}
/* // /* */// expected-warning {{within block comment}}
/* // /* *// */
// expected-warning@input_line_27:2 {{within block comment}}
// expected-error@input_line_27:2 {{expected expression}}
// expected-error@input_line_27:2 {{expected expression}}
// expected-error@input_line_27:3 {{expected expression}}
/* //  *  // */
// Check preprocessor blocked out
/*
#if 1
#else er
#we not gonna terminate this
  #include "stop messing around.h"
#finished
*/
// Check meta-commands are blocked out
/*
  .L SomeStuff
  .x some more
  .q
*/
( 5
  /*
   + 10
   + 20 */
  /*
    + 30
  */
  + 4
  // single line 1
  + 10
  /* single line 2*/
  /* ) */
)
// CHECK-NEXT: (int) 19
/* 8 + */ 9 /* = 20 */
types.push_back(lookup.findType("int", diags));
// CHECK-NEXT: (int) 9
/*
// Check inline asteriks
*******************************************************
*    Row   * Instance *   fEvents.fEventNo * fShowers *
*******************************************************
*        0 *        0 *                  0 *       10 *
*        0 *        1 *                  0 *       20 *
*        0 *        2 *                  2 *       30 *
*******************************************************
*/
// Check inline slashes
/*
A/B
*/
32
// CHECK-NEXT: (int) 32
/* Check inline asteriks ****/
62
// CHECK-NEXT: (int) 62
// ROOT-8529
12/3*4
// CHECK-NEXT: (int) 16
// ROOT-7354
/*
    * :(
*/
42
// CHECK-NEXT: (int) 42
(1/1)*1
// CHECK-NEXT: (int) 1
int A = 5, B = 25, *Ap = &A;
B / *Ap
types.push_back(lookup.findType("float", diags));
// CHECK-NEXT: (int) 5
.q
const clang::FunctionDecl* func_B_h_proto_type = lookup.findFunctionProto(class_A, "B_h", types, diags);
types.pop_back();
types.push_back(lookup.findType("double", diags));
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify 2>&1 | FileCheck %s
// Test dontWrapDefinitions
extern "C" int printf(const char*,...);
class TestDecl { public: int methodDefLater(); } t
const clang::FunctionDecl* func_B_h_match_proto_type = lookup.matchFunctionProto(class_A, "B_h", types, diags, false);
printf("func_B_h_proto_type: 0x%lx\n", (unsigned long) func_B_h_proto_type);
//CHECK: func_B_h_proto_type: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_h_proto_type->print(cling::outs());
//CHECK-NEXT: void B_h(int vi, double vd) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     double y = vd;
//CHECK-NEXT: }
printf("func_B_h_match_proto_type: 0x%lx\n", (unsigned long) func_B_h_match_proto_type);
//CHECK: func_B_h_match_proto_type: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_h_match_proto_type->print(cling::outs());
//CHECK-NEXT: void B_h(int vi, double vd) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     double y = vd;
//CHECK-NEXT: }
//
//  Test finding an overloaded member function in a base class.
//
const clang::FunctionDecl* func_B_j1_args = lookup.findFunctionArgs(class_A, "B_j", "0,0", diags);
const clang::FunctionDecl* func_B_j1_proto = lookup.findFunctionProto(class_A, "B_j", "int,int", diags);
printf("func_B_j1_args: 0x%lx\n", (unsigned long) func_B_j1_args);
//CHECK: func_B_j1_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_j1_args->print(cling::outs());
//CHECK-NEXT: void B_j(int vi, int vj) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     int y = vj;
//CHECK-NEXT: }
printf("func_B_j1_proto: 0x%lx\n", (unsigned long) func_B_j1_proto);
//CHECK: func_B_j1_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_j1_proto->print(cling::outs());
//CHECK-NEXT: void B_j(int vi, int vj) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     int y = vj;
//CHECK-NEXT: }
const clang::FunctionDecl* func_B_j2_args = lookup.findFunctionArgs(class_A, "B_j", "0,0.0", diags);
const clang::FunctionDecl* func_B_j2_proto = lookup.findFunctionProto(class_A, "B_j", "int,double", diags);
printf("func_B_j2_args: 0x%lx\n", (unsigned long) func_B_j2_args);
//CHECK: func_B_j2_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_j2_args->print(cling::outs());
//CHECK-NEXT: void B_j(int vi, double vd) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     double y = vd;
//CHECK-NEXT: }
printf("func_B_j2_proto: 0x%lx\n", (unsigned long) func_B_j2_proto);
//CHECK: func_B_j2_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_j2_proto->print(cling::outs());
//CHECK-NEXT: void B_j(int vi, double vd) {
//CHECK-NEXT:     int x = vi;
//CHECK-NEXT:     double y = vd;
//CHECK-NEXT: }
//
//  Test finding simple member function template instantiations in a base class.
//
const clang::FunctionDecl* func_B_k1_args = lookup.findFunctionArgs(class_A, "B_k<int>", "0", diags);
const clang::FunctionDecl* func_B_k1_proto = lookup.findFunctionProto(class_A, "B_k<int>", "int", diags);
printf("func_B_k1_args: 0x%lx\n", (unsigned long) func_B_k1_args);
//CHECK: func_B_k1_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_k1_args->print(cling::outs());
//CHECK-NEXT: template<> void B_k<int>(int v) {
//CHECK-NEXT:     int x = v;
//CHECK-NEXT: }
printf("func_B_k1_proto: 0x%lx\n", (unsigned long) func_B_k1_proto);
//CHECK: func_B_k1_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_k1_proto->print(cling::outs());
//CHECK-NEXT: template<> void B_k<int>(int v) {
//CHECK-NEXT:     int x = v;
//CHECK-NEXT: }
const clang::FunctionDecl* func_B_k2_args = lookup.findFunctionArgs(class_A, "B_k<double>", "0.0", diags);
const clang::FunctionDecl* func_B_k2_proto = lookup.findFunctionProto(class_A, "B_k<double>", "double", diags);
printf("func_B_k2_args: 0x%lx\n", (unsigned long) func_B_k2_args);
//CHECK: func_B_k2_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_k2_args->print(cling::outs());
//CHECK-NEXT: template<> void B_k<double>(double v) {
//CHECK-NEXT:     double x = v;
//CHECK-NEXT: }
printf("func_B_k2_proto: 0x%lx\n", (unsigned long) func_B_k2_proto);
//CHECK: func_B_k2_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_k2_proto->print(cling::outs());
//CHECK-NEXT: template<> void B_k<double>(double v) {
//CHECK-NEXT:     double x = v;
//CHECK-NEXT: }
//
//  Test finding a member function taking a const int reference arg in a base class.
//
const clang::FunctionDecl* func_B_m_args = lookup.findFunctionArgs(class_A, "B_m", "0", diags);
const clang::FunctionDecl* func_B_m_proto = lookup.findFunctionProto(class_A, "B_m", "const int&", diags);
printf("func_B_m_args: 0x%lx\n", (unsigned long) func_B_m_args);
//CHECK: func_B_m_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_m_args->print(cling::outs());
//CHECK-NEXT: void B_m(const int &v) {
//CHECK-NEXT:     int y = v;
//CHECK-NEXT: }
printf("func_B_m_proto: 0x%lx\n", (unsigned long) func_B_m_proto);
//CHECK: func_B_m_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_m_proto->print(cling::outs());
//CHECK-NEXT: void B_m(const int &v) {
//CHECK-NEXT:     int y = v;
//CHECK-NEXT: }
//
//  Test finding a member function that are const or not
//
const clang::FunctionDecl* func_B_n_args = lookup.findFunctionArgs(class_A, "B_n", "", diags, false);
const clang::FunctionDecl* func_B_n_proto = lookup.findFunctionProto(class_A, "B_n", "", diags, false);
printf("func_B_n_args: 0x%lx\n", (unsigned long) func_B_n_args);
//CHECK: func_B_n_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_n_args->print(cling::outs());
//CHECK-NEXT: long &B_n() {
//CHECK-NEXT:     return this->m_B_i;
//CHECK-NEXT: }
printf("func_B_n_proto: 0x%lx\n", (unsigned long) func_B_n_proto);
//CHECK: func_B_n_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_n_proto->print(cling::outs());
//CHECK-NEXT: long &B_n() {
//CHECK-NEXT:     return this->m_B_i;
//CHECK-NEXT: }
const clang::FunctionDecl* func_const_B_n_args = lookup.findFunctionArgs(class_A, "B_n", "", diags, true);
const clang::FunctionDecl* func_const_B_n_proto = lookup.findFunctionProto(class_A, "B_n", "", diags, true);
printf("func_const_B_n_args: 0x%lx\n", (unsigned long) func_const_B_n_args);
//CHECK: func_const_B_n_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_const_B_n_args->print(cling::outs());
//CHECK-NEXT: const long &B_n() const {
//CHECK-NEXT:     return this->m_B_i;
//CHECK-NEXT: }
printf("func_const_B_n_proto: 0x%lx\n", (unsigned long) func_const_B_n_proto);
//CHECK: func_const_B_n_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_const_B_n_proto->print(cling::outs());
//CHECK-NEXT: const long &B_n() const {
//CHECK-NEXT:     return this->m_B_i;
//CHECK-NEXT: }
const clang::FunctionDecl* func_const_B_m_proto = lookup.findFunctionProto(class_A, "B_m", "const int&", diags, true);
const clang::FunctionDecl* func_const_B_o_proto = lookup.findFunctionProto(class_A, "B_o", "", diags, true);
printf("func_const_B_m_proto: 0x%lx\n", (unsigned long) func_const_B_m_proto);
//CHECK: func_const_B_m_proto: 0x0
printf("func_const_B_o_proto: 0x%lx\n", (unsigned long) func_const_B_o_proto);
//CHECK: func_const_B_o_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_const_B_o_proto->print(cling::outs());
//CHECK-NEXT: const long &B_o() const {
//CHECK-NEXT:     return this->m_B_i;
//CHECK-NEXT: }
// Test exact matches
const clang::FunctionDecl* func_const_B_p_proto = lookup.findFunctionProto(class_A, "B_p", "double", diags, true);
printf("func_const_B_p_proto 1: 0x%lx\n", (unsigned long) func_const_B_p_proto);
//CHECK: func_const_B_p_proto 1: 0x{{[1-9a-f][0-9a-f]*$}}
func_const_B_p_proto->print(cling::outs());
//CHECK-NEXT: long B_p(float) const {
//CHECK-NEXT:     return 0;
//CHECK-NEXT: }
func_const_B_p_proto = lookup.matchFunctionProto(class_A, "B_p", "double", diags, true);
printf("func_const_B_p_proto 2: 0x%lx\n", (unsigned long) func_const_B_p_proto);
//CHECK: func_const_B_p_proto 2: 0x0
func_const_B_p_proto = lookup.matchFunctionProto(class_A, "B_p", "float", diags, true);
printf("func_const_B_p_proto 3: 0x%lx\n", (unsigned long) func_const_B_p_proto);
//CHECK: func_const_B_p_proto 3: 0x{{[1-9a-f][0-9a-f]*$}}
func_const_B_p_proto->print(cling::outs());
//CHECK-NEXT: long B_p(float) const {
//CHECK-NEXT:     return 0;
//CHECK-NEXT: }
func_const_B_p_proto = lookup.matchFunctionProto(class_A, "B_p", "float", diags, false);
printf("func_const_B_p_proto 4: 0x%lx\n", (unsigned long) func_const_B_p_proto);
//CHECK: func_const_B_p_proto 4: 0x0
func_const_B_p_proto = lookup.matchFunctionProto(class_A, "B_p", "int", diags, false);
printf("func_const_B_p_proto 5: 0x%lx\n", (unsigned long) func_const_B_p_proto);
//CHECK: func_const_B_p_proto 5: 0x{{[1-9a-f][0-9a-f]*$}}
func_const_B_p_proto->print(cling::outs());
//CHECK-NEXT: int B_p(int) {
//CHECK-NEXT:     return 0;
//CHECK-NEXT: }
func_const_B_p_proto = lookup.matchFunctionProto(class_A, "B_p", "int", diags, true);
printf("func_const_B_p_proto 6: 0x%lx\n", (unsigned long) func_const_B_p_proto);
//CHECK: func_const_B_p_proto 6: 0x0
func_const_B_p_proto = lookup.matchFunctionProto(class_A, "B_p", "short", diags, false);
// CHECK: (int) 15
Bc
// CHECK-NEXT: (int) 25
Cc
// CHECK-NEXT: (int) 35
static void InvokeTest(int A,
                       int B) { printf("Invoke: %d, %d\n", A, B); }
InvokeTest(Ac,
 Bc);
printf("func_const_B_p_proto 6: 0x%lx\n", (unsigned long) func_const_B_p_proto);
// CHECK-NEXT: Invoke: 15, 25
int A = 10,   \
    B = 20,   \
    C = 30;
A
//CHECK: func_const_B_p_proto 6: 0x0
// CHECK-NEXT: (int) 10
B
func_const_B_p_proto = lookup.matchFunctionProto(class_A, "B_p", "long", diags, false);
// CHECK-NEXT: (int) 20
C
// CHECK-NEXT: (int) 30
#define CLING_MULTILINE_STRING  "A" \
 "B" \
 " C D"
CLING_MULTILINE_STRING
printf("func_const_B_p_proto 6: 0x%lx\n", (unsigned long) func_const_B_p_proto);
//CHECK: func_const_B_p_proto 6: 0x0
//
//  Test finding constructors.
//
//
const clang::FunctionDecl* func_B_ctr1_args = lookup.findFunctionArgs(class_B, "B", "", diags);
// CHECK-NEXT: (const char [7]) "AB C D"
"Multinline" \
 " String " \
  "Constant"
"Separate"
const clang::FunctionDecl* func_B_ctr1_proto = lookup.findFunctionProto(class_B, "B", "", diags);
// CHECK-NEXT: (const char [27]) "Multinline String Constant"
// CHECK-NEXT: (const char [9]) "Separate"
// Common error handling macro
#define CLING_MULTILINE_MACRO(STR)  do { \
   printf(STR "\n"); } while(0)
CLING_MULTILINE_MACRO("DOWHILE");
// CHECK-NEXT: DOWHILE
#define CLING_MULTILINE_TRAILING_SPACE   \    
  "Trailing Space "   \    
  "And A Tab" \
  " End" // expected-warning@1 {{backslash and newline separated by space}} // expected-warning@2 {{backslash and newline separated by space}}
CLING_MULTILINE_TRAILING_SPACE
printf("func_B_ctr1_args: 0x%lx\n", (unsigned long) func_B_ctr1_args);
//CHECK: func_B_ctr1_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_ctr1_args->print(cling::outs());
// CHECK-NEXT: (const char [29]) "Trailing Space And A Tab End"
.q
//CHECK-NEXT: B() : m_B_i(0), m_B_d(0.), m_B_ip(0) {
//CHECK-NEXT: }
printf("func_B_ctr1_proto: 0x%lx\n", (unsigned long) func_B_ctr1_proto);
//CHECK: func_B_ctr1_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_ctr1_proto->print(cling::outs());
//CHECK-NEXT: B() : m_B_i(0), m_B_d(0.), m_B_ip(0) {
//CHECK-NEXT: }
const clang::FunctionDecl* func_B_ctr2_args = lookup.findFunctionArgs(class_B, "B", "0,0.0", diags);
const clang::FunctionDecl* func_B_ctr2_proto = lookup.findFunctionProto(class_B, "B", "int,double", diags);
printf("func_B_ctr2_args: 0x%lx\n", (unsigned long) func_B_ctr2_args);
//CHECK: func_B_ctr2_args: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_ctr2_args->print(cling::outs());
//CHECK-NEXT: B(int vi, double vd) : m_B_i(vi), m_B_d(vd), m_B_ip(0) {
//CHECK-NEXT: }
printf("func_B_ctr2_proto: 0x%lx\n", (unsigned long) func_B_ctr2_proto);
//CHECK: func_B_ctr2_proto: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_ctr2_proto->print(cling::outs());
//CHECK-NEXT: B(int vi, double vd) : m_B_i(vi), m_B_d(vd), m_B_ip(0) {
//CHECK-NEXT: }
B* force_B_char_ctr = new B('a');
const clang::FunctionDecl* func_B_ctr3_args = lookup.findFunctionArgs(class_B, "B", "'a'", diags);
const clang::FunctionDecl* func_B_ctr3_proto = lookup.findFunctionProto(class_B, "B", "char", diags);
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling --metastr=//. | FileCheck %s
// Test setting of meta escape
//.help // CHECK: Cling (C/C++ interpreter) meta commands usage
dumpDecl("func_B_ctr3_args", func_B_ctr3_args);
//CHECK: func_B_ctr3_args: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_ctr3_args name: B::B<char>
//CHECK-NEXT:  {
//CHECK-NEXT:     this->m_B_i = (char)v;
//CHECK-NEXT: }
dumpDecl("func_B_ctr3_proto", func_B_ctr3_proto);
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling 2>&1 | FileCheck %s
extern "C" int printf(const char*,...);
#include "cling/Interpreter/Interpreter.h"
//CHECK: func_B_ctr3_proto: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_ctr3_proto name: B::B<char>
//CHECK-NEXT:  {
//CHECK-NEXT:     this->m_B_i = (char)v;
//CHECK-NEXT: }
B* force_B_char_ptr_ctr = new B((char*)0);
const clang::FunctionDecl* func_B_ctr4_args = lookup.findFunctionArgs(class_B, "B", "(char*)0", diags);
const clang::FunctionDecl* func_B_ctr4_proto = lookup.findFunctionProto(class_B, "B", "char*", diags);
// CHECK: (class TestDecl &) @0x{{.*}}
int TestDecl::methodDefLater() { return 2; }
t.methodDefLater()
// CHECK: (int) 2
class TestDecl2 { public: float methodDefLater(); } b;
float TestDecl2::methodDefLater() { return 5.f; }
b.methodDefLater()
dumpDecl("func_B_ctr4_args", func_B_ctr4_args);
//CHECK: func_B_ctr4_args: 0x{{[1-9a-f][0-9a-f]*$}}
// CHECK: (float) 5.00000f
static int staticFunc(int a) {
  printf("staticFunc(%d)\n", a);
  return 1;
}
//CHECK-NEXT: func_B_ctr4_args name: B::B<char>
static int staticFunc(int a, int b, int c) {
  printf("staticFunc(%d, %d, %d)\n", a, b, c);
  return 3;
}
//CHECK-NEXT: template<> B<char>(char *v) : m_B_i(0), m_B_d(0.), m_B_ip(0) {
//CHECK-NEXT:     this->m_B_i = (long)(char *)v;
//CHECK-NEXT:     this->m_B_d = 1.;
staticFunc(10)
//CHECK-NEXT: }
dumpDecl("func_B_ctr4_proto", func_B_ctr4_proto);
// CHECK: staticFunc(10)
// CHECK: (int) 1
staticFunc(10, 20, 30)
//CHECK: func_B_ctr4_proto: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_ctr4_proto name: B::B<char>
//CHECK-NEXT: template<> B<char>(char *v) : m_B_i(0), m_B_d(0.), m_B_ip(0) {
//CHECK-NEXT:     this->m_B_i = (long)(char *)v;
//CHECK-NEXT:     this->m_B_d = 1.;
//CHECK-NEXT: }
printf("func_B_ctr4_proto has body: %d\n", func_B_ctr4_proto->hasBody());
// CHECK: staticFunc(10, 20, 30)
// CHECK: (int) 3
int localFun(int a) {
  printf("localFun(%d)\n", a);
  return 1;
}
#define staticweird int
staticweird localFun(int a, int b, int c) {
  printf("localFun(%d, %d, %d)\n", a, b, c);
  return 3;
}
localFun(0)
//CHECK: func_B_ctr4_proto has body: 1
// CHECK: localFun(0)
// CHECK: (int) 1
localFun(5, 6, 7)
//
//  Test finding destructors.
//
const clang::FunctionDecl* func_B_dtr_args = lookup.findFunctionArgs(class_B, "~B", "", diags);
// CHECK: localFun(5, 6, 7)
// CHECK: (int) 3
  
class Test {
public:
  Test(int a, int b);
  Test();
  ~Test();
};
Test::Test(int a, int b) {
  printf("Test::Test(%d,%d)\n", a, b);
}
Test::Test() {
  printf("Test::Test\n");
}
Test::~Test() {
  printf("Test::~Test\n");
}
{
  Test t;
  // CHECK: Test::Test
}
const clang::FunctionDecl* func_B_dtr_proto = lookup.findFunctionProto(class_B, "~B", "", diags);
// CHECK: Test::~Test
{
  Test t(5, 6);
  // CHECK: Test::Test(5,6)
}
// CHECK: Test::~Test
class Test2 {
  int A, B;
public:
  Test2(int a, int b);
  int subtract();
  int addition() const;
  void argspacing(int a, int b, int c) const;
  class Nested {
    public:
      struct Value {
        typedef int type;
      };
      Value::type m_A;
      Nested(int A);
      ~Nested();
      int simpleAdd(int b) const;
      int* pointer() const;
      const int& reference() const;
  };
};
Test2::Test2(int a, int b) : A(a), B(b) {
  printf("Test2::Test2(%d,%d)\n", A, B);
}
int Test2::subtract() {
  return A-B;
}
int Test2::addition() const {
  return A+B;
}
dumpDecl("func_B_dtr_args", func_B_dtr_args);
void Test2::argspacing(int a,
                       int
                           b,
                       int 
                         
                         
                           c) const {
  printf("Test2::argspacing(%d,%d,%d)\n", a, b, c);
}
Test2 t0(4, 5);
//CHECK: func_B_dtr_args: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_dtr_args name: B::~B
//CHECK-NEXT: virtual ~B(){{ noexcept | }}{
//CHECK-NEXT:     delete this->m_B_ip;
//CHECK-NEXT:     this->m_B_ip = 0;
// CHECK: Test2::Test2(4,5)
//CHECK-NEXT: }
t0.subtract()
dumpDecl("func_B_dtr_proto", func_B_dtr_proto);
// CHECK: (int) -1
t0.addition()
//CHECK: func_B_dtr_proto: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_dtr_proto name: B::~B
//CHECK-NEXT: virtual ~B(){{ noexcept | }}{
//CHECK-NEXT:     delete this->m_B_ip;
//CHECK-NEXT:     this->m_B_ip = 0;
//CHECK-NEXT: }
// CHECK: (int) 9
t0.argspacing(1,2,3)
//
//  Test finding free store operator new.
//
const clang::FunctionDecl* func_B_new_args = lookup.findFunctionArgs(class_B, "operator new", "sizeof(B)", diags);
// CHECK: Test2::argspacing(1,2,3)
Test2::Nested::Nested(int A) : m_A(A) {
  printf("Nested::Nested(%d)\n", m_A*2);
}
Test2::Nested::~Nested() {
  printf("Nested::~Nested(%d)\n", m_A);
}
Test2::Nested::Value::type Test2::Nested::simpleAdd(int b) const {
  return m_A + b;
}
Test2::Nested::Value::type* Test2::Nested::pointer() const {
  return (int*)&m_A;
}
const Test2::Nested::Value::type & Test2::Nested::reference() const {
  return m_A;
}
{
  Test2::Nested Nest(45);
  // CHECK: Nested::Nested(90)
}
const clang::FunctionDecl* func_B_new_proto = lookup.findFunctionProto(class_B, "operator new", "std::size_t", diags);
// CHECK: Nested::~Nested(45)
Test2::Nested Nest2(80);
// CHECK: Nested::Nested(160)
Nest2.simpleAdd(3)
// CHECK: (int) 83
class Test2 classReturn() { return Test2(10, 11); }
classReturn()
dumpDecl("func_B_new_args", func_B_new_args);
//CHECK: func_B_new_args: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_new_args name: B::operator new
//CHECK-NEXT: void *operator new(std::size_t sz) {
//CHECK-NEXT:     return ::operator new(sz);
// CHECK: Test2::Test2(10,11)
// CHECK: (class Test2) @0x{{.*}}
//CHECK-NEXT: }
class Test2* classReturnPtr() { return nullptr; }
classReturnPtr()
dumpDecl("func_B_new_proto", func_B_new_proto);
// CHECK: (class Test2 *) nullptr
int Ref = 42;
//CHECK: func_B_new_proto: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_new_proto name: B::operator new
const int& cIntRef(const int &val) {
  return val;
}
//CHECK-NEXT: void *operator new(std::size_t sz) {
cIntRef(Ref)
//CHECK-NEXT:     return ::operator new(sz);
//CHECK-NEXT: }
const clang::FunctionDecl* func_B_new_plcmt_args = lookup.findFunctionArgs(class_B, "operator new", "sizeof(B),((B*)&b_arena[0])+2", diags);
// CHECK: (const int) 42
Ref = 32;
const int* cIntStar(const int* val) {
  return val;
}
*cIntStar(&Ref)
// CHECK: (const int) 32
Ref = 56;
int & cIntRefSpace(int &val) {
  return val;
}
cIntRefSpace(Ref)
const clang::FunctionDecl* func_B_new_plcmt_proto = lookup.findFunctionProto(class_B, "operator new", "std::size_t,void*", diags);
// CHECK: (int) 56
Ref = 74;
int * cIntStarSpace(int* val) {
  return val;
}
*cIntStarSpace(&Ref)
// CHECK: (int) 74
constexpr int cExpr() {
  return 801;
}
cExpr()
dumpDecl("func_B_new_plcmt_args", func_B_new_plcmt_args);
// CHECK: (int) 801
int * & cIntStarRef(int*& val) {
  return val;
}
int * RPtr = &Ref;
int *& RefRPtr = RPtr;
cIntStarRef(RefRPtr)
//CHECK: func_B_new_plcmt_args: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_new_plcmt_args name: B::operator new
//CHECK-NEXT: void *operator new(std::size_t sz, void *arena) {
//CHECK-NEXT:     return arena;
//CHECK-NEXT: }
dumpDecl("func_B_new_plcmt_proto", func_B_new_plcmt_proto);
// CHECK: (int *) 0x{{[0-9a-f]+}}
//CHECK: func_B_new_plcmt_proto: 0x{{[1-9a-f][0-9a-f]*$}}
namespace Issue_113 {}
// Keep the blank space after the using clause.
using namespace Issue_113; 
// FIXME: Cannot handle `X<int> func()` yet?!
template <
  class T> class X {};
//CHECK-NEXT: func_B_new_plcmt_proto name: B::operator new
namespace N { template <class T> using X = ::X<T>; }
N::X<int> funcReturnsXint() {
  return X<int>{};
}
//CHECK-NEXT: void *operator new(std::size_t sz, void *arena) {
//CHECK-NEXT:     return arena;
//CHECK-NEXT: }
funcReturnsXint()
const clang::FunctionDecl* func_B_new_ary_args = lookup.findFunctionArgs(class_B, "operator new[]", "sizeof(B)*3", diags);
// CHECK-NEXT: (N::X<int>) @0x{{.*}}
// CHECK-NEXT: Nested::~Nested(80)
// expected-no-diagnostics
const clang::FunctionDecl* func_B_new_ary_proto = lookup.findFunctionProto(class_B, "operator new[]", "std::size_t", diags);
dumpDecl("func_B_new_ary_args", func_B_new_ary_args);
//CHECK: func_B_new_ary_args: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_new_ary_args name: B::operator new[]
//CHECK-NEXT: void *operator new[](std::size_t sz) {
//CHECK-NEXT:     return ::operator new[](sz);
//CHECK-NEXT: }
dumpDecl("func_B_new_ary_proto", func_B_new_ary_proto);
//CHECK: func_B_new_ary_proto: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_new_ary_proto name: B::operator new[]
//CHECK-NEXT: void *operator new[](std::size_t sz) {
//CHECK-NEXT:     return ::operator new[](sz);
//CHECK-NEXT: }
const clang::FunctionDecl* func_B_new_ary_plcmt_args = lookup.findFunctionArgs(class_B, "operator new[]", "sizeof(B)*3,&b_ary_arena[0]", diags);
const clang::FunctionDecl* func_B_new_ary_plcmt_proto = lookup.findFunctionProto(class_B, "operator new[]", "std::size_t,void*", diags);
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling | FileCheck %s
"simple"
dumpDecl("func_B_new_ary_plcmt_args", func_B_new_ary_plcmt_args);
//CHECK: func_B_new_ary_plcmt_args: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_new_ary_plcmt_args name: B::operator new[]
//CHECK-NEXT: void *operator new[](std::size_t sz, void *arena) {
//CHECK-NEXT:     return arena;
//CHECK-NEXT: }
dumpDecl("func_B_new_ary_plcmt_proto", func_B_new_ary_plcmt_proto);
//CHECK: func_B_new_ary_plcmt_proto: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_new_ary_plcmt_proto name: B::operator new[]
//CHECK-NEXT: void *operator new[](std::size_t sz, void *arena) {
//CHECK-NEXT:     return arena;
//CHECK-NEXT: }
//
//  Test finding free store operator delete.
//
const clang::FunctionDecl* func_B_del_args = lookup.findFunctionArgs(class_B, "operator delete", "b_ptr", diags);
const clang::FunctionDecl* func_B_del_proto = lookup.findFunctionProto(class_B, "operator delete", "void*", diags);
dumpDecl("func_B_del_args", func_B_del_args);
//CHECK: func_B_del_args: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_del_args name: B::operator delete
//CHECK-NEXT: void operator delete(void *vp){{ noexcept | }}{
//CHECK-NEXT:     ::operator delete(vp);
//CHECK-NEXT: }
dumpDecl("func_B_del_proto", func_B_del_proto);
//CHECK: func_B_del_proto: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_del_proto name: B::operator delete
//CHECK-NEXT: void operator delete(void *vp){{ noexcept | }}{
//CHECK-NEXT:     ::operator delete(vp);
//CHECK-NEXT: }
const clang::FunctionDecl* func_B_del_plcmt_args = lookup.findFunctionArgs(class_B, "operator delete", "((B*)&b_arena[0])+2,&b_arena[0]", diags);
const clang::FunctionDecl* func_B_del_plcmt_proto = lookup.findFunctionProto(class_B, "operator delete", "void*,void*", diags);
dumpDecl("func_B_del_plcmt_args", func_B_del_plcmt_args);
//CHECK: func_B_del_plcmt_args: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_del_plcmt_args name: B::operator delete
//CHECK-NEXT: void operator delete(void *vp, void *arena){{ noexcept | }}{
//CHECK-NEXT: }
dumpDecl("func_B_del_plcmt_proto", func_B_del_plcmt_proto);
//CHECK: func_B_del_plcmt_proto: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_del_plcmt_proto name: B::operator delete
//CHECK-NEXT: void operator delete(void *vp, void *arena){{ noexcept | }}{
//CHECK-NEXT: }
const clang::FunctionDecl* func_B_del_ary_args = lookup.findFunctionArgs(class_B, "operator delete[]", "b_ary", diags);
const clang::FunctionDecl* func_B_del_ary_proto = lookup.findFunctionProto(class_B, "operator delete[]", "void*", diags);
dumpDecl("func_B_del_ary_args", func_B_del_ary_args);
//CHECK: func_B_del_ary_args: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_del_ary_args name: B::operator delete[]
//CHECK-NEXT: void operator delete[](void *vp){{ noexcept | }}{
//CHECK-NEXT:     ::operator delete[](vp);
//CHECK-NEXT: }
dumpDecl("func_B_del_ary_proto", func_B_del_ary_proto);
//CHECK: func_B_del_ary_proto: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_del_ary_proto name: B::operator delete[]
//CHECK-NEXT: void operator delete[](void *vp){{ noexcept | }}{
//CHECK-NEXT:     ::operator delete[](vp);
//CHECK-NEXT: }
const clang::FunctionDecl* func_B_del_ary_plcmt_args = lookup.findFunctionArgs(class_B, "operator delete[]", "(B*)b_arena,&b_arena[0]", diags);
const clang::FunctionDecl* func_B_del_ary_plcmt_proto = lookup.findFunctionProto(class_B, "operator delete[]", "void*,void*", diags);
dumpDecl("func_B_del_ary_plcmt_args", func_B_del_ary_plcmt_args);
//CHECK: func_B_del_ary_plcmt_args: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_del_ary_plcmt_args name: B::operator delete[]
//CHECK-NEXT: void operator delete[](void *vp, void *arena){{ noexcept | }}{
//CHECK-NEXT: }
dumpDecl("func_B_del_ary_plcmt_proto", func_B_del_ary_plcmt_proto);
//CHECK: func_B_del_ary_plcmt_proto: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_del_ary_plcmt_proto name: B::operator delete[]
//CHECK-NEXT: void operator delete[](void *vp, void *arena){{ noexcept | }}{
//CHECK-NEXT: }
//
//  Test finding unary member operator.
//
const clang::FunctionDecl* func_B_star_args = lookup.findFunctionArgs(class_B, "operator*", "", diags);
const clang::FunctionDecl* func_B_star_proto = lookup.findFunctionProto(class_B, "operator*", "", diags);
dumpDecl("func_B_star_args", func_B_star_args);
//CHECK: func_B_star_args: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_star_args name: B::operator*
//CHECK-NEXT: B &operator*() {
//CHECK-NEXT:     return *this;
//CHECK-NEXT: }
dumpDecl("func_B_star_proto", func_B_star_proto);
//CHECK: func_B_star_proto: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_star_proto name: B::operator*
//CHECK-NEXT: B &operator*() {
//CHECK-NEXT:     return *this;
//CHECK-NEXT: }
//
//  Test finding binary member operator.
//
const clang::FunctionDecl* func_B_plus_args = lookup.findFunctionArgs(class_B, "operator+", "b_obj", diags);
const clang::FunctionDecl* func_B_plus_proto = lookup.findFunctionProto(class_B, "operator+", "B", diags);
dumpDecl("func_B_plus_args", func_B_plus_args);
//CHECK: func_B_plus_args: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_plus_args name: B::operator+
//CHECK-NEXT: B operator+(B b) {
//CHECK-NEXT:     return b;
//CHECK-NEXT: }
dumpDecl("func_B_plus_proto", func_B_plus_proto);
//CHECK: func_B_plus_proto: 0x{{[1-9a-f][0-9a-f]*$}}
//CHECK-NEXT: func_B_plus_proto name: B::operator+
//CHECK-NEXT: B operator+(B b) {
//CHECK-NEXT:     return b;
//CHECK-NEXT: }
//
// Test finding simple member function (including template instantiations
// from just the name.
//
const clang::FunctionDecl* func_B_j_name = lookup.findAnyFunction(class_A, "B_j", diags);
printf("func_B_j_name: 0x%lx\n", (unsigned long) func_B_j_name);
//CHECK: func_B_j_name: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_j_name->print(cling::outs());
//CHECK-NEXT: void B_j(int vi, int vj) {
//CHECK-NEXT:   int x = vi;
//CHECK-NEXT:   int y = vj;
//CHECK-NEXT: }
const clang::FunctionDecl* func_B_k1_name = lookup.findAnyFunction(class_A, "B_k<float>", diags);
printf("func_B_k1_name: 0x%lx\n", (unsigned long) func_B_k1_name);
//CHECK: func_B_k1_name: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_k1_name->print(cling::outs());
//CHECK-NEXT: template<> void B_k<float>(float v) {
//CHECK-NEXT:     float x = v;
//CHECK-NEXT: }
const clang::FunctionDecl* func_B_k1_name_2 = lookup.findAnyFunction(class_A, "B_k", diags);
printf("func_B_k1_name_2: 0x%lx\n", (unsigned long) func_B_k1_name_2);
//CHECK: func_B_k1_name_2: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_k1_name_2->print(cling::outs());
//CHECK-NEXT: template<> void B_k<int>(int v) {
//CHECK-NEXT:     int x = v;
//CHECK-NEXT: }
const clang::FunctionTemplateDecl* func_B_k_template = lookup.findFunctionTemplate(class_A, "B_k", diags);
printf("func_B_k_template: 0x%lx\n", (unsigned long) func_B_k_template);
//CHECK: func_B_k_template: 0x{{[1-9a-f][0-9a-f]*$}}
func_B_k_template->print(cling::outs());
//CHECK-NEXT: template <class T> void B_k(T v) {
//CHECK-NEXT:     T x = v;
//CHECK-NEXT: }
//
//  One final check to make sure we are at the right line in the output.
//
"abc"
//CHECK: (const char [4]) "abc"
//
//  Cleanup.
//
delete[] b_ary;
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling | FileCheck %s
//XFAIL: *
// This test should test the unnamed macro support once it is moved in cling.
.x Commands.macro
// CHECK: I am a function called f.
// CHECK-NOT: 0
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -I%p | FileCheck %s
// This file should be used as regression test for the meta processing subsystem
// Reproducers of fixed bugs should be put here
// PR #93092
// Don't remove the spaces and tabs
.L     cling/Interpreter/Interpreter.h    
//CHECK: (const char [7]) "simple"
"It's me"
//CHECK: (const char [8]) "It's me"
"Luke, I'm your (father({}{["
//CHECK: const char [28]) "Luke, I'm your (father({}{["
("http://foo/bar/whatever")
//CHECK: (const char [24]) "http://foo/bar/whatever"
("http://foo.bar/whatever")
//CHECK: (const char [24]) "http://foo.bar/whatever"
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling | FileCheck %s
int abcdefghxyz = 10
//CHECK: (int) 10
.trace ast abcdefghxyz
//CHECK: Dumping abcdefghxyz:
//CHECK: VarDecl {{0x[0-9a-f]+}} <input_line_[[@LINE-3]]:2:2, col:20> col:6 used abcdefghxyz 'int' cinit
//CHECK: `-IntegerLiteral {{0x[0-9a-f]+}} <col:20> 'int' 10
// RUN: cat %s | %cling -DCLING_TMP="\"%/T\"" | FileCheck --check-prefix=CHECKOUT %s
// RUN: cat %T/outfile.txt | FileCheck --check-prefix=CHECK-REDIRECTOUT %s
// RUN: cat %T/errfile.txt | FileCheck --check-prefix=CHECK-REDIRECTERR %s
// RUN: cat %T/bothfile.txt | FileCheck --check-prefix=CHECK-REDIRECTBOTH %s
// RUN: cat %T/anotheroutfile.txt | FileCheck --check-prefix=CHECK-REDIRECTANOTHER %s
// RUN: cat %T/nospace.txt | FileCheck --check-prefix=CHECK-NOSPACE %s
// RUN: cat %s | %cling -DCLING_TMP="\"%/T\"" 2> %T/stderr.txt && cat %T/stderr.txt | FileCheck --check-prefix=CHECKERR %s
// RUN: cat %s | %cling -DCLING_TMP="\"%/T\"" 2>&1 | FileCheck --check-prefix=CHECKERR --check-prefix=CHECKOUT %s
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;
using namespace llvm;
.rawInput 1
class OuterClass {
public:
   template <typename T> class TmpltInside {};
};
template <typename T> class TmpltOutside {};
.rawInput 0
const cling::LookupHelper& lookup = gCling->getLookupHelper();
cling::LookupHelper::DiagSetting diags = cling::LookupHelper::WithDiagnostics;
const clang::ClassTemplateDecl* tmplt_out = lookup.findClassTemplate("TmpltOutside", diags);
printf("tmplt_out: 0x%lx\n", (unsigned long) tmplt_out);
//CHECK: tmplt_out: 0x{{[1-9a-f][0-9a-f]*$}}
tmplt_out->getQualifiedNameAsString().c_str()
//CHECK-NEXT: ({{[^)]+}}) "TmpltOutside"
const clang::ClassTemplateDecl* tmplt_inside = lookup.findClassTemplate("OuterClass::TmpltInside", diags);
printf("tmplt_inside: 0x%lx\n", (unsigned long) tmplt_inside);
//CHECK: tmplt_inside: 0x{{[1-9a-f][0-9a-f]*$}}
tmplt_inside->getQualifiedNameAsString().c_str()
//CHECK-NEXT: ({{[^)]+}}) "OuterClass::TmpltInside"
const clang::ClassTemplateDecl* tmplt_vec = lookup.findClassTemplate("std::vector", diags);
printf("tmplt_vec: 0x%lx\n", (unsigned long) tmplt_vec);
//CHECK: tmplt_vec: 0x{{[1-9a-f][0-9a-f]*$}}
tmplt_vec->getQualifiedNameAsString().c_str()
//CHECK-NEXT: ({{[^)]+}}) "std::{{(__1::)?}}vector"
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -DPROBABLY_DEFINED -DDEF_DEF -Xclang -verify 2>&1 | FileCheck %s
// Test preprocessorIfSupport
#if 0
  0
  // CHECK-NOT: (int) 0
#endif
#if 1
  1
  // CHECK: (int) 1
#endif
#include "llvm/ADT/SmallVector.h"
#include <iostream>
#include <cstdio>
#include <string>
void printScope(const clang::DeclContext *ctxt) {
//  llvm::raw_string_ostream OS(S);
//  dyn_cast<clang::NamedDecl>(D)
//  ->getNameForDiagnostic(OS, D->getASTContext().getPrintingPolicy(),
//                         /*Qualified=*/true);
  const clang::NamedDecl *decl = llvm::dyn_cast<clang::NamedDecl>(ctxt);
  if (decl) {
    cling::outs() << "Context is " << decl->getQualifiedNameAsString() << '\n';
  } else {
    cling::outs() << "Context is not a named decl\n";
  }
}
int gValue;
template<typename T> class aTemplate {
public:
   static T gValue;
   T fMember;
};
namespace NS {
   double gValue;
}
namespace NS {
  double gValue2;
}
class A {
   static short gValue;
   double fMember;
};
.rawInput 0
const cling::LookupHelper& lookup = gCling->getLookupHelper();
cling::LookupHelper::DiagSetting diags = cling::LookupHelper::WithDiagnostics;
std::string buf;
clang::PrintingPolicy Policy(gCling->getSema().getASTContext().getPrintingPolicy());
//
//  We need to fetch the global scope declaration,
//  otherwise known as the translation unit decl.
//
const clang::Decl* G = lookup.findScope("", diags);
llvm::errs() << "G: " << G << '\n';
//CHECK: G: 0x{{[1-9a-f][0-9a-f]*$}}
//
//  We need these class declarations.
//
const clang::Decl* class_tempFlt = lookup.findScope("aTemplate<float>", diags);
llvm::errs() << "class_tempFlt: " << class_tempFlt << '\n';
//CHECK: class_tempFlt: 0x{{[1-9a-f][0-9a-f]*$}}
const clang::Decl* class_A = lookup.findScope("A", diags);
llvm::errs() << "class_A: " << class_A << '\n';
//CHECK-NEXT: class_A: 0x{{[1-9a-f][0-9a-f]*$}}
const clang::Decl* namespace_NS = lookup.findScope("NS", diags);
llvm::errs() << "namespace_NS: " << namespace_NS << '\n';
//CHECK-NEXT: namespace_NS: 0x{{[1-9a-f][0-9a-f]*$}}
//
// Now test find data members.
//
const clang::ValueDecl *decl;
decl = lookup.findDataMember(G,"gValue", diags);
printScope(decl->getDeclContext());
extern "C" int setenv(const char *name, const char *value, int overwrite);
extern "C" int _putenv_s(const char *name, const char *value);
static void setup() {
#ifdef _WIN32
 #define setenv(n, v, o) _putenv_s(n,v)
#endif
  ::setenv("CLING_TMP", CLING_TMP, 1);
}
setup();
// ROOT-8696
.5 //CHECKOUT: (double) 0.500000
#include "cling/Interpreter/Transaction.h"
decl->dump(cling::outs());
//CHECK-NEXT: Context is not a named decl
//CHECK-NEXT: VarDecl 0x{{[1-9a-f][0-9a-f]*}} <{{.*}}> col:5 gValue 'int'
decl = lookup.findDataMember(class_tempFlt,"gValue", diags);
printScope(decl->getDeclContext());
decl->dump(cling::outs());
//CHECK-NEXT: Context is aTemplate
//CHECK-NEXT: VarDecl 0x{{[1-9a-f][0-9a-f]*}} <{{.*}}> col:13 gValue 'float':'float' static
decl = lookup.findDataMember(class_tempFlt,"fMember", diags);
printScope(decl->getDeclContext());
.2>&1
std::cerr << "Error into stdout.\n";
//CHECKOUT: Error into stdout.
.2>
std::cerr << "Error back from stdout.\n";
//CHECKERR: Error back from stdout.
.1>&2
std::cout << "stdout into stderr.\n";
//CHECKERR: stdout into stderr.
.1>
std::cout << "stdout back from stderr.\n";
//CHECKOUT: stdout back from stderr.
// Test redirect stdout
.> $CLING_TMP/outfile.txt
int a = 101
decl->dump(cling::outs());
//CHECK-REDIRECTOUT: (int) 101
int b = 102
//CHECK-REDIRECTOUT: (int) 102
int c = 103
//CHECK-NEXT: Context is aTemplate
//CHECK-NEXT: FieldDecl 0x{{[1-9a-f][0-9a-f]*}} <{{.*}}> col:6 fMember 'float':'float'
decl = lookup.findDataMember(namespace_NS,"gValue", diags);
//CHECK-REDIRECTOUT: (int) 103
// Test stderr is not redirected as well.
std::cerr << "Into Error\n";
//CHECKERR: Into Error
// Test toggle back to prompt.
.>
int var = 9
//CHECKOUT: (int) 9
// Test append mode.
.>> $CLING_TMP/outfile.txt
a = 991
printScope(decl->getDeclContext());
//CHECK-REDIRECTOUT: (int) 991
b = 992
//CHECK-REDIRECTOUT: (int) 992
c = 993
//CHECK-REDIRECTOUT: (int) 993
// Test redirect stderr
.2> $CLING_TMP/errfile.txt
std::cerr << "Error redirected.\n";
#if PROBABLY_NOT_DEFINED
//CHECK-REDIRECTERR: Error redirected.
  10
  // CHECK-NOT: (int) 10
#elif defined(PROBABLY_DEFINED)
// Test stdout is still redirected to the correct file.
  20
  // CHECK: (int) 20
var = 20
#else
  30
  // CHECK-NOT: (int) 30
#endif//
// '#endif//' intentional
//CHECK-REDIRECTOUT: (int) 20
#ifdef DEF_DEF
  struct Nested {
    int array[1];
// Test toggle only stdout and stderr still redirected.
    Nested() { array[0] = 200; }
    int f() { return array[0]; }
.>
a = 100
  };
  Nested n  // Print expression works as last before #endif
  // CHECK: (Nested &) @0x{{[0-9a-f]+}}
#else
   Nested n
   Nested n;
   Nested n
#endif   
//CHECKOUT: (int) 100
std::cerr << "Error still redirected.\n";
//CHECK-REDIRECTERR: Error still redirected.
// Test toggle stderr back to prompt.
.2>
std::cerr << "Error back to prompt.\n";
decl->dump(cling::outs());
//CHECKERR: Error back to prompt.
// Test redirect of both streams.
.&> $CLING_TMP/bothfile.txt
a=310
//CHECK-NEXT: Context is NS
//CHECK-NEXT: VarDecl 0x{{[1-9a-f][0-9a-f]*}} <{{.*}}> col:11 gValue 'double'
// '#endif   ' intentional
n.f()
//CHECK-REDIRECTBOTH: (int) 310
b=311
decl = lookup.findDataMember(namespace_NS,"gValue2", diags);
//CHECK-REDIRECTBOTH: (int) 311
c=312
// CHECK: (int) 200
#ifdef DEF_DEF
  80 // expected-error {{expected ';' after expression}}
  n.f();
#endif
.rawInput
#if 0
  Err Here
#elif PROBABLY_NOT_DEFINED
  Err Here
#else
  Nested n1;
#endif
//CHECK-REDIRECTBOTH: (int) 312
std::cerr << "Redirect both out & err.\n";
.rawInput
n1.f()
printScope(decl->getDeclContext());
//CHECK-REDIRECTBOTH: Redirect both out & err.
// Test toggle both back to the prompt.
.&>
var = 400
// CHECK: (int) 200
.q
//CHECKOUT: (int) 400
std::cerr << "Both back to prompt.\n";
//CHECKERR: Both back to prompt.
// Test append mode for both streams.
.&>> $CLING_TMP/bothfile.txt
a=491
//CHECK-REDIRECTBOTH: (int) 491
b=492
//CHECK-REDIRECTBOTH: (int) 492
c=493
//CHECK-REDIRECTBOTH: (int) 493
std::cerr << "Append mode for both streams.\n";
//CHECK-REDIRECTBOTH: Append mode for both streams.
// Test toggle only stdout to prompt and stderr to file.
.>
var = 699
decl->dump(cling::outs());
//CHECKOUT: (int) 699
std::cerr << "Err is still in &> file.\n";
//CHECK-REDIRECTBOTH: Err is still in &> file.
//CHECK-NEXT: Context is NS
// Test toggle stderr to the prompt when redirected with &.
.2>
std::cerr << "Err back from &> file.\n";
//CHECK-NEXT: VarDecl 0x{{[1-9a-f][0-9a-f]*}} <{{.*}}> col:10 gValue2 'double'
decl = lookup.findDataMember(class_A,"gValue", diags);
//CHECKERR: Err back from &> file.
// Test redirect to filename without space
.>$CLING_TMP/nospace.txt
a = 1012
//CHECK-NOSPACE: (int) 1012
b = 1023
//CHECK-NOSPACE: (int) 1023
c = 1034
printScope(decl->getDeclContext());
//CHECK-NOSPACE: (int) 1034
// Test append mode to filename without space
.>>$CLING_TMP/nospace.txt
a = 9915
//CHECK-NOSPACE: (int) 9915
b = 9926
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling | FileCheck %s
.rawInput 1
extern "C" int printf(const char* fmt, ...);
namespace MyNamespace {
  class MyClass {
  public:
    MyClass() { printf("MyClass constructor called!\n"); }
  };
  void f() {
    printf("Function f in namespace MyNamespace called!\n");
  }
}
.rawInput 0
MyNamespace::MyClass m = MyNamespace::MyClass(); // CHECK MyClass constructor called!
//CHECK-NOSPACE: (int) 9926
c = 9937
//CHECK-NOSPACE: (int) 9937
// Test redirect with & and toggle to out file.
.&>> $CLING_TMP/bothfile.txt
var = 999
MyNamespace::f(); // CHECK: Function f in namespace MyNamespace called!
//CHECK-REDIRECTBOTH: (int) 999
// Test that exiting in a redirected state will flush properly
.1> $CLING_TMP/anotheroutfile.txt
a = 710
//CHECK-REDIRECTANOTHER: (int) 710
b = 711
//CHECK-REDIRECTANOTHER: (int) 711
c = 712
decl->dump(cling::outs());
//CHECK-REDIRECTANOTHER: (int) 712
//CHECK-NEXT: Context is A
//CHECK-NEXT: VarDecl 0x{{[1-9a-f][0-9a-f]*}} <{{.*}}> col:17 gValue 'short' static
decl = lookup.findDataMember(class_A,"fMember", diags);
printScope(decl->getDeclContext());
decl->dump(cling::outs());
// RUN: cat %s | %cling -DCLING_TMP="\"%/T\"" | FileCheck --check-prefix=CHECKOUT %s
// RUN: cat %T/outfile.txt | FileCheck --check-prefix=CHECK-REDIRECTOUT %s
// RUN: cat %T/errfile.txt | FileCheck --check-prefix=CHECK-REDIRECTERR %s
// RUN: cat %T/bothfile.txt | FileCheck --check-prefix=CHECK-REDIRECTBOTH %s
// RUN: cat %T/anotheroutfile.txt | FileCheck --check-prefix=CHECK-REDIRECTANOTHER %s
// RUN: cat %T/nospace.txt | FileCheck --check-prefix=CHECK-NOSPACE %s
// RUN: cat %s | %cling -DCLING_TMP="\"%/T\"" 2> %T/stderr.txt && cat %T/stderr.txt | FileCheck --check-prefix=CHECKERR %s
// RUN: cat %s | %cling -DCLING_TMP="\"%/T\"" 2>&1 | FileCheck --check-prefix=CHECKERR --check-prefix=CHECKOUT %s
#include <iostream>
//CHECK-NEXT: Context is A
//CHECK-NEXT: FieldDecl 0x{{[1-9a-f][0-9a-f]*}} <{{.*}}> col:11 fMember 'double'
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling | FileCheck %s
// Checks for infinite recursion when we combine nested calls of process line
// with global initializers.
#include "cling/Interpreter/Interpreter.h"
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify
class MyClass{}; // expected-note {{previous definition is here}}
struct MyClass{} // expected-error {{redefinition of 'MyClass'}}
MyClass * s; // expected-note {{previous definition is here}}
MyClass s; // expected-error {{redefinition of 's'}}
const char* a = "test"; // expected-note {{previous definition is here}}
const char* a = ""; // expected-error {{redefinition of 'a'}}
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -I%p | FileCheck %s
// This file should be used as regression test for the meta processing subsystem
// Reproducers of fixed bugs should be put here
// PR #96277
#include "cling/Interpreter/Interpreter.h"
#include "llvm/ADT/SmallVector.h"
.rawInput 1
int a;
template<typename T> class aClass {
  T f() {
    return T();
  }
};
.rawInput 0
const cling::LookupHelper& lookup = gCling->getLookupHelper();
cling::LookupHelper::DiagSetting diags = cling::LookupHelper::WithDiagnostics;
llvm::SmallVector<clang::Expr*, 4> exprs;
std::string buf;
clang::PrintingPolicy Policy(gCling->getSema().getASTContext().getPrintingPolicy());
lookup.findArgList("a, a", exprs, diags);
exprs[0]->dumpPretty(gCling->getSema().getASTContext());
//CHECK: a
exprs[1]->dumpPretty(gCling->getSema().getASTContext());
//CHECK: a
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling | FileCheck %s
int a = 12;
a // CHECK: (int) 12
extern "C" int setenv(const char *name, const char *value, int overwrite);
extern "C" int _putenv_s(const char *name, const char *value);
static void setup() {
#ifdef _WIN32
 #define setenv(n, v, o) _putenv_s(n,v)
#endif
  ::setenv("CLING_TMP", CLING_TMP, 1);
}
setup();
// ROOT-8696
.5 //CHECKOUT: (double) 0.500000
.2>&1
std::cerr << "Error into stdout.\n";
//CHECKOUT: Error into stdout.
.2>
std::cerr << "Error back from stdout.\n";
//CHECKERR: Error back from stdout.
.1>&2
std::cout << "stdout into stderr.\n";
//CHECKERR: stdout into stderr.
.1>
std::cout << "stdout back from stderr.\n";
//CHECKOUT: stdout back from stderr.
// Test redirect stdout
.> $CLING_TMP/outfile.txt
int a = 101
//CHECK-REDIRECTOUT: (int) 101
int b = 102
//CHECK-REDIRECTOUT: (int) 102
int c = 103
//CHECK-REDIRECTOUT: (int) 103
// Test stderr is not redirected as well.
std::cerr << "Into Error\n";
//CHECKERR: Into Error
// Test toggle back to prompt.
.>
int var = 9
//CHECKOUT: (int) 9
// Test append mode.
.>> $CLING_TMP/outfile.txt
a = 991
//CHECK-REDIRECTOUT: (int) 991
b = 992
//CHECK-REDIRECTOUT: (int) 992
c = 993
//CHECK-REDIRECTOUT: (int) 993
// Test redirect stderr
.2> $CLING_TMP/errfile.txt
std::cerr << "Error redirected.\n";
//CHECK-REDIRECTERR: Error redirected.
// Test stdout is still redirected to the correct file.
var = 20
const char* b = "b" // CHECK: (const char *) "b"
//CHECK-REDIRECTOUT: (int) 20
// Test toggle only stdout and stderr still redirected.
.>
a = 100
//CHECKOUT: (int) 100
std::cerr << "Error still redirected.\n";
//CHECK-REDIRECTERR: Error still redirected.
// Test toggle stderr back to prompt.
.2>
std::cerr << "Error back to prompt.\n";
   const char* n = 0 // CHECK: (const char *) nullptr
//CHECKERR: Error back to prompt.
struct C {int d;} E = {22};
// Test redirect of both streams.
.&> $CLING_TMP/bothfile.txt
a=310
E // CHECK: (struct C &) @0x{{[0-9A-Fa-f]{5,12}.}}
//CHECK-REDIRECTBOTH: (int) 310
b=311
E.d // CHECK: (int) 22
//CHECK-REDIRECTBOTH: (int) 311
c=312
#include <string>
std::string s("xyz")
//CHECK-REDIRECTBOTH: (int) 312
std::cerr << "Redirect both out & err.\n";
//CHECK-REDIRECTBOTH: Redirect both out & err.
// Test toggle both back to the prompt.
.&>
var = 400
//CHECKOUT: (int) 400
std::cerr << "Both back to prompt.\n";
//CHECKERR: Both back to prompt.
// Test append mode for both streams.
// CHECK: (std::string &) "xyz"
#include <limits.h>
.&>> $CLING_TMP/bothfile.txt
a=491
class Outer {
public:
  struct Inner {
    enum E{
      A = INT_MAX,
      B = 2,
      C = 2,
      D = INT_MIN
    } ABC;
  };
};
Outer::Inner::C
//CHECK-REDIRECTBOTH: (int) 491
b=492
// CHECK: (Outer::Inner::E::B) ? (Outer::Inner::E::C) : (int) 2
Outer::Inner::D
//CHECK-REDIRECTBOTH: (int) 492
c=493
// CHECK: (Outer::Inner::E::D) : (int) -{{[0-9].*}}
// Put an enum on the global scope
enum E{ e1 = -12, e2, e3=33, e4, e5 = 33};
e2
//CHECK-REDIRECTBOTH: (int) 493
std::cerr << "Append mode for both streams.\n";
// CHECK: (E::e2) : (int) -11
::e1
// CHECK: (E::e1) : (int) -12
// Arrays:
float farr[] = {0.,1.,2.,3.,4.,5.} // CHECK: (float [6]) { 0.{{0+}}f, 1.{{0+}}f, 2.{{0+}}f, 3.{{0+}}f, 4.{{0+}}f, 5.{{0+}}f }
//CHECK-REDIRECTBOTH: Append mode for both streams.
// Test toggle only stdout to prompt and stderr to file.
.>
var = 699
//CHECKOUT: (int) 699
std::cerr << "Err is still in &> file.\n";
//CHECK-REDIRECTBOTH: Err is still in &> file.
// Test toggle stderr to the prompt when redirected with &.
.2>
std::cerr << "Err back from &> file.\n";
//CHECKERR: Err back from &> file.
// Test redirect to filename without space
.>$CLING_TMP/nospace.txt
a = 1012
//CHECK-NOSPACE: (int) 1012
b = 1023
//CHECK-NOSPACE: (int) 1023
c = 1034
//CHECK-NOSPACE: (int) 1034
// Test append mode to filename without space
.>>$CLING_TMP/nospace.txt
a = 9915
//CHECK-NOSPACE: (int) 9915
b = 9926
//CHECK-NOSPACE: (int) 9926
std::string sarr[3] = {"A", "B", "C"} // CHECK: (std::string [3]) { "A", "B", "C" }
c = 9937
//CHECK-NOSPACE: (int) 9937
// Test redirect with & and toggle to out file.
.&>> $CLING_TMP/bothfile.txt
var = 999
//CHECK-REDIRECTBOTH: (int) 999
// Test that exiting in a redirected state will flush properly
.1> $CLING_TMP/anotheroutfile.txt
a = 710
//CHECK-REDIRECTANOTHER: (int) 710
b = 711
//CHECK-REDIRECTANOTHER: (int) 711
c = 712
//CHECK-REDIRECTANOTHER: (int) 712
typedef void (*F_t)(int);
F_t fp = 0;
fp // CHECK: (F_t) Function @0x0
#include <stdio.h>
fp = (F_t)printf // CHECK: (F_t) Function @0x{{[0-9A-Fa-f]{5,12}.}}
.q
// RUN: cat %s | %cling -DCLING_TMP="\"%/T\"" | FileCheck --check-prefix=CHECKOUT %s
// RUN: cat %T/outfile.txt | FileCheck --check-prefix=CHECK-REDIRECTOUT %s
// RUN: cat %T/errfile.txt | FileCheck --check-prefix=CHECK-REDIRECTERR %s
// RUN: cat %T/bothfile.txt | FileCheck --check-prefix=CHECK-REDIRECTBOTH %s
// RUN: cat %T/anotheroutfile.txt | FileCheck --check-prefix=CHECK-REDIRECTANOTHER %s
// RUN: cat %T/nospace.txt | FileCheck --check-prefix=CHECK-NOSPACE %s
// RUN: cat %s | %cling -DCLING_TMP="\"%/T\"" 2> %T/stderr.txt && cat %T/stderr.txt | FileCheck --check-prefix=CHECKERR %s
// RUN: cat %s | %cling -DCLING_TMP="\"%/T\"" 2>&1 | FileCheck --check-prefix=CHECKERR --check-prefix=CHECKOUT %s
#include <iostream>
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify 2>&1 | FileCheck %s
#include <string>
#include "cling/Interpreter/Transaction.h"
#include <tuple>
#include <vector>
#include <map>
#include <set>
std::vector<bool> Bv(5,5)
// CHECK: (std::vector<bool> &) { true, true, true, true, true }
std::vector<std::vector<bool>> Bvv;
extern "C" int setenv(const char *name, const char *value, int overwrite);
extern "C" int _putenv_s(const char *name, const char *value);
static void setup() {
#ifdef _WIN32
 #define setenv(n, v, o) _putenv_s(n,v)
#endif
  ::setenv("CLING_TMP", CLING_TMP, 1);
}
setup();
// ROOT-8696
.5 //CHECKOUT: (double) 0.500000
for (int i = 0; i < 5; ++i) {
  Bvv.push_back(std::vector<bool>());
  for (int j = 0, N = i+1; j < N; ++j)
    Bvv.back().push_back(j % 4);
}
.2>&1
std::cerr << "Error into stdout.\n";
//CHECKOUT: Error into stdout.
.2>
std::cerr << "Error back from stdout.\n";
//CHECKERR: Error back from stdout.
.1>&2
std::cout << "stdout into stderr.\n";
//CHECKERR: stdout into stderr.
.1>
std::cout << "stdout back from stderr.\n";
//CHECKOUT: stdout back from stderr.
// Test redirect stdout
.> $CLING_TMP/outfile.txt
int a = 101
//CHECK-REDIRECTOUT: (int) 101
int b = 102
//CHECK-REDIRECTOUT: (int) 102
int c = 103
//CHECK-REDIRECTOUT: (int) 103
// Test stderr is not redirected as well.
std::cerr << "Into Error\n";
//CHECKERR: Into Error
// Test toggle back to prompt.
.>
int var = 9
//CHECKOUT: (int) 9
// Test append mode.
.>> $CLING_TMP/outfile.txt
a = 991
//CHECK-REDIRECTOUT: (int) 991
b = 992
//CHECK-REDIRECTOUT: (int) 992
c = 993
//CHECK-REDIRECTOUT: (int) 993
// Test redirect stderr
.2> $CLING_TMP/errfile.txt
std::cerr << "Error redirected.\n";
//CHECK-REDIRECTERR: Error redirected.
// Test stdout is still redirected to the correct file.
var = 20
//CHECK-REDIRECTOUT: (int) 20
// Test toggle only stdout and stderr still redirected.
.>
a = 100
//CHECKOUT: (int) 100
std::cerr << "Error still redirected.\n";
//CHECK-REDIRECTERR: Error still redirected.
// Test toggle stderr back to prompt.
.2>
std::cerr << "Error back to prompt.\n";
//CHECKERR: Error back to prompt.
// Test redirect of both streams.
.&> $CLING_TMP/bothfile.txt
a=310
//CHECK-REDIRECTBOTH: (int) 310
b=311
.X ./DotXable.h(5)
//CHECK-REDIRECTBOTH: (int) 311
c=312
//CHECK-REDIRECTBOTH: (int) 312
std::cerr << "Redirect both out & err.\n";
// CHECK: 5
//CHECK-REDIRECTBOTH: Redirect both out & err.
// End PR #93092
// Test toggle both back to the prompt.
.&>
var = 400
//CHECKOUT: (int) 400
std::cerr << "Both back to prompt.\n";
//CHECKERR: Both back to prompt.
// Test append mode for both streams.
.&>> $CLING_TMP/bothfile.txt
a=491
//CHECK-REDIRECTBOTH: (int) 491
b=492
//CHECK-REDIRECTBOTH: (int) 492
c=493
//CHECK-REDIRECTBOTH: (int) 493
std::cerr << "Append mode for both streams.\n";
//CHECK-REDIRECTBOTH: Append mode for both streams.
// Test toggle only stdout to prompt and stderr to file.
.>
var = 699
//CHECKOUT: (int) 699
std::cerr << "Err is still in &> file.\n";
//CHECK-REDIRECTBOTH: Err is still in &> file.
// Test toggle stderr to the prompt when redirected with &.
.2>
std::cerr << "Err back from &> file.\n";
//CHECKERR: Err back from &> file.
// Test redirect to filename without space
.>$CLING_TMP/nospace.txt
a = 1012
//CHECK-NOSPACE: (int) 1012
b = 1023
//CHECK-NOSPACE: (int) 1023
c = 1034
//CHECK-NOSPACE: (int) 1034
// Test append mode to filename without space
.>>$CLING_TMP/nospace.txt
a = 9915
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify 2>&1 | FileCheck %s
// Test valueDestruction
.rawInput
extern "C" int printf(const char*,...);
class A {
  int m_A[2];
public:
  A() {}
  ~A() { printf("A::~A()\n"); }
};
class B : public A {
  int m_B[2];
public:
};
extern "C" {
  struct C {
    int m_C[4];
  };
  typedef struct {
    int C0, c1;
  } C2;
}
class D {
//CHECK-NOSPACE: (int) 9915
  int m_D[2];
public:
};
b = 9926
int gTest = 0;
class E {
public:
  ~E() { gTest = 101; }
};
.rawInput
A()
//CHECK-NOSPACE: (int) 9926
c = 9937
//CHECK-NOSPACE: (int) 9937
// Test redirect with & and toggle to out file.
.&>> $CLING_TMP/bothfile.txt
var = 999
//CHECK-REDIRECTBOTH: (int) 999
// Test that exiting in a redirected state will flush properly
.1> $CLING_TMP/anotheroutfile.txt
a = 710
//CHECK-REDIRECTANOTHER: (int) 710
b = 711
//CHECK-REDIRECTANOTHER: (int) 711
c = 712
//CHECK-REDIRECTANOTHER: (int) 712
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling 2>&1 | FileCheck %s
// This file should be used as regression test for the value printing subsystem
// Reproducers of fixed bugs should be put here
extern "C" int mustPrintFirst() { return 6; }
mustPrintFirst
Bvv.push_back(std::vector<bool>());
Bvv
// CHECK-NEXT: (std::vector<std::vector<bool> > &) { { false }, { false, true }, { false, true, true }, { false, true, true, true }, { false, true, true, true, false }, {} }
class CustomThing {
};
namespace cling {
  std::string printValue(const CustomThing *ptr) {
    return "";
  }
}
std::vector<CustomThing> A, B(1);
cling::printValue(&A) == cling::printValue(&B)
// CHECK-NEXT: (bool) false
std::tuple<> tA
// CHECK-NEXT: (std::tuple<> &) {}
std::map<int, int> M
// CHECK-NEXT: (std::map<int, int> &) {}
std::map<int, std::pair<int,int> > M2;
//      CHECK: (A) @0x{{[0-9a-f]+}}
// CHECK-NEXT: A::~A()
B()
// CHECK-NEXT: (B) @0x{{[0-9a-f]+}}
// CHECK-NEXT: A::~A()
C()
// CHECK-NEXT: (C) @0x{{[0-9a-f]+}}
C2()
// CHECK-NEXT: (C2) @0x{{[0-9a-f]+}}
C2 c = {1, 2}
// CHECK: (int (*)()) Function
// PR #93006
.rawInput 1
extern "C" int printf(const char* fmt, ...);
class A {
public:
  int Var;
  A(int arg) { Var = arg; }
  int someFunc(float) { return 42; }
  ~A() { printf("A d'tor\n"); }
};
const A& foo(const A& arg) { return arg; }
A foo2(const A& arg) { return A(42); }
.rawInput 0
foo(A(12)).Var
// CHECK-NEXT: (C2 &) @0x{{[0-9a-f]+}}
D()
// CHECK-NEXT: (D) @0x{{[0-9a-f]+}}
std::map<std::pair<std::string,bool>, std::pair<int,bool> > M3;
gTest
// CHECK-NEXT: 0
E()
// CHECK: (const int) 12
// CHECK: A d'tor
// End PR #93006
// myvector.end() failed to print (roottest/cling/stl/default/VectorSort.C)
foo2(A(42))
// CHECK-NEXT: (E) @0x{{[0-9a-f]+}}
gTest
// CHECK-NEXT: 101
// Don't call destructor on printed lambda
[] {}
// CHECK-NEXT: () @0x{{[0-9a-f]+}}
// expected-no-diagnostics
.q
// CHECK: (A) @0x{{[0-9a-f]+}}
//------------------------------------------------------------------------------
std::set<std::pair<int, std::string>> S;
// CLING - the C++ LLVM-based InterpreterG :)
// CHECK: A d'tor
//
 // Savannah #96523
// This file is dual-licensed: you can choose to license it under the University
int *p = (int*)0x123;
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// Windows wants -Wno-deprecated-declarations
//RUN: cat %s | %cling -Wno-deprecated-declarations -Xclang -verify 2>&1 | FileCheck %s
#include <stdlib.h>
p // CHECK: (int *) 0x123
const int *q = (int*)0x123;
q // CHECK: (const int *) 0x123 <invalid memory address>
0.00001234L // CHECK-NEXT: (long double) 1.2340000e-05L
// PR ROOT-5467
&A::someFunc // CHECK: (int (A::*)(float)) Function @0x{{[0-9a-f]+}}
nullptr // CHECK: (nullptr_t) nullptr
#ifdef _WIN32
true // CHECK: (bool) true
 extern "C" int SetConsoleOutputCP(unsigned int);
 extern "C" int strcmp(const char*, const char*);
#endif
static void setLang(const char* Lang) {
#ifdef _WIN32
  ::SetConsoleOutputCP(strcmp(Lang, "en_US.UTF-8")==0 ? 65001 : 20127);
#else
  ::setenv("LANG", Lang, 1);
#endif
}
setLang("en_US.UTF-8");
false // CHECK: (bool) false
const char* Data = (const char*) 0x01
unordered_multiset<float> {1} // ROOT-7310
// expected-error@2 {{use of undeclared identifier 'unordered_multiset'}}
// expected-error@2 {{expected '(' for function-style cast or type construction}}
// expected-error@2 {{initializer list cannot be used on the right hand side of operator '>'}}
#include <unordered_set>
std::map<std::string, std::map<int, std::pair<int,std::string>>> MM;
for (int i = 0; i < 5; ++i) {
  const std::string Str = std::to_string(i);
  M[i] = i+1;
  M2[i] = std::make_pair(i+1, i+2);
  M3[std::make_pair(Str, i%2)] = std::make_pair(i*10, i%3);
  S.insert(std::make_pair(i*10+4, Str));
  auto &MMv = MM[Str];
  for (int j = 0; j < 3; ++j) {
    MMv[j] = std::make_pair(j*3, Str + std::to_string(j*5));
  }
}
std::unordered_multiset<float> {1}
// CHECK: (const char *) 0x{{.+}} <invalid memory address>
std::string RawData("\x12""\x13");
cling::printValue(&RawData)[1]
// CHECK-NEXT: (char) '0x12'
cling::printValue(&RawData)[2]
// CHECK-NEXT: (char) '0x13'
RawData = "Line1\nLine2\rLine3";
cling::printValue(&RawData)[6]
// CHECK-NEXT: (char) '\n'
cling::printValue(&RawData)[12]
// CHECK-NEXT: (char) '\r'
cling::printValue(&RawData)[13]
// CHECK-NEXT: (char) 'L'
"Line1\nLine2\nLine3"
// CHECK-NEXT: (const char [18]) "Line1
// CHECK-NEXT: Line2
// CHECK-NEXT: Line3"
"\x12""\x13"
// CHECK: (const char [3]) "\x12\x13"
"ABCD" "\x10""\x15" "EFG"
// CHECK-NEXT: (const char [10]) "ABCD\x10\x15" "EFG"
"ENDWITH" "\x11""\x07"
// CHECK-NEXT: (const char [10]) "ENDWITH\x11\x07"
"\x03" "\x09" "BEGANWITH"
// CHECK-NEXT: (const char [12]) "\x03\x09" "BEGANWITH"
"1233123213\n\n\n\f234\x3"
// CHECK-NEXT: (const char [19]) "1233123213\x0a\x0a\x0a\x0c" "234\x03"
// Posing as UTF-8, but invalid
// https://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-test.txt
"\xea"
// FIXME: BROKEN_ON_LINUX-CHECK: (std::unordered_multiset<float>) { 1.00000f }
// ROOT-7426
#include <string>
#include <vector>
// CHECK-NEXT: (const char [2]) "\xea"
"\xea\xfb"
// CHECK-NEXT: (const char [3]) "\xea\xfb"
"\xfe\xfe\xff\xff"
// CHECK-NEXT: (const char [5]) "\xfe\xfe\xff\xff"
"\xfc\x80\x80\x80\x80\xaf"
// CHECK-NEXT: (const char [7]) "\xfc\x80\x80\x80\x80\xaf"
"\xfc\x83\xbf\xbf\xbf\xbf"
// CHECK-NEXT: (const char [7]) "\xfc\x83\xbf\xbf\xbf\xbf"
"\xed\xa0\x80"
// CHECK-NEXT: (const char [4]) "\xed\xa0\x80"
"\xed\xad\xbf"
// CHECK-NEXT: (const char [4]) "\xed\xad\xbf"
"\xed\xae\x80"
// CHECK-NEXT: (const char [4]) "\xed\xae\x80"
"\xed\xaf\xbf"
// CHECK-NEXT: (const char [4]) "\xed\xaf\xbf"
"\xed\xb0\x80"
// CHECK-NEXT: (const char [4]) "\xed\xb0\x80"
"\xed\xbe\x80"
// CHECK-NEXT: (const char [4]) "\xed\xbe\x80"
"\xed\xbf\xbf"
// CHECK-NEXT: (const char [4]) "\xed\xbf\xbf"
"\xed\xa0\x80\xed\xb0\x80"
// CHECK-NEXT: (const char [7]) "\xed\xa0\x80\xed\xb0\x80"
"\xed\xa0\x80\xed\xbf\xbf"
// CHECK-NEXT: (const char [7]) "\xed\xa0\x80\xed\xbf\xbf"
"\xed\xad\xbf\xed\xb0\x80"
// CHECK-NEXT: (const char [7]) "\xed\xad\xbf\xed\xb0\x80"
"\xed\xad\xbf\xed\xbf\xbf"
// CHECK-NEXT: (const char [7]) "\xed\xad\xbf\xed\xbf\xbf"
"\xed\xae\x80\xed\xb0\x80"
std::vector<std::string> a = { "a", "b", "c" } // CHECK: (std::vector<std::string> &) { "a", "b", "c" }
// CHECK-NEXT: (const char [7]) "\xed\xae\x80\xed\xb0\x80"
"\xed\xae\x80\xed\xbf\xbf"
// CHECK-NEXT: (const char [7]) "\xed\xae\x80\xed\xbf\xbf"
"\xed\xaf\xbf\xed\xb0\x80"
// CHECK-NEXT: (const char [7]) "\xed\xaf\xbf\xed\xb0\x80"
"\xed\xaf\xbf\xed\xbf\xbf"
// CHECK-NEXT: (const char [7]) "\xed\xaf\xbf\xed\xbf\xbf"
std::string(u8"UTF-8")
// CHECK-NEXT: (std::string) "UTF-8"
std::u16string(u"UTF-16 " u"\x394" u"\x3a6" u"\x3a9")
#include "clang/AST/Decl.h"
#include "clang/AST/PrettyPrinter.h"
#include <cstdio>
#include <string>
using namespace std;
using namespace llvm;
//
//  We need to fetch the global scope declaration,
//  otherwise known as the translation unit decl.
//
const cling::LookupHelper& lookup = gCling->getLookupHelper();
const clang::Decl* G = lookup.findScope("", cling::LookupHelper::WithDiagnostics);
printf("G: 0x%lx\n", (unsigned long) G);
//CHECK: G: 0x{{[1-9a-f][0-9a-f]*$}}
std::string buf;
clang::PrintingPolicy Policy(G->getASTContext().getPrintingPolicy());
a // CHECK: (std::vector<std::string> &) { "a", "b", "c" }
// CHECK-NEXT: (std::u16string) u"UTF-16 "
std::u32string(U"UTF-32 " U"\x262D" U"\x2615" U"\x265F")
#include <iostream>
#include <cstdarg>
a[0] // CHECK: ({{.*}} &) "a"
// ROOT-7918
struct Enumer {
#ifndef _WIN32
  // This variant fails on Windows, and seems conforming behaviour to do so
  enum H {  h = (unsigned long long )-1 };
#else
  enum H : unsigned long long { h = (unsigned long long )-1 };
#endif
};
Enumer::h
// CHECK: (Enumer::H) (Enumer::H::h) : (unsigned long{{( long)?}}) 18446744073709551615
// ROOT-7837
auto bla=[](double *x, double *par, int blub){return x[0]*blub;} // CHECK: ((lambda) &) @0x
#include <functional>
#include "cling/Interpreter/Value.h"
class MyClass { public:  MyClass(){ gCling->process("gCling->getVersion()");} };
MyClass *My = new MyClass(); // CHECK: (const char *) "{{.*}}"
// CHECK-NEXT: (std::u32string) U"UTF-32 "
std::u32string(U"UTF-32 " U"\u2616\u2615\u2614")
#include <stdio.h>
gCling->declare("int print() { printf(\"print is run.\\n\"); return 1; }");
using namespace std::placeholders;
auto fn_moo = std::bind (bla, _1,_2,10) // CHECK: ERROR in cling's callPrintValue(): missing value string.
cling::Value V;
gCling->process("int a = print();",&V);
.q
//CHECK: print is run.
gCling->process("a", &V);
// CHECK-NEXT: (std::u32string) U"UTF-32 "
std::wstring(L"wide")
//CHECK: (int) 1
// CHECK-NEXT: (std::wstring) L"wide"
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
u"16strliteral"
gCling->process("a;", &V);
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling | FileCheck %s
template<int n> struct F{
  enum {RET=F<n-1>::RET*n} ;
};
template<> struct F<0> {
  enum {RET = 1};
};
F<7>::RET
// CHECK-NEXT: (const char16_t [13]) u"16strliteral"
U"32literalstr"
//CHECK-NOT: print is run.
// End PR #96277
// PR #98146
gCling->process("\"Root\"", &V);
// CHECK-NEXT: (const char32_t [13]) U"32literalstr"
L"wcharliteral"
// CHECK-NEXT: (const wchar_t [13]) L"wcharliteral"
// Unicode shouldn't do character level access, return the raw codepages
const char16_t* utf16 = u"16str";
utf16[0]
// CHECK: (const char [5]) "Root"
V
// CHECK-NEXT: (const char16_t) u'\u0031'
const char32_t* utf32 = U"32str";
utf32[1]
// CHECK-NEXT: (const char32_t) U'\U00000032'
// wchar_t doesn't guarantee a size
const wchar_t* wides = L"wide";
wides[3]
// CHECK: (cling::Value &) boxes [(const char [5]) "Root"]
// End PR #98146
.rawInput 1
typedef enum {k1 = 0, k2} enumName;
enumName var = k1;
.rawInput 0
var
// CHECK: (enumName) (k1) : ({{(unsigned )?}}int) 0
const enumName constVar = (enumName) 1 // k2 is invisible!
// CHECK-NEXT: (const wchar_t) L'\x{{0+}}65'
// ASCII output
setLang("");
u"UTF-16 " u"\x394" u"\x3a6" u"\x3a9"
// CHECK: (const enumName) (k2) : ({{(unsigned )?}}int) 1
// ROOT-8036: check that library symbols do not override interpreter symbols
int step = 10 // CHECK: (int) 10
step // CHECK: (int) 10
gCling->process("#ifdef __UNDEFINED__\n42\n#endif")
// CHECK-NEXT: (const char16_t [11]) u"UTF-16 \u0394\u03a6\u03a9"
U"UTF-32\x262D\x2615\x265F"
//CHECK: (cling::Interpreter::CompilationResult) (cling::Interpreter::CompilationResult::kSuccess) : ({{(unsigned )?}}int) 0
// User input variants of above:
#ifdef NOTDEFINED
 gCling->echo("9")
#else
 gCling->echo("12")
#endif
// CHECK-NEXT: (const char32_t [10]) U"UTF-32\u262d\u2615\u265f"
U"UTF-32\x2616\x2615\x2614"
// CHECK-NEXT: (const char32_t [10]) U"UTF-32\u2616\u2615\u2614"
"\u20ac"
//CHECK: (int) 12
//CHECK: (cling::Interpreter::CompilationResult) (cling::Interpreter::CompilationResult::kSuccess) : ({{(unsigned )?}}int) 0
#ifdef __CLING__
 gCling->echo("19");
#else
 gCling->echo("156")
#endif
// CHECk-NEXT: (const char [4]) "\xe2\x82\xac"
"\u2620\u2603\u2368"
// CHECk-NEXT: (const char [10]) "\xe2\x98\xa0\xe2\x98\x83\xe2\x8d\xa8"
#include <stdio.h>
#include <vector>
//CHECK: (int) 19
// ROOT-8300
struct B { static void *fgStaticVar; B(){ printf("B::B()\n"); } };
B b; // CHECK: B::B()
// ROOT-7857
template <class T> void tfunc(T) {}
struct ROOT7857{
  void func() { tfunc((ROOT7857*)0); }
};
ROOT7857* root7857;
// ROOT-5248
class MyClass;
extern MyClass* my;
class MyClass {public: MyClass* getMyClass() {return 0;}} cl;
MyClass* my = cl.getMyClass();
void simple_printf(const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    while (*fmt != '\0') {
        if (*fmt == 'd') {
            int i = va_arg(args, int);
            std::cout << i << '\n';
        } else if (*fmt == 'c') {
            // note automatic conversion to integral type
            int c = va_arg(args, int);
            std::cout << static_cast<char>(c) << '\n';
        } else if (*fmt == 'f') {
            double d = va_arg(args, double);
            std::cout << d << '\n';
        }
        ++fmt;
    }
    va_end(args);
}
const clang::FunctionDecl* variadicF = lookup.findFunctionArgs(G, "simple_printf", "const char*, ...", cling::LookupHelper::WithDiagnostics);
printf("simple_printf: 0x%lx\n", (unsigned long) variadicF);
//CHECK-NEXT: simple_printf: 0x{{[1-9a-f][0-9a-f]*$}}
.q
// expected-error {{use of undeclared identifier 'lambda'}}
// expected-error {{expected expression}}
// expected-error {{type name requires a specifier or qualifier}}
// expected-error {{expected ')'}}
// expected-note  {{to match this '('}}
// Make sure cling survives
12 // CHECK: (int) 12
// ROOT-8077
.rawInput 1
#include <string>
void f(std::string) {}
.rawInput 0
f // CHECK: (void (*)(std::string)) Function @0x{{[0-9a-f]+}}
// CHECK: at input_line_{{[0-9].*}}:1:
// CHECK: void f(std::string) {}
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
// author:  Danilo Piparo <danilo.piparo@cern.ch>
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling | FileCheck %s
#include <utility>
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
//RUN: cat %s | %cling -Xclang -verify 2>&1
// Test unknownTypeTest
typedef float vec4f __attribute__((ext_vector_type(4)));
vec4f testVar;
testVar // expected-error {{float __attribute__((ext_vector_type(4))) has unknown type, which is not supported for this kind of declaration}}
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling | FileCheck %s
static void ReadData(std::vector<char>& FData) {
#include <cstdlib>
  FILE *File = ::fopen("Strings.dat", "r");
  if (File) {
    ::fseek(File, 0L, SEEK_END);
    const size_t N = ::ftell(File);
    FData.reserve(N+1);
    FData.resize(N);
    ::fseek(File, 0L, SEEK_SET);
    ::fread(&FData[0], N, 1, File);
    ::fclose(File);
  }
  FData.push_back(0);
}
#include <tuple>
M
extern "C" int printf(const char* fmt, ...);
#define MYMACRO(v) if (v) { printf("string:%%s\n", v);}
#undef MYMACRO
int MYMACRO = 42; // expected-warning {{expression result unused}}
printf("MYMACRO=%d\n", MYMACRO); // CHECK: MYMACRO=42
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -I%p | FileCheck %s
#include <cmath>
std::vector<char> FDat;
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify
struct {int j;}; // expected-error {{anonymous structs and classes must be class members}}
// ROOT-7610
do { int a = 0; } while(a==0); // expected-error {{use of undeclared identifier 'a'}}
.q
// CHECK-NEXT: (std::map<int, int> &) { 0 => 1, 1 => 2, 2 => 3, 3 => 4, 4 => 5 }
M2
ReadData(FDat);
// CHECK-NEXT: (std::map<int, std::pair<int, int> > &) { 0 => {1 , 2}, 1 => {2 , 3}, 2 => {3 , 4}, 3 => {4 , 5}, 4 => {5 , 6} }
M3
struct S{int i;} ss;
S s = {12 };
struct U{void f() const {};} uu;
struct V{V(): v(12) {}; int v; } vv;
int i = 12;
float f = sin(12);
int j = i;
extern "C" int printf(const char* fmt, ...);
printf("j=%d\n",j); // CHECK:j=12
#include <string>
(char*)FDat.data()
// CHECk-NEXT: (char *) "deadbeeffeedfacec0ffeedebac1eecafebabe\xde\xad\xbe\xef\xfe\xed\xfa\xce\xc0\xff\xee\xde\xba\xc1\xee\xca\xfe\xba\xbe"
// expected-no-diagnostics
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// CHECK-NEXT: (std::map<std::pair<std::string, bool>, std::pair<int, bool> > &) { {"0" , false} => {0 , false}, {"1" , true} => {10 , true}, {"2" , false} => {20 , true}, {"3" , true} => {30 , false}, {"4" , false} => {40 , true} }
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling | FileCheck %s
S
extern "C" int printf(const char*,...);
extern "C" void exit(int);
int i;
struct S{int i;} s;
i = 42;
printf("i=%d\n",i); // CHECK: i=42
gCling->getDefaultOptLevel()
if (i != 42) exit(1);
.q
// CHECK: (int) 0
(int)gCling->getLatestTransaction()->getCompilationOpts().OptLevel
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling | FileCheck %s
// Checks:
// Savannah #99210 https://savannah.cern.ch/bugs/index.php?99210
// Savannah #99234 https://savannah.cern.ch/bugs/?99234
// Let's start with simpler example pointing out the issue:
int i = 1; i++; int j = i;
// CHECK-NEXT: (int) 0
{
#pragma cling optimize(0)
  printf("Transaction OptLevel=%d\n", (int)gCling->getLatestTransaction()->getCompilationOpts().OptLevel);
}
j
// CHECK-NEXT: Transaction OptLevel=0
{
#pragma cling optimize(1)
  printf("Transaction OptLevel=%d\n", (int)gCling->getLatestTransaction()->getCompilationOpts().OptLevel);
}
// CHECK-NEXT: (std::set<std::pair<int, std::string> > &) { {4 , "0"}, {14 , "1"}, {24 , "2"}, {34 , "3"}, {44 , "4"} }
MM
// CHECK-NEXT: Transaction OptLevel=1
{
#pragma cling optimize(2)
  printf("Transaction OptLevel=%d\n", (int)gCling->getLatestTransaction()->getCompilationOpts().OptLevel);
}
// CHECK-NEXT: Transaction OptLevel=2
{
#pragma cling optimize(2)
// CHECK-NEXT: cling::PHOptLevel: conflicting `#pragma cling optimize` directives: was already set to 2
#pragma cling optimize(1)
// CHECK-NEXT: Setting to lower value of 1
#pragma cling optimize(2)
// CHECK-NEXT: cling::PHOptLevel: conflicting `#pragma cling optimize` directives: was already set to 1
// CHECK-NEXT: Ignoring higher value of 2
  printf("Transaction OptLevel=%d\n", (int)gCling->getLatestTransaction()->getCompilationOpts().OptLevel);
}
// CHECK-NEXT: Transaction OptLevel=1
.O
// CHECK-NEXT: Current cling optimization level: 0
// No parenthesis
{
#pragma cling optimize 1
  printf("Transaction OptLevel=%d\n", (int)gCling->getLatestTransaction()->getCompilationOpts().OptLevel);
}
// CHECK-NEXT: Transaction OptLevel=1
// Full functional style
{
#pragma cling(optimize, 3)
  printf("Transaction OptLevel=%d\n", (int)gCling->getLatestTransaction()->getCompilationOpts().OptLevel);
}
// CHECK-NEXT: Transaction OptLevel=3
// Invalid token
#pragma cling optimize Invalid // expected-error {{expected argument after optimize}}
.q
// (std::map<std::string, std::map<int, std::pair<int, std::string> > > &) { "0" => { 0 => {0 , "00"}, 1 => {3 , "05"}, 2 => {6 , "010"} }, "1" => { 0 => {0 , "10"}, 1 => {3 , "15"}, 2 => {6 , "110"} }, "2" => { 0 => {0 , "20"}, 1 => {3 , "25"}, 2 => {6 , "210"} }, "3" => { 0 => {0 , "30"}, 1 => {3 , "35"}, 2 => {6 , "310"} }, "4" => { 0 => {0 , "40"}, 1 => {3 , "45"}, 2 => {6 , "410"} } }
// expected-no-diagnostics
.q
//CHECK: (F<7>::(anonymous)) (F<7>::RET) : ({{(unsigned )?}}int) 5040
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -I%p 2>&1 | FileCheck %s
// Tests the ability of cling to host itself. We can have cling instances in
// cling's runtime. This is important for people, who use cling embedded in
// their frameworks.
#include "cling/Interpreter/Interpreter.h"
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling -Xclang -verify 2>&1 | FileCheck %s
int example() { } // expected-error {{control reaches end of non-void function}}
// Make FileCheck happy with having at least one positive rule:
int a = 5
std::make_pair("s",10)
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling
// RUN: cat %s | %cling 2>&1 | FileCheck %s
// Test handling and recovery from calling an unresolved symbol.
extern int foo(); // extern C++
void bar() { foo(); }
extern "C" int functionWithoutDefinition();
int i = 42;
i = functionWithoutDefinition();
// CHECK: IncrementalExecutor::executeFunction: symbol 'functionWithoutDefinition' unresolved while linking
i = foo();
extern "C" int printf(const char* fmt, ...);
printf("got i=%d\n", i); // CHECK: got i=42
int a = 12// CHECK: (int) 12
//CHECK: (std::pair<{{.+char.+\[2\].*,.*int.*}}>) { "s", 10 }
std::make_pair(4L,'c')
std::string str("abc");
printf("str=%s\n",str.c_str()); // CHECK: str=abc
.q
//CHECK: (std::pair<{{.*long.*,.*char.*}}>) { 4, 'c' }
std::make_tuple()
//CHECK: (std::tuple<>) {}
std::make_tuple(2)
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %built_cling -fno-rtti | FileCheck %s
// The test verifies the expected behavior in cling::utils::Transform class,
// which is supposed to provide different transformation of AST nodes and types.
#include "cling/Interpreter/Interpreter.h"
//CHECK: (std::tuple<{{.*int.*}}>) { 2 }
std::make_tuple(1.2f)
//CHECK: (std::tuple<{{.*float.*}}>) { 1.20000f }
std::make_tuple(1, std::make_tuple(1, 'c'))
// CHECK: (int) 2
extern "C" int printf(const char*,...);
.rawInput
class RAII {
public:
   RAII(int i) { I = new int(i); printf("RAII%d\n", ++InstanceCount); };
   int incr() { return ++(*I); }
   int get() { return *I; }
   ~RAII() { delete I; printf("~RAII%d\n", InstanceCount--); }
private:
   RAII(RAII&);
   RAII& operator=(RAII);
   int* I;
   static int InstanceCount; // will notice object copy
};
int RAII::InstanceCount = 0;
.rawInput
// This works because each line ends up in a separate wrapper
RAII R(12); // CHECK: RAII1
R.get();
int res = R.incr() // CHECK: 13
// This does not work because the decls and their inits are run before the
// call to R2.incr(), i.e. the second statement in the line.
// Savannah #99210 https://savannah.cern.ch/bugs/index.php?99210
RAII R2(42);R2.incr();int res2 = R2.get()
// CHECK: RAII2
// CHECK: 43
.q
//CHECK: (std::tuple<{{.*int.*,.*std::tuple<.*int,.*char.*>.*}}>) { 1, { 1, 'c' } }
.q
// CHECK: (int) 5
.q
foo()
// CHECK: IncrementalExecutor::executeFunction: symbol '{{.*}}foo{{.*}}' unresolved
functionWithoutDefinition();
// CHECK: IncrementalExecutor::executeFunction: symbol 'functionWithoutDefinition' unresolved while linking
i = 13 //CHECK: (int) 13
.q
//------------------------------------------------------------------------------
// CLING - the C++ LLVM-based InterpreterG :)
//
// This file is dual-licensed: you can choose to license it under the University
// of Illinois Open Source License or the GNU Lesser General Public License. See
// LICENSE.TXT for details.
//------------------------------------------------------------------------------
// RUN: cat %s | %cling
// RUN: cat %s | %cling 2>&1 | FileCheck %s
// Test handling and recovery from calling an unresolved symbol.
extern int foo(); // extern C++
void bar() { foo(); }
extern "C" int functionWithoutDefinition();
int i = 42;
i = functionWithoutDefinition();
// CHECK: IncrementalExecutor::executeFunction: symbol 'functionWithoutDefinition' unresolved while linking
i = foo();
extern "C" int printf(const char* fmt, ...);
printf("got i=%d\n", i); // CHECK: got i=42
int a = 12// CHECK: (int) 12
foo()
// CHECK: IncrementalExecutor::executeFunction: symbol '{{.*}}foo{{.*}}' unresolved
functionWithoutDefinition();
// CHECK: IncrementalExecutor::executeFunction: symbol 'functionWithoutDefinition' unresolved while linking
i = 13 //CHECK: (int) 13
.q
gCling->getDefaultOptLevel() // CHECK: (int) 0
.O // CHECK-NEXT: Current cling optimization level: 0
(int)gCling->getLatestTransaction()->getCompilationOpts().OptLevel // CHECK-NEXT: (int) 0
.O 2
gCling->getDefaultOptLevel() // CHECK-NEXT: (int) 2
.O // CHECK-NEXT: Current cling optimization level: 2
#pragma cling optimize(1) // shouldn't change default but only current transaction (which is empty except this pragma)
gCling->getDefaultOptLevel() // CHECK-NEXT: (int) 2
.O // CHECK-NEXT: Current cling optimization level: 2
gCling->process("const char * const argV = \"cling\";");
gCling->process("cling::Interpreter *DefaultInterp;");
gCling->process("DefaultInterp = new cling::Interpreter(1, &argV);");
gCling->process("DefaultInterp->process(\"#include \\\"cling/Interpreter/Interpreter.h\\\"\");");
#include "cling/Interpreter/LookupHelper.h"
#include "cling/Utils/AST.h"
#include "clang/AST/Type.h"
#include "clang/AST/ASTContext.h"
gCling->process("DefaultInterp->process(\"std::string s; gCling->createUniqueName(s); s.c_str()\");");
// CHECK: ({{[^)]+}}) "__cling_Un1Qu31"
.q
#include "llvm/ADT/SmallSet.h"
#include "clang/Sema/Sema.h"
.rawInput 1
#include <vector>
#include <iostream>
typedef double Double32_t;
typedef int Int_t;
typedef long Long_t;
typedef Int_t* IntPtr_t;
typedef Int_t& IntRef_t;
template <typename T> class A {};
template <typename T, typename U> class B {};
template <typename T, typename U> class C {};
typedef C<A<B<Double32_t, Int_t> >, Double32_t > CTD;
typedef C<A<B<const Double32_t, const Int_t> >, Double32_t > CTDConst;
template <typename key, typename value, typename compare_operation = std::less<key>, typename alloc = std::allocator<std::pair<const key, value> > > class cmap { key fKey; const value fValue; alloc fAlloc; public: cmap() : fValue(0) {} };
   // : public std::map<key, value, compare_operation, alloc> {
template <typename key, typename value = const key> class mypair { public: key fKey; value fValue; };
#include <string>
namespace Details {
  class Impl {};
}
// To insure instantiation.
// typedef std::pair<Details::Impl,std::vector<Details::Impl> > details_pairs;
namespace NS {
  template <typename T, int size = 0> class ArrayType {};
  template <typename T> class Array {};
  template <typename T> class Container {
  public:
    class Content {};
    typedef T Value_t;
    typedef Content Content_t;
    typedef ::Details::Impl Impl_t;
  };
  template <typename T> class TDataPoint {};
  typedef TDataPoint<float> TDataPointF;
  typedef TDataPoint<Double32_t> TDataPointD32;
  const int typeN =1;
  typedef ArrayType<float, typeN + 1> FArray;
  typedef int IntNS_t;
}
// Anonymous namespace
namespace {
  class InsideAnonymous {
  };
}
using namespace std;
class Embedded_objects {
public:
  enum Eenum {
    kEnumConst=16
  };
  class EmbeddedClasses;
  typedef EmbeddedClasses EmbeddedTypedef;
  class EmbeddedClasses {
  public:
    class Embedded1 {};
    class Embedded2 {};
    class Embedded3 {};
    class Embedded4 {};
    class Embedded5 {};
    class Embedded6 {};
  };
  EmbeddedClasses m_embedded;
  EmbeddedClasses::Embedded1 m_emb1;
  EmbeddedClasses::Embedded2 m_emb2;
  EmbeddedClasses::Embedded3 m_emb3;
  EmbeddedTypedef::Embedded4 m_emb4;
  Embedded_objects::EmbeddedClasses::Embedded5 m_emb5;
  Embedded_objects::EmbeddedTypedef::Embedded6 m_emb6;
  typedef std::vector<int> vecint;
  vecint* m_iter;
  const Eenum m_enum;
  typedef vector<int> vecint2;
  vecint2* m_iter2;
  vector<Double32_t> vd32a;
  typedef vector<Double32_t> vecd32t1;
  vecd32t1 vd32b;
  using vecd32t2 = vector<Double32_t>;
  vecd32t2 vd32c;
  template <typename T> using myvector = std::vector<T>;
  myvector<float> vfa;
  // Not yet, the desugar of template alias do not keep the opaque typedef.
  // myvector<Double32_t> vd32d;
  Double32_t *p1;
  template<class T> using ptr = T*;
  ptr<float> p2;
  // Not yet, the desugar of template alias do not keep the opaque typedef.
  // ptr<Double32_t> p3;
  typedef B<Int_t,Double32_t> t1;
  typedef t1* t2;
  typedef t2* t3;
  typedef t3 t4[3];
  typedef t4 t5[4];
  typedef t5& t6;
  typedef t1& t7;
  typedef t2& t8;
  typedef t2  t9;
  typedef t5* t10;
  t1 d1;
  t2 d2;
  t2 d2_1[5];
  t3 d3;
  t4 d4;
  t5 d5;
  t6 d6;
  t7 d7;
  t8 d8;
  t9 d9;
  t10 d10;
};
namespace NS1 {
  namespace NS2 {
    namespace NS3 {
      inline namespace InlinedNamespace {
        class InsideInline {};
      }
      class Point {};
      class Inner3 {
      public:
        Point p1;
        NS3::Point p2;
        ::NS1::NS2::NS3::Point p3;
        InsideInline p4;
      };
    }
  }
}
.rawInput 0
const cling::LookupHelper& lookup = gCling->getLookupHelper();
cling::LookupHelper::DiagSetting diags = cling::LookupHelper::WithDiagnostics;
clang::Sema* Sema = &gCling->getSema();
const clang::ASTContext& Ctx = gCling->getSema().getASTContext();
cling::utils::Transform::Config transConfig;
using namespace cling::utils;
transConfig.m_toSkip.insert(Lookup::Named(Sema, "Double32_t"));
using namespace std;
transConfig.m_toSkip.insert(Lookup::Named(Sema, "string"));
transConfig.m_toSkip.insert(Lookup::Named(Sema, "string", Lookup::Namespace(Sema, "std")));
const clang::Type* t = 0;
clang::QualType QT;
using namespace cling::utils;
// Test the behavior on a simple class
lookup.findScope("Details::Impl", diags, &t);
QT = clang::QualType(t, 0);
//QT.getAsString().c_str()
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "Details::Impl"
// Test the behavior for a class inside an anonymous namespace
lookup.findScope("InsideAnonymous", diags, &t);
QT = clang::QualType(t, 0);
//QT.getAsString().c_str()c
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "class (anonymous namespace)::InsideAnonymous"
// The above result is not quite want we want, so the client must using
// the following:
// The scope suppression is required for getting rid of the anonymous part of the name of a class defined in an anonymous namespace.
// This gives us more control vs not using the clang::ElaboratedType and relying on the Policy.SuppressUnwrittenScope which would
// strip both the anonymous and the inline namespace names (and we probably do not want the later to be suppressed).
clang::PrintingPolicy Policy(Ctx.getPrintingPolicy());
Policy.SuppressTagKeyword = true; // Never get the class or struct keyword
Policy.SuppressScope = true;      // Force the scope to be coming from a clang::ElaboratedType.
std::string name;
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsStringInternal(name,Policy);
name.c_str()
// CHECK: ({{[^)]+}}) "InsideAnonymous"
// Test desugaring pointers types:
QT = lookup.findType("Int_t*", diags);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK:({{[^)]+}}) "int *"
QT = lookup.findType("const IntPtr_t*", diags);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK:({{[^)]+}}) "int *const *"
// Test desugaring reference (both r- or l- value) types:
QT = lookup.findType("const IntPtr_t&", diags);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK:({{[^)]+}}) "int *const &"
//TODO: QT = lookup.findType("IntPtr_t[32], diags");
// To do: findType does not return the const below:
// Test desugaring reference (both r- or l- value) types:
// QT = lookup.findType("const IntRef_t", diags);
// Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// should print:({{[^)]+}}) "int &const"
// but this is actually an illegal type:
// C++ [dcl.ref]p1:
//   Cv-qualified references are ill-formed except when the
//   cv-qualifiers are introduced through the use of a typedef
//   (7.1.3) or of a template type argument (14.3), in which
//   case the cv-qualifiers are ignored.
// So the following is the right behavior:
// Will issue
// "'const' qualifier on reference type 'IntRef_t' (aka 'int &') has no effect"
// thus suppress diagnostics
QT = lookup.findType("const IntRef_t", cling::LookupHelper::NoDiagnostics);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "int &"
// Test desugaring reference (both r- or l- value) types:
QT = lookup.findType("IntRef_t", diags);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK:({{[^)]+}}) "int &"
//Desugar template parameters:
lookup.findScope("A<B<Double32_t, Int_t*> >", diags, &t);
QT = clang::QualType(t, 0);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK:({{[^)]+}}) "A<B<Double32_t, int *> >"
lookup.findScope("A<B<Double32_t, std::size_t*> >", diags, &t);
QT = clang::QualType(t, 0);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK:({{[^)]+}}) "A<B<Double32_t, unsigned {{long|int|long long}} *> >"
lookup.findScope("CTD", diags, &t);
QT = clang::QualType(t, 0);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "C<A<B<Double32_t, int> >, Double32_t>"
lookup.findScope("CTDConst", diags, &t);
QT = clang::QualType(t, 0);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "C<A<B<const Double32_t, const int> >, Double32_t>"
lookup.findScope("std::pair<const std::string,int>", diags, &t);
QT = clang::QualType(t, 0);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "std::pair<const std::string, int>"
lookup.findScope("NS::Array<NS::ArrayType<double> >", diags, &t);
QT = clang::QualType(t, 0);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "NS::Array<NS::ArrayType<double> >"
lookup.findScope("NS::Array<NS::ArrayType<Double32_t> >", diags, &t);
QT = clang::QualType(t, 0);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "NS::Array<NS::ArrayType<Double32_t> >"
lookup.findScope("NS::Container<Long_t>::Content", diags, &t);
QT = clang::QualType(t, 0);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "NS::Container<long>::Content"
QT = lookup.findType("NS::Container<Long_t>::Value_t", diags);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "long"
lookup.findScope("NS::Container<Long_t>::Content_t", diags, &t);
QT = clang::QualType(t, 0);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "NS::Container<long>::Content"
lookup.findScope("NS::Container<Long_t>::Impl_t", diags, &t);
QT = clang::QualType(t, 0);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "Details::Impl"
lookup.findScope("NS::Container<Double32_t>::Content", diags, &t);
QT = clang::QualType(t, 0);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "NS::Container<Double32_t>::Content"
QT = lookup.findType("NS::Container<Double32_t>::Value_t", diags);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "double"
// Really we would want it to say Double32_t but oh well.
lookup.findScope("NS::Container<Double32_t>::Content_t", diags, &t);
QT = clang::QualType(t, 0);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "NS::Container<Double32_t>::Content"
lookup.findScope("NS::Container<Double32_t>::Impl_t", diags, &t);
QT = clang::QualType(t, 0);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "Details::Impl"
lookup.findScope("NS::TDataPointF", diags, &t);
QT = clang::QualType(t, 0);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "NS::TDataPoint<float>"
lookup.findScope("NS::TDataPointD32", diags, &t);
QT = clang::QualType(t, 0);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "NS::TDataPoint<Double32_t>"
lookup.findScope("NS::ArrayType<float,1>", diags, &t);
QT = clang::QualType(t, 0);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "NS::ArrayType<float, 1>"
lookup.findScope("NS::FArray", diags, &t);
QT = clang::QualType(t, 0);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "NS::ArrayType<float, 2>"
QT = lookup.findType("const NS::IntNS_t", diags);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "const int"
lookup.findScope("vector<Details::Impl>::value_type", diags, &t);
QT = clang::QualType(t, 0);
Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str()
// CHECK: ({{[^)]+}}) "Details::Impl"
const clang::Decl*decl=lookup.findScope("Embedded_objects", diags,&t);
if (decl) {
  const clang::CXXRecordDecl *cxxdecl
    = llvm::dyn_cast<clang::CXXRecordDecl>(decl);
  if (cxxdecl) {
    clang::DeclContext::decl_iterator iter = cxxdecl->decls_begin();
    while ( *iter ) {
      const clang::Decl *mdecl = *iter;
      if (const clang::ValueDecl *vd = llvm::dyn_cast<clang::ValueDecl>(mdecl)) {
        clang::QualType vdType = vd->getType();
        name.clear();
        Transform::GetPartiallyDesugaredType(Ctx,vdType,transConfig).getAsStringInternal(name,Policy);
        std::cout << name.c_str() << std::endl;
      }
      ++iter;
    }
  }
}
// CHECK: Embedded_objects::EmbeddedClasses
// CHECK: Embedded_objects::EmbeddedClasses::Embedded1
// CHECK: Embedded_objects::EmbeddedClasses::Embedded2
// CHECK: Embedded_objects::EmbeddedClasses::Embedded3
// CHECK: Embedded_objects::EmbeddedClasses::Embedded4
// CHECK: Embedded_objects::EmbeddedClasses::Embedded5
// CHECK: Embedded_objects::EmbeddedClasses::Embedded6
// CHECK: std::vector<int> *
// CHECK: const Embedded_objects::Eenum
// CHECK: std::vector<int> *
// CHECK: std::vector<Double32_t>
// CHECK: std::vector<Double32_t>
// CHECK: std::vector<Double32_t>
// CHECK: std::vector<float>
// NOT-YET-CHECK: std::vector<Double32_t>
// CHECK: Double32_t *
// CHECK: float *
// NOT-YET-CHECK: Double32_t *
// CHECK: B<int, Double32_t>
// CHECK: B<int, Double32_t> *
// CHECK: B<int, Double32_t> *[5]
// CHECK: B<int, Double32_t> **
// CHECK: B<int, Double32_t> **[3]
// CHECK: B<int, Double32_t> **[4][3]
// CHECK: B<int, Double32_t> **(&)[4][3]
// CHECK: B<int, Double32_t> &
// CHECK: B<int, Double32_t> *&
// CHECK: B<int, Double32_t> *
// CHECK: B<int, Double32_t> **(*)[4][3]
// In the partial desugaring add support for the case where we have a type
// that point to an already completely desugared template instantiation in
// which case the type is a RecordDecl rather than a TemplateInstantationType
decl = lookup.findScope("std::pair<Details::Impl,std::vector<Details::Impl> >", diags,&t);
QT = clang::QualType(t, 0);
std::cout << Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str() << std::endl;
// CHECK: std::pair<Details::Impl, std::vector<Details::Impl> >
if (const clang::RecordDecl *rdecl = llvm::dyn_cast_or_null<clang::RecordDecl>(decl)) {
  clang::RecordDecl::field_iterator field_iter = rdecl->field_begin();
  // For some reason we can not call field_end:
  // cling: root/interpreter/llvm/src/tools/clang/lib/CodeGen/CGCall.cpp:1839: void checkArgMatches(llvm::Value*, unsigned int&, llvm::FunctionType*): Assertion `Elt->getType() == FTy->getParamType(ArgNo)' failed.
  // so just 'guess' the size
  int i = 0;
  while( i < 2 )  {
    name.clear();
    clang::QualType fdType = field_iter->getType();
    Transform::GetPartiallyDesugaredType(Ctx,fdType,transConfig).getAsStringInternal(name,Policy);
    std::cout << name.c_str() << std::endl;
    ++field_iter;
    ++i;
  }
}
// CHECK: Details::Impl
// CHECK: std::vector<Details::Impl, std::allocator<Details::Impl> >
decl=lookup.findScope("NS1::NS2::NS3::Inner3", diags,&t);
if (decl) {
  const clang::CXXRecordDecl *cxxdecl
  = llvm::dyn_cast<clang::CXXRecordDecl>(decl);
  if (cxxdecl) {
    clang::DeclContext::decl_iterator iter = cxxdecl->decls_begin();
    while ( *iter ) {
      const clang::Decl *mdecl = *iter;
      if (const clang::ValueDecl *vd = llvm::dyn_cast<clang::ValueDecl>(mdecl)) {
        clang::QualType vdType = vd->getType();
        name.clear();
        Transform::GetPartiallyDesugaredType(Ctx,vdType,transConfig).getAsStringInternal(name,Policy);
        std::cout << name.c_str() << std::endl;
      }
      ++iter;
    }
  }
}
// CHECK: NS1::NS2::NS3::Point
// CHECK: NS1::NS2::NS3::Point
// CHECK: NS1::NS2::NS3::Point
decl = lookup.findScope("cmap<volatile int,volatile int>", diags,&t);
QT = clang::QualType(t, 0);
std::cout << Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str() << std::endl;
if (const clang::RecordDecl *rdecl = llvm::dyn_cast_or_null<clang::RecordDecl>(decl)) {
  QT = clang::QualType(rdecl->getTypeForDecl(), 0);
  std::cout << Transform::GetPartiallyDesugaredType(Ctx, QT, transConfig).getAsString().c_str() << std::endl;
  clang::RecordDecl::field_iterator field_iter = rdecl->field_begin();
  // For some reason we can not call field_end:
  // cling: root/interpreter/llvm/src/tools/clang/lib/CodeGen/CGCall.cpp:1839: void checkArgMatches(llvm::Value*, unsigned int&, llvm::FunctionType*): Assertion `Elt->getType() == FTy->getParamType(ArgNo)' failed.
  // so just 'guess' the size
  int i = 0;
  while( i < 2 )  {
    name.clear();
    clang::QualType fdType = field_iter->getType();
    Transform::GetPartiallyDesugaredType(Ctx,fdType,transConfig).getAsStringInternal(name,Policy);
    std::cout << name.c_str() << std::endl;
    ++field_iter;
    ++i;
  }
}
// CHECK: cmap<volatile int, volatile int>
// CHECK: cmap<volatile int, volatile int, std::less<volatile int>, std::allocator<std::pair<const volatile int, volatile int> > >
// CHECK: volatile int
// CHECK: const volatile int
.q
#include <iostream>
#include "xtensor/xarray.hpp"
#include <xtensor/xarray.hpp>
.q
help
.q
#include <iostream>
#include <xtensor/xarray.hpp>
#include <xtensor/xio.hpp>
xt::xarray<double> arr1 {{1.0, 2.0, 3.0}, {2.0, 5.0, 7.0}, {2.0, 5.0, 7.0}};
xt::xarray<double> arr2 {5.0, 6.0, 7.0};
xt::xarray<double> res = xt::view(arr1, 1) + arr2;
std::cout << res;
std::cout << "foo" << endl;
std::cout << "foo" << std:endl;
std::cout << "foo" << std::endl;
std::cout << res;
xt::xarray<int> arr {1, 2, 3, 4, 5, 6, 7, 8, 9};
arr.reshape({3, 3});
std::cout << arr;
.q
#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/depth_first_search.hpp>
#include <iostream>
using namespace std;
typedef boost::property<boost::edge_weight_t, int> EdgeWeightProperty;
typedef boost::adjacency_list < boost::listS, boost::vecS, boost::undirectedS, boost::no_property, EdgeWeightProperty> mygraph;
class custom_dfs_visitor : public boost::default_dfs_visitor {
public:
template < typename boost::Vertex, typename boost::Graph > void discover_vertex(boost::Vertex u, const boost::Graph & g) const {
std::cout << "At " << u << std::endl;
}
template < typename boost::Edge, typename boost::Graph > void examine_edge(boost::Edge e, const boost::Graph& g) const {
std::cout << "Examining edges " << e << std::endl;
}
}
class custom_dfs_visitor : public boost::default_dfs_visitor {
public:
template < typename Vertex, typename Graph > void discover_vertex(Vertex u, const Graph & g) const {
std::cout << "At " << u << std::endl;
}
template < typename Edge, typename Graph > void examine_edge(Edge e, const Graph& g) const {
std::cout << "Examining edges " << e << std::endl;
}
}
int main()
int main() {
mygraph g;
add_edge (0, 1, 8, g);
add_edge (0, 3, 18, g);
 add_edge (1, 2, 20, g);
 add_edge (2, 3, 2, g);
 add_edge (3, 1, 1, g);
 add_edge (1, 3, 7, g);
custom_dfs_visitor vis;
 depth_first_search(g, visitor(vis));
}
#include <boost/graph/adjacency_list.hpp>
 #include <boost/graph/depth_first_search.hpp>
 #include <iostream>
 using namespace std;
 using namespace boost;
 typedef property<edge_weight_t, int>
 EdgeWeightProperty; 
 typedef boost::adjacency_list
 < listS, vecS, undirectedS, no_property, EdgeWeightProperty>
 mygraph;
 class custom_dfs_visitor : public boost::default_dfs_visitor 
 { public: template < typename Vertex, typename Graph >
  void discover_vertex(Vertex u, const Graph & g)
  const { std::cout << "At " << u << std::endl; }
  template < typename Edge, typename Graph >
  void examine_edge(Edge e, const Graph& g) 
 const { std::cout << "Examining edges " << e << std::endl;
 } 
}; 
int main() 
{
 mygraph g; add_edge (0, 1, 8, g);
 add_edge (0, 3, 18, g);
 add_edge (1, 2, 20, g);
 add_edge (2, 3, 2, g);
 add_edge (3, 1, 1, g);
 add_edge (1, 3, 7, g);
 custom_dfs_visitor vis;
 depth_first_search(g, visitor(vis));
}
